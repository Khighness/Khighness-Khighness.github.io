<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>红黑树 | Khighness</title><meta name="keywords" content="RedBlackTree"><meta name="author" content="Khighness"><meta name="copyright" content="Khighness"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="📓 定义红黑树是一种含有红黑节点并能自平衡的二叉查找树  🌲二叉查找树 满足约束：左结点的值小于父结点，父结点的值小于右结点的值。 场景理解：假设二叉查找树建立在x-y笛卡尔坐标系中，则所有结点向x轴投影，值正好沿着x轴递增。      🔰 性质 每个结点要么是黑色，要么是红色 根节点是黑色 每个叶子结点(NIL)是黑色的(虚结点) 每个红色结点的两个子结点一定都是黑色 任意一结点到每个叶子">
<meta property="og:type" content="article">
<meta property="og:title" content="红黑树">
<meta property="og:url" content="https://www.parak.top/posts/f89cb603/index.html">
<meta property="og:site_name" content="Khighness">
<meta property="og:description" content="📓 定义红黑树是一种含有红黑节点并能自平衡的二叉查找树  🌲二叉查找树 满足约束：左结点的值小于父结点，父结点的值小于右结点的值。 场景理解：假设二叉查找树建立在x-y笛卡尔坐标系中，则所有结点向x轴投影，值正好沿着x轴递增。      🔰 性质 每个结点要么是黑色，要么是红色 根节点是黑色 每个叶子结点(NIL)是黑色的(虚结点) 每个红色结点的两个子结点一定都是黑色 任意一结点到每个叶子">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Khighness/images/top/bg-9.jpg">
<meta property="article:published_time" content="2020-11-06T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-01T08:57:43.283Z">
<meta property="article:author" content="Khighness">
<meta property="article:tag" content="RedBlackTree">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Khighness/images/top/bg-9.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/K.jpg"><link rel="canonical" href="https://www.parak.top/posts/f89cb603/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//s4.cnzz.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16576652";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" data-pjax="data-pjax" src="https://s4.cnzz.com/z_stat.php?id=1279324689&amp;web_id=1279324689"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Khighness","link":"链接: ","source":"来源: Khighness","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-01 16:57:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/iconfont/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Khighness" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/Khighness.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Khighness/images/top/bg-9.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Khighness</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">红黑树</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-06T16:00:00.000Z" title="发表于 2020-11-07 00:00:00">2020-11-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-01T08:57:43.283Z" title="更新于 2021-06-01 16:57:43">2021-06-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Algorithm/">Algorithm</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="红黑树"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="📓-定义"><a href="#📓-定义" class="headerlink" title="📓 定义"></a>📓 定义</h2><p>红黑树是一种含有红黑节点并能自平衡的二叉查找树</p>
<blockquote>
<p>🌲二叉查找树</p>
<p>满足约束：左结点的值小于父结点，父结点的值小于右结点的值。</p>
<p>场景理解：假设二叉查找树建立在x-y笛卡尔坐标系中，则所有结点向x轴投影，值正好沿着x轴递增。</p>
</blockquote>
<br>



<h2 id="🔰-性质"><a href="#🔰-性质" class="headerlink" title="🔰 性质"></a>🔰 性质</h2><ul>
<li>每个结点要么是黑色，要么是红色</li>
<li>根节点是黑色</li>
<li>每个叶子结点(NIL)是黑色的(虚结点)</li>
<li>每个红色结点的两个子结点一定都是黑色</li>
<li>任意一结点到每个叶子结点的路径都包含数量相同的黑结点(黑色完美平衡)</li>
</ul>
<p>以上为最简性质，任何一条不可缺少，任意四条不能推出另外一条。</p>
<br>

<h2 id="🌗-平衡"><a href="#🌗-平衡" class="headerlink" title="🌗 平衡"></a>🌗 平衡</h2><p>红黑树是非完美平衡二叉查找树，是完美黑色平衡二叉查找树。</p>
<br>

<blockquote>
<p>⭕红黑树自平衡的最小单元</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/f89cb603/image-20201106225159861.png" class="" title="image-20201106225159861">

<p>红黑树的自平衡</p>
<p>插入只考虑G-{P, U}-C三代，删除只考虑P-{C, B}-{CL, CR, BL, BR}三代</p>
<br>

<blockquote>
<p>🔱红黑树自平衡的原子操作</p>
</blockquote>
<p>包括：变色、左旋、右旋</p>
<p>旋转要有圆心，有方向。</p>
<p>旋转结点是父结点围绕子节点旋转(子节点为圆心)。</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/f89cb603/image-20201103220142748.png" class="" title="image-20201103220142748">

<center>
    <font face="Kristen ITC" color="#555555" font-size=100px>☬ 旋转结点 ☬</font><br>
</center>

<br>

<blockquote>
<p>🌐变色：P-Black=&gt;Red,CB-Red=&gt;Black</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/f89cb603/image-20201103221816468.png" class="" title="image-20201103221816468">

<center>
    <font face="Kristen ITC" color="#555555" font-size=100px>☬ 变色操作 ☬</font><br>
</center>

<br>

<blockquote>
<p>🌔左旋：旋转结点绕圆心逆时针方向旋转。基于最短路径来确定方向。</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/f89cb603/image-20201103222025132.png" class="" title="image-20201103222025132">

<center>
    <font face="Kristen ITC" color="#555555" font-size=100px>☬ 左旋操作 ☬</font><br>
</center>

<br>

<pre><code class="java">    /**
     * &lt;p&gt;左旋&lt;/p&gt;
     * &lt;p&gt;过程：父亲下沉，右子上升，右子的左子变为原父的右子&lt;/p&gt;
     * &lt;p&gt;
     *     左旋X结点
     *             P                                P
     *            /                                /
     *           X                                Y
     *         /  \        --(左旋)--&gt;           / \
     *       lX    Y                           X  rY
     *            / \                        /  \
     *          lY   rY                     lX  lY
     * &lt;/p&gt;
     * @param x
     */
    public void leftRotate(RBTNode&lt;T, D&gt; x) &#123;
        /* 右子结点 */
        RBTNode&lt;T, D&gt; y = x.getRight();
        /* 父亲结点 */
        RBTNode&lt;T, D&gt; p = x.getParent();

        /* Y的左子 变成 X的右子
        * 若X不Y的左子不为空
        * 则设置Y的左子的父亲为X */
        x.setRight(y.getLeft());
        if (y.getLeft() != null) &#123;
            y.getLeft().setParent(x);
        &#125;

        /* 设置Y的父亲为P
        * 1. P为空，则根节点设置为Y
        * 2. X为P的左子， 则P的左子设置为Y
        * 3. X为P的右子，则P的右子设置为Y */
        y.setParent(p);
        if (p == null) &#123;
            this.root = y;
        &#125; else &#123;
            if (p.getLeft() == x) &#123;
                p.setLeft(y);
            &#125; else &#123;
                p.setRight(y);
            &#125;
        &#125;

        /* 将X的父亲设置为Y
        * 将Y的左子设置为X */
        x.setParent(y);
        y.setLeft(x);
    &#125;</code></pre>
<blockquote>
<p>🌖右旋：旋转结点绕圆心顺时针方向旋转。基于最短路径确定方向。</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/f89cb603/image-20201103223223997.png" class="" title="image-20201103223223997">

<center>
    <font face="Kristen ITC" color="#555555" font-size=100px>☬ 右旋操作 ☬</font><br>
</center>

<br>

<pre><code class="java">    /**
     * &lt;p&gt;右旋&lt;/p&gt;
     * &lt;p&gt;过程：父亲下沉，左子上升，左子的右子变成原父的左子&lt;/p&gt;
     * &lt;p&gt;
     *     右旋X结点
     *             P                                P
     *            /                                /
     *           X                                Y
     *         /  \        --(右旋)--&gt;           /  \
     *        Y   rX                           lY   X
     *       / \                                   / \
     *     lY  rY                                rY  rX
     * &lt;/p&gt;
     * @param x
     */
    public void rightRotate(RBTNode&lt;T, D&gt; x) &#123;
        /* 左子结点 */
        RBTNode&lt;T, D&gt; y = x.getLeft();
        /* 父亲结点 */
        RBTNode&lt;T, D&gt; p = x.getParent();

        /* Y的右子 变成 X的左子
        * 若Y的右子不为空
        * 则设置Y的右子的父亲为X */
        x.setLeft(y.getRight());
        if (y.getRight() != null) &#123;
            y.getRight().setParent(x);
        &#125;

        /* 设置Y的父亲为P
         * 1. P为空，则根节点设置为Y
         * 2. X为P的左子， 则P的左子设置为Y
         * 3. X为P的右子，则P的右子设置为Y */
        y.setParent(p);
        if (p == null) &#123;
            this.root = y;
        &#125; else &#123;
            if (p.getLeft() == x) &#123;
                p.setLeft(y);
            &#125; else &#123;
                p.setRight(y);
            &#125;
        &#125;

        /* 将X的父亲设置为Y
        * 将Y的右子设置为X */
        x.setParent(y);
        y.setRight(x);
    &#125;</code></pre>
<br>

<h2 id="🌀-增删"><a href="#🌀-增删" class="headerlink" title="🌀 增删"></a>🌀 增删</h2><br>

<blockquote>
<p>➕插入结点</p>
</blockquote>
<p>新增结点默认为红色，避免破坏黑色完美平衡。</p>
<p>首先寻找新结点的插入位置，即找到新结点的父亲，然后决定将新结点插入到父亲的左边还是右边。</p>
<pre><code class="java">    /**
     * &lt;p&gt;插入结点&lt;/p&gt;
     * @param key
     * @param data
     */
    public void insertNode(T key, D data) &#123;
        int cmp;
        RBTNode&lt;T, D&gt; x = this.root;
        RBTNode&lt;T, D&gt; y = null;

        /* 寻找新结点的插入位置 */
        while (x != null) &#123;
            y = x;
            cmp = key.compareTo(x.getKey());

            if (cmp == 0) &#123;
                /* key已存在，直接更新 */
                System.out.println(getCurrentTime() + &quot; [WARN] key已存在&quot;);
                System.out.println(getCurrentTime() + &quot; [INFO] 更新value: &quot; + get(key) + &quot; =&gt; &quot; + data);
                return;
            &#125; else if (cmp &gt; 0)&#123;
                /* key较大，继续向右查询 */
                x = x.getRight();
            &#125; else if (cmp &lt; 0) &#123;
                /* key较小，继续向左查询 */
                x = x.getLeft();
            &#125;
        &#125;

        /* 生成一个新的结点 */
        RBTNode&lt;T, D&gt; node = new RBTNode&lt;&gt;(RBTColor.red, key, data, null, null, null);
        System.out.println(getCurrentTime() + &quot; [INFO] 新增结点 (&quot; + key + &quot;, &quot; + data + &quot;)&quot;);
        /* 总结点数量+1 */
        this.count.incrementAndGet();
        /* 设置新结点的父亲为Y */
        node.setParent(y);

        /* 再次比较决定新结点是y的左子还是右子*/
        if (y == null) &#123;
            this.root = node;
        &#125; else &#123;
            cmp = key.compareTo(y.getKey());
            if (cmp &gt; 0) &#123;
                y.setRight(node);
            &#125; else &#123;
                y.setLeft(node);
            &#125;
        &#125;

        /* 最后进行自平衡 */
        balanceInsertion(node);
    &#125;</code></pre>
<br>

<blockquote>
<p>💉插入修复</p>
</blockquote>
<p>插入结点为红色，因此只有当父亲结点为红色时才需要修复。</p>
<p>G-祖父、P-父亲、U-叔叔、C-插入。</p>
<p>我总结了五种情况以及解决口诀:</p>
<p>（1）叔叔为红</p>
<p>CASE 1</p>
<p>Description: 叔叔为红</p>
<p>Solution: GPU变色，若不满足红黑树约束则递归变色</p>
<br>

<p>（2）叔叔为黑</p>
<p>CASE 2</p>
<p>Description: 父为左子，GPC三点一线</p>
<p>Solution: 右旋祖父，GP变色</p>
<pre><code class="java">         (1) 右旋祖父结点
           黑祖                        红父
           / \                         / \
        红父  黑叔    --(右旋)--&gt;    红插  黑祖
         /                                 \
       红插                                黑叔
         (2) 祖父和父亲变色
           红父                        黑父
           / \                         / \
        红插  黑祖    --(变色)--&gt;    红插  红祖
              \                            \
              黑叔                         黑叔</code></pre>
<br>

<p>CASE 3: </p>
<p>Description: 父为左子，GPC三角关系</p>
<p>Solution: 左旋父亲，交换PC，右旋祖父，GP变色</p>
<pre><code class="java">         (1) 左旋父亲结点，并且交换父子身份，此时GPC三点一线
          黑祖                        黑祖                        黑祖
          / \                         / \                        / \
       红父  黑叔    --(左旋)--&gt;    红插  黑叔    --(交换)--&gt;    红父  黑叔
        \                          /                           /
        红插                     红父                         红插
        (2) 右旋祖父结点
          黑祖                        红父
          / \                         / \
       红父  黑叔    --(右旋)--&gt;    红插  黑祖
        /                                 \
      红插                                黑叔
        (3) 祖父和父亲变色
          红父                        黑父
          / \                         / \
       红插  黑祖    --(变色)--&gt;    红插  红组
              \                           \
              黑叔                        黑叔</code></pre>
<br>

<p>CASE 4</p>
<p>Description: 父为右子，GPC三点一线</p>
<p>Solution: 左旋祖父，GP变色</p>
<pre><code class="java">         (1) 左旋祖父结点
           黑祖                        红父
           / \                         / \
        黑叔  红父    --(右旋)--&gt;    黑祖  红插
               \                     /
               红插                黑叔
         (2) 祖父和父亲变色
           红父                        黑父
           / \                         / \
        黑祖  红插    --(变色)--&gt;    红祖  红插
         /                           /
       黑叔                        黑叔</code></pre>
<br>

<p>CASE 5</p>
<p>Description: 父为右子，GPC三角关系</p>
<p>Solution: 右旋父亲，交换PC，左旋祖父，GP变色</p>
<pre><code class="java">          (1) 右旋父亲结点，并且交换父子身份，此时GPC三点一线
           黑祖                        黑祖                        黑祖
           / \                         / \                        / \
        黑叔  红父    --(右旋)--&gt;    黑祖  红插    --(交换)--&gt;    黑祖  红父
              /                            \                          \
            红插                           红父                        红插
          (2) 左旋祖父
           黑祖                        红父
           / \                         / \
        黑叔  红父    --(左旋)--&gt;    黑祖  红插
               \                    /
               红插               黑叔
          (3) 祖父和父亲变色
           红父                        黑父
           / \                         / \
        黑叔  红插    --(变色)--&gt;    红祖  红插
         /                         /
       黑叔                      黑叔</code></pre>
<br>

<blockquote>
<p>➖删除结点</p>
</blockquote>
<p>三种情况，解决方案主要为寻找后裔顶替自己</p>
<p>CASE 1</p>
<p>Description: 待删结点左子和右子都存在:</p>
<p>Solution: 替代结点为右子树的最左孩子，然后调整关系</p>
<p>CASE 2:</p>
<p>Description: 待删结点没有左子和右子:</p>
<p>Solution: 直接删除，然后调整关系</p>
<p>CASE 3:</p>
<p>Description: 待删结点只有左子或者右子:</p>
<p>Solution: 替代结点为存在的孩子，然后调整关系</p>
<br>

<blockquote>
<p>💉删除修复</p>
</blockquote>
<p>仅删除黑色结点需要修复，删除红色不需要。</p>
<p>P-父亲、D-删除、B-兄弟、BR-兄弟右子、BL-兄弟左子。</p>
<ul>
<li>D为左子<ul>
<li>B为红色：左旋父亲，父亲染红，兄弟染黑，然后continue</li>
<li>B为黑色<ul>
<li>BL为黑色且BR黑色：兄弟染红，父亲回溯</li>
<li>BL为红色且BR为黑色：右旋兄弟，兄弟染红，BL染黑</li>
<li>BR为红色：左旋父亲，父亲的颜色给兄弟，父亲黑化，BR黑化，然后break</li>
</ul>
</li>
</ul>
</li>
<li>D为右子<ul>
<li>B为红色：右旋父亲，父亲染红，兄弟染黑，然后continue</li>
<li>B为黑色：<ul>
<li>BL为黑色且BR为黑色：兄弟染红，父亲回溯</li>
<li>BL为红色且BR为黑色：左旋兄弟，父亲染红，BR染黑</li>
<li>BL为红色：右旋父亲，父亲的颜色给兄弟，父亲黑化，BL黑化，然后break</li>
</ul>
</li>
</ul>
</li>
</ul>
<br>

<h2 id="📑-源码"><a href="#📑-源码" class="headerlink" title="📑 源码"></a>📑 源码</h2><pre><code class="java">package top.parak.DataStructures.RBTree;

import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;

/**
 * &lt;p&gt; Project: Algorithm &lt;/P&gt;
 * &lt;p&gt; Package: top.parak.DataStructures.RBTree &lt;/p&gt;
 * &lt;p&gt; FileName: RBTree &lt;p&gt;
 * &lt;p&gt; Description: 红黑树 &lt;p&gt;
 * &lt;p&gt; Created By IntelliJ IDEA &lt;/p&gt;
 *
 * @author KHighness
 * @since 2020/11/5
 */

/* 红黑颜色 */
enum RBTColor &#123;
    red,
    black
&#125;

/* 红黑结点 */
class RBTNode&lt;T extends Comparable&lt;T&gt;, D&gt; &#123;

    /* 结点颜色 */
    private RBTColor color;
    /* 结点键值 */
    private T key;
    /* 结点数据 */
    private D data;
    /* 父亲结点 */
    private RBTNode&lt;T, D&gt; parent;
    /* 左子结点 */
    private RBTNode left;
    /* 右子结点 */
    private RBTNode right;

    public RBTNode(RBTColor color, T key, D data, RBTNode&lt;T, D&gt; parent, RBTNode left, RBTNode right) &#123;
        this.color = color;
        this.key = key;
        this.data = data;
        this.parent = parent;
        this.left = left;
        this.right = right;
    &#125;

    public RBTColor getColor() &#123;
        if (this != null) &#123;
            return color;
        &#125;
        return null;
    &#125;

    public void setColor(RBTColor color) &#123;
        this.color = color;
    &#125;

    public void updateColor() &#123;
        if (this.color == RBTColor.red) &#123;
            this.color = RBTColor.black;
        &#125; else &#123;
            this.color = RBTColor.red;
        &#125;
    &#125;

    public T getKey() &#123;
        if (this != null) &#123;
            return key;
        &#125;
        return null;
    &#125;

    public void setKey(T key) &#123;
        this.key = key;
    &#125;

    public D getData() &#123;
        if (this != null) &#123;
            return data;
        &#125;
        return null;
    &#125;

    public void setData(D data) &#123;
        this.data = data;
    &#125;

    public RBTNode&lt;T, D&gt; getParent() &#123;
        return parent;
    &#125;

    public void setParent(RBTNode&lt;T, D&gt; parent) &#123;
        this.parent = parent;
    &#125;

    public RBTNode getLeft() &#123;
        if (this != null) &#123;
            return left;
        &#125;
        return null;
    &#125;

    public void setLeft(RBTNode left) &#123;
        this.left = left;
    &#125;

    public RBTNode getRight() &#123;
        if (this != null) &#123;
            return right;
        &#125;
        return null;
    &#125;

    public void setRight(RBTNode right) &#123;
        this.right = right;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;RBTNode[&quot; +
                &quot;color=&quot; + color +
                &quot;, key=&quot; + key +
                &quot;, data=&quot; + data +
                &#39;]&#39;;
    &#125;
&#125;

/* 红黑树 */
public class RedBlackTree&lt;T extends Comparable&lt;T&gt;, D&gt; &#123;

    /* 时间格式 */
    private static final SimpleDateFormat SDF = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);

    /* 根节点 */
    private RBTNode&lt;T, D&gt; root;

    /* 树结点数量 */
    private AtomicLong count = new AtomicLong(0);


    /**
     * &lt;p&gt;获取时间&lt;/p&gt;
     * @return
     */
    private String getCurrentTime() &#123;
        return SDF.format(new Date());
    &#125;

    /**
     * &lt;p&gt;大小&lt;p/&gt;
     * @return
     */
    public long size() &#123;
        return count.get();
    &#125;

    /**
     * &lt;p&gt;查询&lt;/p&gt;
     * @param key
     * @return
     */
    public D get(T key) &#123;
        RBTNode&lt;T, D&gt; node = search(key, this.root);
        return node == null ? null : node.getData();
    &#125;

    /**
     * &lt;p&gt;插入&lt;/p&gt;
     * @param key
     * @param data
     */
    public void add(T key, D data) &#123;
        insertNode(key, data);
    &#125;

    /**
     * &lt;p&gt;删除&lt;/p&gt;
     * @param key
     */
    public void del(T key) &#123;
        RBTNode&lt;T, D&gt; node = search(key, this.root);
        if (node != null) &#123;
            deleteNode(node);
        &#125; else &#123;
            System.out.println(getCurrentTime() + &quot; [ERROR] &quot; + &quot;key为&quot; + key + &quot;的结点不存在&quot;);
        &#125;
    &#125;

    /**
     * &lt;p&gt;root-getter&lt;/p&gt;
     * @return
     */
    public RBTNode&lt;T, D&gt; getRoot() &#123;
        return root;
    &#125;

    /**
     * &lt;p&gt;判断结点是否为红色&lt;/p&gt;
     * @param node
     * @return
     */
    public Boolean isRed(RBTNode&lt;T, D&gt; node) &#123;
        return (node != null &amp;&amp; node.getColor() == RBTColor.red) ? true : false;
    &#125;

    /**
     * &lt;p&gt;判断结点是否为黑色&lt;/p&gt;
     * @param node
     * @return
     */
    public Boolean isBlack(RBTNode&lt;T, D&gt; node) &#123;
        return (node == null || node.getColor() == RBTColor.black) ? true : false;
    &#125;

    /**
     * &lt;p&gt;查询key值的结点&lt;/p&gt;
     * &lt;p&gt;递归查询: 比较key，相等直接返回，过大则继续向右，过小则继续向左&lt;/p&gt;
     * @param key
     * @param node
     * @return
     */
    public RBTNode&lt;T, D&gt; search(T key, RBTNode&lt;T, D&gt; node) &#123;
        if (node != null) &#123;
            int cmp = key.compareTo(node.getKey());
            if (cmp == 0) &#123;
                return node;
            &#125; else if (cmp &gt; 0) &#123;
                return search(key, node.getRight());
            &#125; else if (cmp &lt; 0) &#123;
                return search(key, node.getLeft());
            &#125;
        &#125;
        return null;
    &#125;

    /**
     * &lt;p&gt;左旋&lt;/p&gt;
     * &lt;p&gt;过程：父亲下沉，右子上升，右子的左子变为原父的右子&lt;/p&gt;
     * &lt;p&gt;
     *     左旋X结点
     *             P                                P
     *            /                                /
     *           X                                Y
     *         /  \        --(左旋)--&gt;           / \
     *       lX    Y                           X  rY
     *            / \                        /  \
     *          lY   rY                     lX  lY
     * &lt;/p&gt;
     * @param x
     */
    private void leftRotate(RBTNode&lt;T, D&gt; x) &#123;
        /* 右子结点 */
        RBTNode&lt;T, D&gt; y = x.getRight();
        /* 父亲结点 */
        RBTNode&lt;T, D&gt; p = x.getParent();

        /* Y的左子 变成 X的右子
        * 若X不Y的左子不为空
        * 则设置Y的左子的父亲为X */
        x.setRight(y.getLeft());
        if (y.getLeft() != null) &#123;
            y.getLeft().setParent(x);
        &#125;

        /* 设置Y的父亲为P
        * 1. P为空，则根节点设置为Y
        * 2. X为P的左子， 则P的左子设置为Y
        * 3. X为P的右子，则P的右子设置为Y */
        y.setParent(p);
        if (p == null) &#123;
            this.root = y;
        &#125; else &#123;
            if (p.getLeft() == x) &#123;
                p.setLeft(y);
            &#125; else &#123;
                p.setRight(y);
            &#125;
        &#125;

        /* 将X的父亲设置为Y
        * 将Y的左子设置为X */
        x.setParent(y);
        y.setLeft(x);
    &#125;

    /**
     * &lt;p&gt;右旋&lt;/p&gt;
     * &lt;p&gt;过程：父亲下沉，左子上升，左子的右子变成原父的左子&lt;/p&gt;
     * &lt;p&gt;
     *     右旋X结点
     *             P                                P
     *            /                                /
     *           X                                Y
     *         /  \        --(右旋)--&gt;           /  \
     *        Y   rX                           lY   X
     *       / \                                   / \
     *     lY  rY                                rY  rX
     * &lt;/p&gt;
     * @param x
     */
    private void rightRotate(RBTNode&lt;T, D&gt; x) &#123;
        /* 左子结点 */
        RBTNode&lt;T, D&gt; y = x.getLeft();
        /* 父亲结点 */
        RBTNode&lt;T, D&gt; p = x.getParent();

        /* Y的右子 变成 X的左子
        * 若Y的右子不为空
        * 则设置Y的右子的父亲为X */
        x.setLeft(y.getRight());
        if (y.getRight() != null) &#123;
            y.getRight().setParent(x);
        &#125;

        /* 设置Y的父亲为P
         * 1. P为空，则根节点设置为Y
         * 2. X为P的左子， 则P的左子设置为Y
         * 3. X为P的右子，则P的右子设置为Y */
        y.setParent(p);
        if (p == null) &#123;
            this.root = y;
        &#125; else &#123;
            if (p.getLeft() == x) &#123;
                p.setLeft(y);
            &#125; else &#123;
                p.setRight(y);
            &#125;
        &#125;

        /* 将X的父亲设置为Y
        * 将Y的右子设置为X */
        x.setParent(y);
        y.setRight(x);
    &#125;

    /**
     * &lt;p&gt;插入结点&lt;/p&gt;
     * @param key
     * @param data
     */
    private void insertNode(T key, D data) &#123;
        int cmp;
        RBTNode&lt;T, D&gt; x = this.root;
        RBTNode&lt;T, D&gt; y = null;

        /* 寻找新结点的插入位置 */
        while (x != null) &#123;
            y = x;
            cmp = key.compareTo(x.getKey());

            if (cmp == 0) &#123;
                /* key已存在，直接更新 */
                System.out.println(getCurrentTime() + &quot; [WARN] key已存在&quot;);
                System.out.println(getCurrentTime() + &quot; [INFO] 更新value: &quot; + get(key) + &quot; =&gt; &quot; + data);
                return;
            &#125; else if (cmp &gt; 0)&#123;
                /* key较大，继续向右查询 */
                x = x.getRight();
            &#125; else if (cmp &lt; 0) &#123;
                /* key较小，继续向左查询 */
                x = x.getLeft();
            &#125;
        &#125;

        /* 生成一个新的结点 */
        RBTNode&lt;T, D&gt; node = new RBTNode&lt;&gt;(RBTColor.red, key, data, null, null, null);
        System.out.println(getCurrentTime() + &quot; [INFO] 新增结点 (&quot; + key + &quot;, &quot; + data + &quot;)&quot;);
        /* 总结点数量+1 */
        this.count.incrementAndGet();
        /* 设置新结点的父亲为Y */
        node.setParent(y);

        /* 再次比较决定新结点是y的左子还是右子*/
        if (y == null) &#123;
            this.root = node;
        &#125; else &#123;
            cmp = key.compareTo(y.getKey());
            if (cmp &gt; 0) &#123;
                y.setRight(node);
            &#125; else &#123;
                y.setLeft(node);
            &#125;
        &#125;

        /* 最后进行自平衡 */
        balanceInsertion(node);
    &#125;

    /**
     * &lt;p&gt;插入结点的自平衡操作&lt;/p&gt;
     * &lt;p&gt;由于插入节点默认颜色为红色，所以只有父结点为红色时候才需要修复
     *   分三种情况讨论&lt;/p&gt;
     * &lt;li&gt;case1. 叔叔结点也为红色&lt;/li&gt;
     * &lt;li&gt;case2. 叔叔结点为空，且祖父子三点一线&lt;/li&gt;
     * &lt;li&gt;case3. 叔叔结点为空，且祖父子三角关系&lt;/li&gt;
     * &lt;p&gt;G-祖父、P-父亲、U-叔叔、C-插入&lt;/p&gt;
     * @param node
     */
    private void balanceInsertion(RBTNode&lt;T, D&gt; node) &#123;
        /* 父亲 · 祖父 */
        RBTNode&lt;T, D&gt; paren, grand;

        /* 当父亲节点为黑色时，结束修复 */
        while (((paren = node.getParent()) != null) &amp;&amp; isRed(paren)) &#123;
            grand = paren.getParent();

            /* 确定父亲和叔叔的左右关系 */

            /* CASE: 父左叔右 */
            if (grand.getLeft() == paren) &#123;
                RBTNode&lt;T, D&gt; uncle = grand.getRight();

                /**
                 * case1: PU双红
                 * solution1: GPU变色
                 * 如果此时整棵树不满足约束，则递归进行GPU变色
                 */
                if (isRed(uncle)) &#123;
                    grand.setColor(RBTColor.red);
                    paren.setColor(RBTColor.black);
                    uncle.setColor(RBTColor.black);
                    node = grand;
                    continue;
                &#125;
                /*
                 * case2: P红U黑，父为左子，GPC三点一线
                 * solution2: 右旋祖父，GP变色
                 *         (1) 右旋祖父结点
                 *           黑祖                        红父
                 *           / \                         / \
                 *        红父  黑叔    --(右旋)--&gt;    红插  黑祖
                 *         /                                 \
                 *       红插                                黑叔
                 *         (2) 祖父和父亲变色
                 *           红父                        黑父
                 *           / \                         / \
                 *        红插  黑祖    --(变色)--&gt;    红插  红祖
                 *              \                            \
                 *              黑叔                         黑叔
                 *
                 *
                * case3: P红U黑，父为左子，GPC三角关系
                * solution3: 左旋父亲，交换PC，右旋祖父，GP变色
                *         (1) 左旋父亲结点，并且交换父子身份，此时GPC三点一线
                *          黑祖                        黑祖                        黑祖
                *          / \                         / \                        / \
                *       红父  黑叔    --(左旋)--&gt;    红插  黑叔    --(交换)--&gt;    红父  黑叔
                *        \                          /                           /
                *        红插                     红父                         红插
                *        (2) 右旋祖父结点
                *          黑祖                        红父
                *          / \                         / \
                *       红父  黑叔    --(右旋)--&gt;    红插  黑祖y
                *        /                                 \
                *      红插                                黑叔
                *        (3) 祖父和父亲变色
                *          红父                        黑
                *          / \                         / \
                *       红插  黑祖    --(变色)--&gt;    红插  红组
                *              \                           \
                *              黑叔                        黑叔
                 *
                 * attention:
                 * 三角关系经过一步旋转即可转换成三点一线
                 * 因此case3先经过一步处理到case2，再进行case2的处理
                 */
                else &#123;
                    if (paren.getRight() == node) &#123; // case3
                        leftRotate(paren);
                        RBTNode&lt;T, D&gt; temp = node;
                        node = paren;
                        paren = temp;
                    &#125; // case2
                    rightRotate(grand);
                    grand.updateColor();
                    paren.updateColor();
                &#125;
            &#125;
            /* CASE: 父右叔左 */
            else &#123;
                RBTNode&lt;T, D&gt; uncle = grand.getLeft();

                /**
                 * case1: PU双红(父亲和叔叔都为红色)
                 * solution1: GPU变色(祖父变为红色，父亲和叔叔都变为黑色)
                 * 如果此时整棵树不满足约束，则递归进行GPU变色
                 */
                if (isRed(uncle)) &#123;
                    grand.setColor(RBTColor.red);
                    paren.setColor(RBTColor.black);
                    uncle.setColor(RBTColor.black);
                    node = grand;
                    continue;
                &#125;
                /*
                 * case4: P红U黑，父为左子，GPC三点一线
                 * solution4: 左旋祖父，GP变色
                 *         (1) 左旋祖父结点
                 *           黑祖                        红父
                 *           / \                         / \
                 *        黑叔  红父    --(右旋)--&gt;    黑祖  红插
                 *               \                     /
                 *               红插                黑叔
                 *          (2) 祖父和父亲变色
                 *           红父                        黑父
                 *           / \                         / \
                 *        黑祖  红插    --(变色)--&gt;    红祖  红插
                 *         /                           /
                 *       黑叔                        黑叔
                 *
                 * case5: P红U黑，父为右子，GPC三角关系
                 * solution5: 右旋父亲，交换PC，左旋祖父，GP变色
                 *          (1) 右旋父亲结点，并且交换父子身份，此时GPC三点一线
                 *           黑祖                        黑祖                        黑祖
                 *           / \                         / \                        / \
                 *        黑叔  红父    --(右旋)--&gt;    黑祖  红插    --(交换)--&gt;    黑祖  红父
                 *              /                            \                          \
                 *            红插                           红父                        红插
                 *          (2) 左旋祖父
                 *           黑祖                        红父
                 *           / \                         / \
                 *        黑叔  红父    --(左旋)--&gt;    黑祖  红插
                 *               \                    /
                 *               红插               黑叔
                 *          (3) 祖父和父亲变色
                 *           红父                        黑父
                 *           / \                         / \
                 *        黑叔  红插    --(变色)--&gt;    红祖  红插
                 *         /                         /
                 *       黑叔                      黑叔
                 *
                 * attention:
                 * 三角关系经过一步旋转即可转换成三点一线
                 * 因此case3先经过一步处理到case2，再进行case2的处理
                 */
                else &#123;
                    if (paren.getLeft() == node) &#123; // case3
                        rightRotate(paren);
                        RBTNode&lt;T, D&gt; temp = node;
                        node = paren;
                        paren = temp;
                    &#125; // case2
                    leftRotate(grand);
                    grand.updateColor();
                    paren.updateColor();
                &#125;
            &#125;
        &#125;

        /* 保证根节点为黑色 */
        if (root == node) &#123;
            node.setColor(RBTColor.black);
        &#125;
    &#125;

    /**
     * &lt;p&gt;删除结点&lt;/p&gt;
     * &lt;p&gt;三种情况&lt;/p&gt;
     * &lt;li&gt;case1. 待删结点左子和右子都存在&lt;/li&gt;
     * &lt;li&gt;case2. 待删结点没有左子和右子&lt;/li&gt;
     * &lt;li&gt;case3. 待删结点只有左子或者右子&lt;/li&gt;
     * @param node
     */
    private void deleteNode(RBTNode&lt;T, D&gt; node) &#123;
        /* 父亲 · 儿子 · 继承者 */
        RBTNode&lt;T, D&gt; paren, child, replace;
        RBTColor color;

        /*
         * case1: 待删结点左子和右子都存在
         * solution1:
         * - 找到该结点的右子树中的最左子结点
         * - 把它的值和要删除的结点的值进行交换
         * - 然后删除这个结点即相当于删除所需删除结点
         */
        if ((node.getLeft() != null) &amp;&amp; (node.getRight() != null))  &#123;

            /*  获取其后继结点: 右子树中的最左子结点 */
            replace = descendants(node);
            paren = replace.getParent();
            child = replace.getRight();
            color = replace.getColor();

            if (node == replace.getParent()) &#123;
                /**
                 * case:
                 *    node              replace
                 *      \                  \
                 *      replace    --&gt;    child
                 *         \
                 *         child
                 */
                paren = replace;
            &#125; else &#123;
                /**
                 * case:
                 *     node                replace
                 *       \                   \
                 *        X                   X
                 *       / \                 / \
                 *  paren   X    --&gt;    paren   X
                 *     /                  /
                 *  replace            child
                 *     \
                 *     child
                 *
                 */
                /* 建立替代结点的父亲与替换结点的右子的父子关系，即爷孙変父子 */
                if (child != null) &#123;
                    child.setParent(replace.getParent());
                &#125;
                replace.getParent().setLeft(child);
                /* 建立替代节点与待删节点的右子的父子关系 */
                replace.setRight(node.getRight());
                node.getRight().setParent(replace);
            &#125;

            /* 待删节点的父亲设置为替代结点的父亲 */
            replace.setParent(node.getParent());
            /* 建立替换结点与待删节点左子的父子关系 */
            replace.setLeft(node.getLeft());
            node.getLeft().setParent(replace);
            /* 替代结点沿用待删节点的颜色 */
            replace.setColor(node.getColor());

            /* 待删结点的父亲不为空，则调整左右子 */
            if (node.getParent() != null) &#123;
                if (node.getParent().getLeft() == node) &#123;
                    node.getParent().setLeft(replace);
                &#125; else &#123;
                    node.getParent().setRight(replace);
                &#125;
            &#125;
            /* 待删结点的父亲为空，则设置根结点 */
            else &#123;
                this.root = replace;
            &#125;

            /* 删除黑色结点需要调整平衡，红色不需要 */
            if (color == RBTColor.black) &#123;
                balanceDeletion(child, paren);
            &#125;
        &#125;
        /**
         * case2: 待删结点没有左子和右子
         * solution2: 直接删除结点
         */
        else if((node.getLeft() == null) &amp;&amp; (node.getRight() == null)) &#123;
            paren = node.getParent();
            if (node == paren.getLeft()) &#123;
                paren.setLeft(node.getLeft());
            &#125; else &#123;
                paren.setRight(node.getRight());
            &#125;
        &#125;
        /**
         * case3: 待删结点只有左子或者右子
         * solution3: 待删节点的父亲指向存在的子嗣
         */
        else &#123;
            /* 确定替代结点 */
            if (node.getLeft() != null) &#123;
                replace = node.getLeft();
            &#125; else &#123;
                replace = node.getRight();
            &#125;

            /* 待删结点的父亲 */
            paren = node.getParent();

            /* 待删结点的父亲是否为空 */
            if (paren != null) &#123;
                if (paren.getLeft() == node) &#123;
                    paren.setLeft(replace);
                &#125; else &#123;
                    paren.setRight(replace);
                &#125;
            &#125; else &#123;
                this.root = replace;
            &#125;

            /* 待删节点的父亲指向替代结点 */
            replace.setParent(paren);

            color = node.getColor();
            child = replace;

            /* 删除黑色结点需要调整平衡，红色不需要 */
            if (color == RBTColor.black) &#123;
                balanceDeletion(child, paren);
            &#125;
        &#125;

        /* 结点数量-1 */
        count.decrementAndGet();
        System.out.println(getCurrentTime() + &quot; [INFO] key为&quot; + node.getKey() + &quot;的结点删除成功&quot;);
    &#125;

    /**
     * &lt;p&gt;寻找继承的后裔&lt;/p&gt;
     * @param node
     * @return
     */
    public RBTNode&lt;T, D&gt; descendants(RBTNode&lt;T, D&gt; node) &#123;
        /* 查询大于该节点的最小结点，即右子树的最左结点 */
        if (node.getRight() != null) &#123;
            RBTNode&lt;T, D&gt; right = node.getRight();
            if (right.getLeft() == null) &#123;
                return right;
            &#125;
            while (right.getLeft() != null) &#123;
                right = right.getLeft();
            &#125;
            return right;
        &#125;

        /* @deprecated */
        RBTNode&lt;T, D&gt; paren = node.getParent();
        while ((paren != null) &amp;&amp; (paren.getRight() == node)) &#123;
            node = paren;
            paren = paren.getParent();
        &#125;
        return paren;
    &#125;


    /**
     * &lt;p&gt;删除结点的自平衡操作&lt;/p&gt;
     * &lt;p&gt;
     * P-父亲、D-删除、B-兄弟、BR-兄弟右子、BL-兄弟左子。
     *
     * - D为左子
     *   - B为红色：左旋父亲，父亲染红，兄弟染黑，然后continue
     *   - B为黑色
     *     - BL为黑色且BR黑色：兄弟染红，父亲回溯
     *     - BL为红色且BR为黑色：右旋兄弟，兄弟染红，BL染黑
     *     - BR为红色：左旋父亲，父亲的颜色给兄弟，父亲黑化，BR黑化，然后break
     * - D为右子
     *   - B为红色：右旋父亲，父亲染红，兄弟染黑，然后continue
     *   - B为黑色：
     *     - BL为黑色且BR为黑色：兄弟染红，父亲回溯
     *     - BL为红色且BR为黑色：左旋兄弟，父亲染红，BR染黑
     *     - BL为红色：右旋父亲，父亲的颜色给兄弟，父亲黑化，BL黑化，然后break
     * &lt;/p&gt;
     *
     * @param node
     * @param paren
     * &lt;p&gt;
     *     入参情况:
     *     1. node=替换节点 paren=替换节点的父亲节点
     *     2. node=替换节点的孩子节点 paren=替换节点
     *     3. node=替换节点的孩子节点 parent=替换节点的父节点
     * &lt;/p&gt;
     */
    private void balanceDeletion(RBTNode&lt;T, D&gt; node, RBTNode&lt;T, D&gt; paren) &#123;
        RBTNode&lt;T, D&gt; broth;

        while (isBlack(node) &amp;&amp; node != this.root) &#123;

            if (paren.getLeft() == node) &#123;
                broth = paren.getRight();

                /**
                 * case1: D为左子。B为红色
                 * solution1: 左旋父亲，父亲染红，兄弟染黑，然后continue
                 */
                if (isRed(broth)) &#123;
                    leftRotate(paren);
                    paren.setColor(RBTColor.red);
                    broth.setColor(RBTColor.black);
                    continue;
                &#125; else &#123;
                    /**
                     * case2: D为左子。B为黑色，BL为黑色且BR为黑色
                     * solution2: 兄弟染红，父亲回溯
                     */
                    if (isBlack(broth.getLeft()) &amp;&amp; isBlack(broth.getRight())) &#123;
                        broth.setColor(RBTColor.red);
                        node = paren;
                        paren = paren.getParent();
                    &#125;
                    /**
                     * case3: D为左子。B为黑色，BL为红色且BR为黑色
                     * solution3: 右旋兄弟，兄弟染红，BL染黑
                     */
                    else if (isRed(broth.getLeft()) &amp;&amp; isBlack(broth.getRight())) &#123;
                        rightRotate(broth);
                        broth.setColor(RBTColor.red);
                        broth.getLeft().setColor(RBTColor.black);
                    &#125;
                    /**
                     * case4: D为左子，B为黑色，BR为红色
                     * solution4: 左旋父亲，父亲的颜色给兄弟，父亲黑化，BR黑化，然后break
                     */
                    else if (isRed(broth.getRight())) &#123;
                        leftRotate(paren);
                        broth.setColor(paren.getColor());
                        paren.setColor(RBTColor.black);
                        broth.getRight().setColor(RBTColor.black);
                        break;
                    &#125;
                &#125;
            &#125; else &#123;
                broth = paren.getLeft();

                /**
                 * case5: D为右子。B为红色
                 * solution5: 右旋父亲，父亲染红，兄弟染黑，然后continue
                 */
                if (isRed(broth)) &#123;
                    rightRotate(paren);
                    paren.setColor(RBTColor.red);
                    broth.setColor(RBTColor.black);
                &#125; else &#123;
                    /**
                     * case6: D为右子。B为黑色，BL为黑色且BR为黑色
                     * solution6: 兄弟染红，父亲回溯
                     */
                    if (isBlack(broth.getLeft()) &amp;&amp; isBlack(broth.getRight())) &#123;
                        broth.setColor(RBTColor.red);
                        node = paren;
                        paren = paren.getParent();
                    &#125;
                    /**
                     * case7: D为右子。B为黑色，BL为红色且BR为黑色
                     * solution7: 左旋兄弟，父亲染红，BR染黑
                     */
                    else if (isRed(broth.getLeft()) &amp;&amp; isBlack(broth.getRight())) &#123;
                        leftRotate(broth);
                        paren.setColor(RBTColor.red);
                        broth.getRight().setColor(RBTColor.black);
                    &#125;
                    /**
                     * case8: D为右子，B为黑色，BR为红色
                     * solution8: 右旋父亲，父亲的颜色给兄弟，父亲黑化，BL黑化，然后break
                     */
                    else if (isRed(broth.getRight())) &#123;
                        rightRotate(paren);
                        broth.setColor(paren.getColor());
                        paren.setColor(RBTColor.black);
                        broth.getRight().setColor(RBTColor.black);
                        break;
                    &#125;
                &#125;
            &#125;

        &#125;

        /* node染成被删结点的颜色 */
        node.setColor(RBTColor.black);
    &#125;

    /**
     * &lt;p&gt;层次遍历&lt;/p&gt;
     */
    public void levelOrder() &#123;
        List&lt;List&lt;RBTNode&lt;T, D&gt;&gt;&gt; levelList = levelOrder(this.root);
        for (List&lt;RBTNode&lt;T, D&gt;&gt; list:levelList) &#123;
            for (RBTNode node : list) &#123;
                System.out.print(node.getKey() + &quot; &quot;);
            &#125;
            System.out.println();
        &#125;
    &#125;

    /**
     * &lt;p&gt;层次遍历&lt;/p&gt;
     * @param node
     * @return
     */
    private List&lt;List&lt;RBTNode&lt;T, D&gt;&gt;&gt; levelOrder(RBTNode&lt;T, D&gt; node) &#123;
        List&lt;List&lt;RBTNode&lt;T, D&gt;&gt;&gt; res = new LinkedList&lt;&gt;();
        Queue&lt;RBTNode&lt;T, D&gt;&gt; queue = new LinkedList&lt;&gt;();
        queue.add(node);
        while (!queue.isEmpty()) &#123;
            int count = queue.size();
            List&lt;RBTNode&lt;T, D&gt;&gt; cur = new LinkedList&lt;&gt;();
            while (count != 0) &#123;
                RBTNode&lt;T, D&gt; temp = queue.poll();
                cur.add(temp);
                if (temp.getLeft() != null) queue.add(temp.getLeft());
                if (temp.getRight() != null) queue.add(temp.getRight());
                count--;
            &#125;
            res.add(cur);
        &#125;
        return res;
    &#125;

    /**
     * &lt;p&gt;输出红黑树的层级结构&lt;/p&gt;
     */
    public void printRBTreeLevel() &#123;
        System.out.println(getCurrentTime() + &quot; [INFO] 开始打印红黑树的层级结构&quot;);
        ConcurrentHashMap&lt;Integer, List&lt;RBTNode&gt;&gt; map = showTree();
        int size = map.size();

        for (int i = 0; i &lt; map.size(); i++) &#123;
            System.out.println();
            for (int j = 0; j &lt; map.get(i).size(); j++) &#123;
                System.out.print( makeSpace(size, i) +
                        (map.get(i).get(j).getKey() == null ? &quot; &quot; : (map.get(i).get(j).getKey()) + (map.get(i).get(j).getColor() == RBTColor.black ? &quot;(黑)&quot; : &quot;(红)&quot;)) + makeSpace(size, i));
            &#125;
            System.out.println();
        &#125;
        System.out.println(getCurrentTime() + &quot; [INFO] 红黑树的层级结构打印完毕&quot;);
    &#125;

    /**
     * &lt;p&gt;输出整棵树的Graphviz结构&lt;/p&gt;
     */
    public void printGraphviz()&#123;
        System.out.println(getCurrentTime() + &quot; [INFO] 开始打印树的Graphviz结构&quot;);
        ConcurrentHashMap&lt;Integer, List&lt;RBTNode&gt;&gt; map = showTree();
        int size = map.size();
        System.out.println(&quot;digraph &#123;&quot;);
        for (int i = 0; i &lt; map.size(); i++) &#123;
            for (int j = 0; j &lt; map.get(i).size(); j++) &#123;
                if(map.get(i).get(j).getKey() != null)&#123;
                    System.out.println(map.get(i).get(j).getKey() + &quot; [color=&quot;  + (map.get(i).get(j).getColor()) + &quot;] &quot;);
                &#125;
            &#125;
        &#125;

        for (int i = 0; i &lt; map.size(); i++) &#123;
            for (int j = 0; j &lt; map.get(i).size(); j++) &#123;
                if(map.get(i).get(j).getKey() != null)&#123;
                    if(map.get(i).get(j).getLeft() != null)&#123;
                        System.out.println(map.get(i).get(j).getKey() + &quot;-&gt;&quot; + map.get(i).get(j).getLeft().getKey() + &quot;[label=left]&quot;);
                    &#125;
                    if(map.get(i).get(j).getRight() != null)&#123;
                        System.out.println(map.get(i).get(j).getKey() + &quot;-&gt;&quot; + map.get(i).get(j).getRight().getKey() + &quot;[label=right]&quot;);
                    &#125;
                &#125;
            &#125;
        &#125;
        System.out.println(&quot;&#125;&quot;);
        System.out.println(getCurrentTime() + &quot; [INFO] 树的Graphviz结构打印完毕&quot;);
    &#125;

    public String makeSpace(int size, int index)&#123;
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i &lt; 1 &lt;&lt; (size - index); i++) &#123;
            builder.append(&quot;  &quot;);
        &#125;
        return builder.toString();
    &#125;

    public ConcurrentHashMap&lt;Integer, List&lt;RBTNode&gt;&gt; showTree()&#123;
        ConcurrentHashMap&lt;Integer, List&lt;RBTNode&gt;&gt; map = new ConcurrentHashMap&lt;&gt;();
        showTree(root, 0, map);
        return map;
    &#125;

    public void showTree(RBTNode root, int count, ConcurrentHashMap&lt;Integer, List&lt;RBTNode&gt;&gt; map)&#123;
        if (map.get(count) == null)&#123;
            map.put(count, new ArrayList&lt;&gt;());
        &#125;
        map.get(count).add(root);

        if (root.getLeft() != null)&#123;
            showTree(root.getLeft(), count+1 , map);
        &#125; else&#123;
            if(map.get(count+1) == null)&#123;
                map.put(count+1, new ArrayList&lt;&gt;());
            &#125;
            map.get(count+1).add(new RBTNode(RBTColor.red, null, null, null, null, null));
        &#125;
        if (root.getRight() != null)&#123;
            showTree(root.getRight(), count+1 , map);
        &#125; else&#123;
            if(map.get(count+1) == null)&#123;
                map.put(count+1, new ArrayList&lt;&gt;());
            &#125;
            map.get(count+1).add(new RBTNode(RBTColor.red, null, null, null, null, null));
        &#125;
    &#125;


    /**
     * &lt;p&gt;菜单&lt;/p&gt;
     */
    public void RBT() &#123;
        RedBlackTree KTree = new RedBlackTree();
        Scanner scanner = new Scanner(System.in);
        while (true) &#123;
            System.out.println((&quot;┏━━━━━━━━━ ▶ ▶ ▶ ▶ ▶ RED ❤ BLACK ◀ ◀ ◀ ◀ ◀ ━━━━━━━━━━┓&quot;));
            System.out.println((&quot;   ✪━━━━━━━━━━━━━━━━━━━ 1. 插入节点 ━━━━━━━━━━━━━━━━━━━✪&quot;));
            System.out.println((&quot;   ✪━━━━━━━━━━━━━━━━━━━ 2. 查询节点 ━━━━━━━━━━━━━━━━━━━✪&quot;));
            System.out.println((&quot;   ✪━━━━━━━━━━━━━━━━━━━ 3. 删除结点 ━━━━━━━━━━━━━━━━━━━✪&quot;));
            System.out.println((&quot;   ✪━━━━━━━━━━━━━━━━━━━ 4. 查询数量 ━━━━━━━━━━━━━━━━━━━✪&quot;));
            System.out.println((&quot;   ✪━━━━━━━━━━━━━━━━━━━ 5. 层次结构 ━━━━━━━━━━━━━━━━━━━✪&quot;));
            System.out.println((&quot;   ✪━━━━━━━━━━━━━━━━━━━ 6. Graphviz ━━━━━━━━━━━━━━━━━━✪&quot;));
            System.out.println((&quot;   ✪━━━━━━━━━━━━━━━━━━━ 7. 退出系统 ━━━━━━━━━━━━━━━━━━━✪&quot;));
            System.out.println((&quot;┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛&quot;));

            System.out.print(getCurrentTime() + &quot; [input] 输入选择：&quot;);
            int choice = scanner.nextInt();
            int key;
            String value;
            switch (choice) &#123;
                case 1:
                    System.out.print(getCurrentTime() + &quot; [INPUT] 输入键值：&quot;);
                    key = scanner.nextInt();
                    System.out.print(getCurrentTime() + &quot; [INPUT] 输入数据：&quot;);
                    value = scanner.next();
                    KTree.add(key, value);
                    break;
                case 2:
                    System.out.print(getCurrentTime() + &quot; [INPUT] 输入键值：&quot;);
                    key = scanner.nextInt();
                    System.out.println(getCurrentTime() + &quot; [INFO] 查询结果 value = &quot; + KTree.get(key));
                    break;
                case 3:
                    System.out.print(getCurrentTime() + &quot; [INPUT] 输入键值：&quot;);
                    key = scanner.nextInt();
                    KTree.del(key);
                    break;
                case 4:
                    System.out.println(getCurrentTime() + &quot; [INFO] 查询结果 size = &quot; + KTree.size());
                    break;
                case 5:
                    KTree.printRBTreeLevel();
                    break;
                case 6:
                    KTree.printGraphviz();
                    break;
                case 7:
                    System.out.println(getCurrentTime() + &quot; [INFO] 退出成功&quot;);
                    System.exit(0);
                default:
                    System.out.println(getCurrentTime() + &quot; [ERROR] 输入错误&quot;);
                    break;
            &#125;
        &#125;
    &#125;


    public static void main(String[] args) &#123;
        RedBlackTree redBlackTree = new RedBlackTree();
        redBlackTree.RBT();
    &#125;
&#125;</code></pre>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://parak.top">Khighness</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://parak.top/posts/f89cb603">https://parak.top/posts/f89cb603</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"> CC BY-NC-SA 4.0 </a>许可协议。转载请注明来自<a href="https://www.parak.top">炒菜K殿下</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RedBlackTree/">RedBlackTree</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Khighness/images/top/bg-9.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/wepay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/wepay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/41682/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-10.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">设计模式</div></div></a></div><div class="next-post pull-right"><a href="/posts/f8cdfd0a/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-8.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">叶惠美</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%93-%E5%AE%9A%E4%B9%89"><span class="toc-text">📓 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B0-%E6%80%A7%E8%B4%A8"><span class="toc-text">🔰 性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%97-%E5%B9%B3%E8%A1%A1"><span class="toc-text">🌗 平衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%80-%E5%A2%9E%E5%88%A0"><span class="toc-text">🌀 增删</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%91-%E6%BA%90%E7%A0%81"><span class="toc-text">📑 源码</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Khighness/cdn/common/footer.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Khighness</div><div class="footer_custom_text"><a href="https://www.foreverblog.cn/" target="_blank" > <img src="https://img.foreverblog.cn/logo_en_default.png" alt="" style="width:auto;height:16px;"> </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'hexo-2grv2lyu1131c342',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'hexo-2grv2lyu1131c342',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Py2eOHzSdrnxKPzKrOJaHJOq-9Nh9j0Va',
      appKey: '9eQhwuCgyshpYKn4rtEhqt4R',
      placeholder: '',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: 'https://cdn.jsdelivr.net/gh/imaegoo/emotion/owo.json',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick, mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/js/Valine.min.js').then(initValine)
}

if ('Twikoo' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'hexo-2grv2lyu1131c342',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>