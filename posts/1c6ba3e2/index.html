<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Netty | Khighness</title><meta name="keywords" content="Server"><meta name="author" content="Khighness"><meta name="copyright" content="Khighness"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. IO1.1 BIO1.1.1 介绍 Java BIO就是传统的Java IO编程，相关API都在java.io BIO (blocking I&#x2F;O)：同步并阻塞，服务器实现模式为一个连接一个线程，即有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 BIO方式适用于连接数目较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty">
<meta property="og:url" content="https://www.parak.top/posts/1c6ba3e2/index.html">
<meta property="og:site_name" content="Khighness">
<meta property="og:description" content="1. IO1.1 BIO1.1.1 介绍 Java BIO就是传统的Java IO编程，相关API都在java.io BIO (blocking I&#x2F;O)：同步并阻塞，服务器实现模式为一个连接一个线程，即有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 BIO方式适用于连接数目较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-3.jpg">
<meta property="article:published_time" content="2020-09-30T16:00:00.000Z">
<meta property="article:modified_time" content="2021-05-24T02:54:02.780Z">
<meta property="article:author" content="Khighness">
<meta property="article:tag" content="Server">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-3.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/K.jpg"><link rel="canonical" href="https://www.parak.top/posts/1c6ba3e2/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//s4.cnzz.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16576652";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" data-pjax="data-pjax" src="https://s4.cnzz.com/z_stat.php?id=1279324689&amp;web_id=1279324689"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Khighness","link":"链接: ","source":"来源: Khighness","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-24 10:54:02'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/iconfont/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Khighness" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/Khighness.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Khighness</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Netty</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-30T16:00:00.000Z" title="发表于 2020-10-01 00:00:00">2020-10-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-24T02:54:02.780Z" title="更新于 2021-05-24 10:54:02">2021-05-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Netty"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-IO"><a href="#1-IO" class="headerlink" title="1. IO"></a>1. IO</h2><h3 id="1-1-BIO"><a href="#1-1-BIO" class="headerlink" title="1.1 BIO"></a>1.1 BIO</h3><h4 id="1-1-1-介绍"><a href="#1-1-1-介绍" class="headerlink" title="1.1.1 介绍"></a>1.1.1 介绍</h4><ul>
<li>Java BIO就是传统的Java IO编程，相关API都在java.io</li>
<li>BIO (<strong>blocking I/O</strong>)：<strong>同步并阻塞</strong>，服务器实现模式为一个连接一个线程，即有连接请求时服务器就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销</li>
<li>BIO方式适用于连接数目较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择</li>
</ul>
<a id="more"></a>



<h4 id="1-1-2-实例"><a href="#1-1-2-实例" class="headerlink" title="1.1.2 实例"></a>1.1.2 实例</h4><blockquote>
<p>BIO服务器</p>
</blockquote>
<pre><code class="java">package com.kag.bio;

import org.apache.log4j.Logger;
import java.io.IOException;
import java.io.InputStream;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @Author: KHighness
 * @Date: 2020/9/13 11:07
 * @Description: BIO服务器
 */

public class BIOServer &#123;

    private Logger logger = Logger.getLogger(BIOServer.class);

    /**
     *  启动服务器
     * @throws IOException
     */
    public void start() throws IOException &#123;

        /**
         * 线程池机制
         * 思路
         * 1、创建一个线程池
         * 2、如果有多个线程池联机呃，就创建一个线程，与之通讯
         */

        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();

        // 创建ServerSocket
        ServerSocket serverSocket = new ServerSocket(6666);
        logger.info(&quot;NIO 服务器启动 &quot;);

        while (true) &#123;
            // 监听，等待客户端接受
            final Socket socket = serverSocket.accept();
            logger.info(&quot;新增一个客户端连接&quot;);
            // 创建一个线程，与之通讯
            newCachedThreadPool.execute(new Runnable() &#123;
                public void run() &#123;
                    handler(socket);
                &#125;
            &#125;);
        &#125;
    &#125;

    /**
     * handler，和客户端通讯
     * @param socket
     */
    public void handler(Socket socket) &#123;
        try &#123;
            byte[] bytes = new byte[1024];
            // 通过socket获取输入流
            InputStream inputStream = socket.getInputStream();
            // 循环读取客户端发送的数据
            while (true) &#123;
                // 输出线程信息
                logger.info(&quot;线程信息：&#123; PID = &quot; + Thread.currentThread().getId()
                        + &quot;, Name = &quot; + Thread.currentThread().getName() + &quot; &#125;&quot;);
                int read = inputStream.read(bytes);
                if (read != -1) &#123;
                    logger.info(&quot;[客户端：&quot; + new String(bytes, 0, read) + &quot;]&quot;);
                &#125; else &#123;
                    break;
                &#125;
            &#125;
        &#125; catch (Exception e) &#123;
            logger.info(e.getMessage());
        &#125; finally &#123;
            logger.info(&quot;关闭与客户端的连接&quot;);
            try &#123;
                socket.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        try &#123;
            new BIOServer().start();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="1-1-3-配置"><a href="#1-1-3-配置" class="headerlink" title="1.1.3 配置"></a>1.1.3 配置</h4><img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200913115739418.png" class="" title="image-20200913115739418">

<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200913115851769.png" class="" title="image-20200913115851769">

<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200913115947574.png" class="" title="image-20200913115947574">



<h4 id="1-1-4-运行"><a href="#1-1-4-运行" class="headerlink" title="1.1.4 运行"></a>1.1.4 运行</h4><img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200913120322526.png" class="" title="image-20200913120322526">



<pre><code class="shell">telnet 127.0.0.1 6666</code></pre>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200913120406689.png" class="" title="image-20200913120406689">



<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200913121954652.png" class="" title="image-20200913121954652">

<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200913122028056.png" class="" title="image-20200913122028056">



<h4 id="1-1-5-不足"><a href="#1-1-5-不足" class="headerlink" title="1.1.5 不足"></a>1.1.5 不足</h4><p>1）每个请求都需要创建独立的线程，与对应的客户端进行数据Read，业务处理，数据Write</p>
<p>2）当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大</p>
<p>3）连接建立后，如果当当前线程暂存没有数据可读，则线程就阻塞在Read上，造成线程资源浪费</p>
<h3 id="1-2-NIO"><a href="#1-2-NIO" class="headerlink" title="1.2 NIO"></a>1.2 NIO</h3><h4 id="1-2-1-介绍"><a href="#1-2-1-介绍" class="headerlink" title="1.2.1 介绍"></a>1.2.1 介绍</h4><ul>
<li>Java NIO 全称 <strong>java non-blocking IO</strong>，是指JDK提供的心API，是<strong>同步非阻塞</strong>的。</li>
<li>NIO 相关类都被放在 java.nio包及子包下，并且对原 java.io包中的很多类进行改写</li>
<li>NIO 三大核心部分：<u>Channel</u>(通道)、<u>Buffer</u>(缓冲区)、<u>Selector</u>(选择器)</li>
<li>NIO 是面向缓冲区或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区前后移动，这就增加处理过程中的灵活性，使用它可以提供非阻塞的高伸缩性网络</li>
</ul>
<h4 id="1-2-2-比较"><a href="#1-2-2-比较" class="headerlink" title="1.2.2 比较"></a>1.2.2 比较</h4><blockquote>
<p><code>BIO</code> VS <code>NIO</code></p>
</blockquote>
<ul>
<li><p>BIO以流的方式处理数据，而NIO以块的方式处理数据，块I/O的效率比流I/O高很多</p>
</li>
<li><p>BIO是阻塞的，NIO则是非阻塞的</p>
</li>
<li><p>BIO基于字节流和字符流进行操作，而NIO基于<code>Channel</code>(通道)和<code>Buffer</code>(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到同道中人。<code>Selectors</code>(选择器)用于监听多个通道的事件（比如：连接请求、数据到达等），因此使用单个线程就可以监听多个客户端通道</p>
</li>
</ul>
<h4 id="1-2-3-组件"><a href="#1-2-3-组件" class="headerlink" title="1.2.3 组件"></a>1.2.3 组件</h4><p>三大组件：<code>Selector</code>、<code>Channe</code>和<code>Buffer</code></p>
<blockquote>
<p>关系图</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200913164017187.png" class="" title="image-20200913164017187">

<blockquote>
<p>说明</p>
</blockquote>
<ul>
<li>每个<code>channel</code>都会对应一个<code>Buffer</code></li>
<li><code>Selector</code>对应一个线程，一个线程对应多个<code>channel</code></li>
<li>该图反应有三个<code>channel</code>注册到了该<code>Selector</code>程序</li>
<li>程序切换到哪个<code>channel</code>是有事件决定的，<code>Event</code>就是一个重要的概念</li>
<li><code>Selector</code>会根据不同的事件，在各个通道上切换</li>
<li><code>Buffer</code>就是一个内存块，底层是有一个数组</li>
<li>数据的读取写入都通过<code>Buffer</code>，这个和BIO不同。BIO要么是输入流，要么是输出流，不能双向，但是NIO的<code>buffer</code>是可以读也可以写，需要<code>flip</code>方法切换</li>
<li><code>channel</code>是双向的，可以返回底层操作系统的情况，比如<code>Linux</code>，底层的操作系统通道就是双向的</li>
</ul>
<h5 id="1-2-3-1-Buffer"><a href="#1-2-3-1-Buffer" class="headerlink" title="1.2.3.1 Buffer"></a>1.2.3.1 Buffer</h5><blockquote>
<p>说明</p>
</blockquote>
<p>缓冲区：缓冲区本质上是一个可以读写数据的内存块</p>
<blockquote>
<p>常用Buffer子类：</p>
</blockquote>
<ul>
<li>ByteBuffer</li>
<li>ShortBuffer</li>
<li>CharBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>DoubleBuffer</li>
<li>FloatBuffer</li>
</ul>
<blockquote>
<p>Buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Capacity</td>
<td align="center">容量，即可以容纳的最大数据量；在缓冲区创建时被设定且不能改变</td>
</tr>
<tr>
<td align="center">Limit</td>
<td align="center">表示缓冲区的当前重点，不能对缓冲区超过极限的位置进行读写操作，且极限是可以修改的</td>
</tr>
<tr>
<td align="center">Position</td>
<td align="center">位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变的值，为下次读写作准备</td>
</tr>
<tr>
<td align="center">Mark</td>
<td align="center">标记</td>
</tr>
</tbody></table>
<p>mark &lt;= position &lt;= limit &lt;= capacity</p>
<h5 id="1-2-3-2-Channel"><a href="#1-2-3-2-Channel" class="headerlink" title="1.2.3.2 Channel"></a>1.2.3.2 Channel</h5><blockquote>
<p>说明</p>
</blockquote>
<p>通道：NIO的通道类似于流，但有些区别</p>
<ul>
<li>通道可以同时进行读写，而流只能读或者只能写</li>
<li>通道可以实现异步读写数据</li>
<li>通道可以从缓冲读数据，也可以写数据到缓冲</li>
</ul>
<blockquote>
<p> 常用的Channel类：</p>
</blockquote>
<ul>
<li>FileChannel                      ━━━━━▶          文件的数据读写</li>
<li>DatagramChannel            ━━━━━▶          UDP的数据读写</li>
<li>ServerSocketChannel      ━━━━━▶          TCP的数据读写</li>
<li>SocketChannel                 ━━━━━▶          TCP的数据读写</li>
</ul>
<blockquote>
<p>FileChannel的主要IO操作</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public int read(ByteBuffer dst)</td>
<td align="center">从通道读取数据并放到缓冲区中</td>
</tr>
<tr>
<td align="center">public int write(ByteBuffer src)</td>
<td align="center">把缓冲区的数据写到通道中</td>
</tr>
<tr>
<td align="center">public long transferFrom(ReadableByteChannel src, long position, long count)</td>
<td align="center">从目标通道中复制数据到当前通道</td>
</tr>
<tr>
<td align="center">public long transferTo(long position, long count, WritableByteChannel target)</td>
<td align="center">把数据从当前通道复制给目标通道</td>
</tr>
</tbody></table>
<h5 id="1-2-3-3-Selector"><a href="#1-2-3-3-Selector" class="headerlink" title="1.2.3.3 Selector"></a>1.2.3.3 Selector</h5><blockquote>
<p>说明</p>
</blockquote>
<p>选择器：</p>
<ul>
<li>Java的NIO，用非阻塞的IO方式，可以用一个线程，处理多个的客户端连接，就会使用到<code>Selector</code></li>
<li><code>Selector</code>能够检测多个注册的通道上是否有事件发生（多个<code>Channel</code>以事件的方式可以注册到同一个<code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求</li>
<li>只有在连接真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程</li>
<li>避免了多线程之间的上下文切换导致的开销</li>
</ul>
<blockquote>
<p>类及相关方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Class | Method</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public abstract class Selector implements Closeable</td>
<td align="center">抽象类</td>
</tr>
<tr>
<td align="center">public static Selector open()</td>
<td align="center">得到一个选择器对象</td>
</tr>
<tr>
<td align="center">public int select(long timeout)</td>
<td align="center">监控所有注册的通道，参数用来设置超时时间</td>
</tr>
<tr>
<td align="center">public Set<SelectionKey> selectedKeys()</td>
<td align="center">从内部集合中得到所有的SelectionKe’y</td>
</tr>
</tbody></table>
<blockquote>
<p>说明</p>
</blockquote>
<ul>
<li>当客户端连接时，会通过<code>ServerSocketChannel</code>得到<code>SocketChannel</code></li>
<li>将<code>SocketChannel</code>注册到<code>Selector</code>上，注册后返回一个<code>SelectionKey</code></li>
<li><code>Selector</code>进行监听<code>select</code>方法，返回有事件发生的通道的个数</li>
<li>进一步得到各个<code>SelectionKey</code></li>
<li>在通道<code>SelectionKey</code>反向获取<code>SocketChannel</code>，方法<code>channel()</code></li>
<li>可以得到所有的<code>channel</code>，完成业务处理</li>
</ul>
<h4 id="1-2-3-编程"><a href="#1-2-3-编程" class="headerlink" title="1.2.3 编程"></a>1.2.3 编程</h4><blockquote>
<p>将数据写入到本地文件</p>
</blockquote>
<pre><code class="java">    public static void write(String s) throws IOException &#123;
        // 创建输出流 ——&gt; channel
        FileOutputStream fileOutputStream = new FileOutputStream(&quot;D:\\Java\\Test\\K1.txt&quot;);

        // 通过 fileOutputStream 获取 对应的 FileChannel
        // 这个 fileChannel 真实类型是  FileChannelImpl
        FileChannel fileChannel = fileOutputStream.getChannel();

        // 创建一个缓冲区 ByteBuffer
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

        // 将 s 放入 byteBuffer
        byteBuffer.put(s.getBytes());

        // 对 byteBuffer 进行flip
        byteBuffer.flip();

        // 将 byteBuffer 数据写入到 fileChannel
        fileChannel.write(byteBuffer);
        fileOutputStream.close();
    &#125;</code></pre>
<blockquote>
<p>从本地文件读取数据</p>
</blockquote>
<pre><code class="java">    public static void read(String path) throws IOException &#123;
        // 创建文件的输入流
        File file = new File(path);
        FileInputStream fileInputStream = new FileInputStream(file);

        // 通过 fileInputStream 获取对应的 FileChannel ——&gt;  实际类型 FileChannelImpl
        FileChannel fileChannel = fileInputStream.getChannel();

        // 创建一个缓冲区ByteBuffer
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

        // 将 通道的数据 读入到 Buffer
        fileChannel.read(byteBuffer);

        // 将byteBuffer的字节数据转成字符串
        System.out.println(new String(byteBuffer.array()));
        fileInputStream.close();
    &#125;</code></pre>
<blockquote>
<p>拷贝文件</p>
</blockquote>
<pre><code class="java">    public static void copy(String source, String destination) throws IOException &#123;
        FileInputStream fileInputStream = new FileInputStream(source);
        FileChannel fileChannel1 = fileInputStream.getChannel();

        FileOutputStream fileOutputStream = new FileOutputStream(destination);
        FileChannel fileChannel2 = fileOutputStream.getChannel();

        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

        while (true) &#123;
            // 复位，重置标志位
            byteBuffer.clear();

            int read = fileChannel1.read(byteBuffer);
            if (read == -1) &#123;// 表示读完
                break;
            &#125;
            // 将buffer中的数据写入到fileChannel02 -- K2.txt
            byteBuffer.flip();
            fileChannel2.write(byteBuffer);
        &#125;
        fileOutputStream.close();
        fileInputStream.close();
    &#125;</code></pre>
<blockquote>
<p>使用transferFrom完成拷贝</p>
</blockquote>
<pre><code class="java">    public static void copyImage(String fromPath, String toPath) throws IOException &#123;
        // 创建相关流
        FileInputStream fileInputStream = new FileInputStream(fromPath);
        FileOutputStream fileOutputStream = new FileOutputStream(toPath);

        // 获取Channel
        FileChannel sourceChannel = fileInputStream.getChannel();
        FileChannel destinChannel = fileOutputStream.getChannel();

        // 使用transferFrom完成拷贝
        destinChannel.transferFrom(sourceChannel, 0, sourceChannel.size());

        // 关闭相关流
        sourceChannel.close();
        destinChannel.close();
        fileInputStream.close();
        fileOutputStream.close();
    &#125;</code></pre>
<blockquote>
<p>buffer数组完成读写操作</p>
</blockquote>
<pre><code class="java">// Scattering: 将数据写入到buffer时，可以采用buffer数组，依次写入[分散]
// Gathering: 从buffer读取数据时，可以采用buffer数组，依次读取[聚集]
public class ScatteringAndGatheringTest &#123;

    public static void demo() throws Exception&#123;
        // 使用ServerSocketChannel 和 SocketChannel 网络
        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
        InetSocketAddress inetSocketAddress = new InetSocketAddress(7000);

        // 绑定端口到Socket，并启动
        serverSocketChannel.socket().bind(inetSocketAddress);

        // 创建buffer数组
        ByteBuffer[] byteBuffers = new ByteBuffer[2];
        byteBuffers[0] = ByteBuffer.allocate(5);
        byteBuffers[1] = ByteBuffer.allocate(3);

        // 等客户端连接
        SocketChannel socketChannel = serverSocketChannel.accept();
        int messageLength = 8;

        // 循环的读取
        while (true) &#123;
            int byteRead = 0;

            while (byteRead &lt; messageLength) &#123;
                long l = socketChannel.read(byteBuffers);
                byteRead  += l;
                System.out.println(&quot;byteRead = &quot; + byteRead);
                Arrays.asList(byteBuffers)
                        .stream()
                        .map(buffer -&gt; &quot;position = &quot;
                                + buffer.position()
                                + &quot;, limit = &quot;
                                + buffer.limit())
                        .forEach(System.out::println);

                // 将所有的buffer反转
                Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());

                // 将数据读出显示到客户端
                long byteWrite = 0;
                while (byteWrite &lt; messageLength) &#123;
                    socketChannel.write(byteBuffers);
                    byteWrite += 1;
                &#125;

                // 将所欲的buffer进行clear
                Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;
                    buffer.clear();
                &#125;);

                System.out.println(
                                &quot;byteRead = &quot; + byteRead
                                + &quot;, byteWrite = &quot; + byteWrite
                                + &quot;, messageLength = &quot; + messageLength);
            &#125;
        &#125;
    &#125;</code></pre>
<h4 id="1-2-4-实例"><a href="#1-2-4-实例" class="headerlink" title="1.2.4 实例"></a>1.2.4 实例</h4><p><strong>群聊系统Demo</strong></p>
<p>编码步骤：</p>
<ol>
<li>当客户端连接时，会通过<code>ServerSocketChannel</code> 得到 SocketChannel</li>
<li>Selector 进行监听 select 方法, 返回有事件发生的通道的个数.</li>
<li>将socketChannel注册到Selector上, register(Selector sel, int ops), 一个selector上可以注册多个SocketChannel</li>
<li>注册后返回一个 SelectionKey, 会和该Selector 关联(集合)</li>
<li>进一步得到各个 SelectionKey (有事件发生)</li>
<li>在通过 SelectionKey 反向获取 SocketChannel , 方法 channel()</li>
<li>判断该Channel的事件类型，对不同事件进行不同的业务处理</li>
</ol>
<blockquote>
<p>NIOServer</p>
</blockquote>
<pre><code class="java">package com.kag.nio.groupchat;

import org.apache.log4j.Logger;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.*;
import java.util.Iterator;

/**
 * @Author: KHighness
 * @Date: 2020/9/19 22:59
 * @Description:
 */

public class GroupChatServer &#123;

    private Logger log = Logger.getLogger(GroupChatServer.class);

    private Selector selector;

    private ServerSocketChannel listenChannel;

    private final int PORT = 3333;

    public GroupChatServer() &#123;
        try &#123;
            // 1、获取选择器
            selector = Selector.open();
            // 2、获取通道
            listenChannel = ServerSocketChannel.open();
            // 3、绑定端口
            listenChannel.socket().bind(new InetSocketAddress(PORT));
            // 4、设置非阻塞
            listenChannel.configureBlocking(false);
            // 5、将通道注册到选择器，注册操作：“接收”
            listenChannel.register(selector, SelectionKey.OP_ACCEPT);
        &#125; catch (IOException e) &#123;
            log.info(e.getMessage());
        &#125;
    &#125;

    // 监听
    public void listen() &#123;
        try &#123;
            // 6、采用轮询的方式，查询获取“准备就绪”的注册过的操作
            while (true) &#123;
                int count = selector.select();
                if (count &gt; 0) &#123;
                    // 7、获取当前选择器中所有注册的选择键
                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                    while (iterator.hasNext()) &#123;
                        // 8、获取“准备就绪”的时间
                        SelectionKey selectionKey = iterator.next();

                        // 9、判断selectionKey是具体的什么事件
                        // 监听到accept事件
                        if (selectionKey.isAcceptable()) &#123;
                            // 10、若接受的事件是“接收就绪”操作，就获取客户端连接
                            SocketChannel socketChannel = listenChannel.accept();
                            // 11、切换为非阻塞模式
                            socketChannel.configureBlocking(false);
                            // 将该通道注册到选择器上
                            socketChannel.register(selector, SelectionKey.OP_READ);
                            log.info(&quot;[&quot; + socketChannel.getRemoteAddress().toString().substring(1) + &quot;]上线&quot;);
                        &#125;

                        // 监听到read事件
                        if (selectionKey.isReadable()) &#123;
                            // 处理读 (专门方法)
                            readMessage(selectionKey);
                        &#125;

                        // end：移除选择键，防止重复操作
                        iterator.remove();

                    &#125;
                &#125; else &#123;
                    log.info(&quot;等待····&quot;);
                &#125;
            &#125;
        &#125; catch (IOException e) &#123;
            log.error(e.getMessage());
        &#125;
    &#125;

    // 读取客户端消息
    public void readMessage(SelectionKey selectionKey) &#123;
        // 定义一个 SocketChannel
        SocketChannel socketChannel = null;
        try &#123;
            // 13、获取该选择器上的“读就绪”状态的通道
            socketChannel = (SocketChannel) selectionKey.channel();
            // 14、读取数据
            ByteBuffer buffer = ByteBuffer.allocate(1024);

            int count = socketChannel.read(buffer);
            // 根据count的h值做处理
            if (count &gt; 0) &#123;
                // 把缓存区的数据转成字符串
                String msg = new String(buffer.array());
                // 输出该消息
                log.info(&quot;客户端-&quot; + msg);
                // 向其他客户端转发消息(排除自己)，专门写一个方法来处理
                sendMessageToOtherClients(msg, socketChannel);
            &#125;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            try &#123;
                log.info(&quot;[&quot; + socketChannel.getRemoteAddress().toString().substring(1) + &quot;]离线&quot;);
                // 取消注册
                selectionKey.cancel();
                // 关闭通道
                socketChannel.close();
            &#125; catch (IOException ioException) &#123;
                log.error(e.getMessage());
            &#125;
        &#125;
    &#125;

    // 转发消息给其他客户
    private void sendMessageToOtherClients(String msg, SocketChannel self) throws IOException &#123;
        log.info(&quot;服务器转发消息&quot;);
        // 遍历所有注册到 selector 上的SocketChannel，并排除self
        for (SelectionKey key : selector.keys()) &#123;
            // 通过 key 取出 对应的 SocketChannel
            Channel targetChannel = key.channel();
            // 排除自己
            if (targetChannel instanceof SocketChannel &amp;&amp; targetChannel != self) &#123;
                // 转型
                SocketChannel dest = (SocketChannel) targetChannel;
                // 将msg存储到buffer
                ByteBuffer byteBuffer = ByteBuffer.wrap(msg.getBytes());
                // 将buffer的数据写入通道
                dest.write(byteBuffer);
            &#125;
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        // 创建服务器对象
        GroupChatServer groupChatServer = new GroupChatServer();
        groupChatServer.listen();
    &#125;
&#125;</code></pre>
<blockquote>
<p>NIOClient</p>
</blockquote>
<pre><code class="java">package com.kag.nio.groupchat;

import org.apache.log4j.Logger;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.nio.ByteBuffer;
import java.nio.channels.SelectionKey;
import java.nio.channels.Selector;
import java.nio.channels.SocketChannel;
import java.util.Iterator;
import java.util.Scanner;

/**
 * @Author: KHighness
 * @Date: 2020/9/20 0:53
 * @Description:
 */

public class GroupChatClient &#123;

    private Logger log = Logger.getLogger(GroupChatClient.class);

    private final String HOST = &quot;127.0.0.1&quot;;

    private final int    PORT = 3333;

    private Selector selector;

    private SocketChannel socketChannel;

    private String username;

    // 构造器
    public GroupChatClient() throws IOException &#123;
        selector = Selector.open();
        // 连接服务器
        socketChannel = socketChannel.open(new InetSocketAddress(HOST, PORT));
        // 设置非阻塞
        socketChannel.configureBlocking(false);
        // 将socketChannel注册到selector
        socketChannel.register(selector, SelectionKey.OP_READ);
        // 得到username
        username = socketChannel.getLocalAddress().toString().substring(1);
        log.info(&quot;[&quot; + username + &quot;]已就绪···&quot;);
    &#125;

    // 向服务器发送消息
    public void sendMessage(String msg) &#123;
        msg = username + &quot;: &quot; + msg;
        try &#123;
            socketChannel.write(ByteBuffer.wrap(msg.getBytes()));
        &#125; catch (IOException e) &#123;
            log.error(e.getMessage());
        &#125;
    &#125;

    // 从服务器回复的消息
    public void readMessage() &#123;
        try &#123;
            int readChannels = selector.select();
            if (readChannels &gt; 0) &#123;
                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();
                while (iterator.hasNext()) &#123;
                    SelectionKey key = iterator.next();
                    if (key.isReadable()) &#123;
                        // 得到相关的通道
                        SocketChannel socketChannel = (SocketChannel) key.channel();
                        // 得到一个buffer
                        ByteBuffer buffer = ByteBuffer.allocate(1024);
                        // 读取
                        socketChannel.read(buffer);
                        // 把读到的缓冲区的数据转成字符串
                        String msg = new String(buffer.array());
                        log.info(msg);
                    &#125;
                &#125;
                // 删除当前 SelectionKey
                iterator.remove();
            &#125; else &#123;
                //log.error(&quot;无可用的通道···&quot;);
            &#125;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
        &#125;
    &#125;

    public static void main(String[] args) throws Exception&#123;
        // 启动客户端
        GroupChatClient chatClient = new GroupChatClient();

        // 启动一个线程，每隔3秒，读取从服务器
        new Thread() &#123;
            public void run() &#123;
                while (true) &#123;
                    chatClient.readMessage();
                    try &#123;
                        Thread.currentThread().sleep(3000);
                    &#125; catch (InterruptedException e) &#123;
                        System.err.println(e.getMessage());
                    &#125;
                &#125;
            &#125;
        &#125;.start();

        // 发送数据给服务器
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNextLine()) &#123;
            String s = scanner.nextLine();
            chatClient.sendMessage(s);
        &#125;
    &#125;
&#125;</code></pre>
<h4 id="1-2-5-零拷贝"><a href="#1-2-5-零拷贝" class="headerlink" title="1.2.5 零拷贝"></a>1.2.5 零拷贝</h4><blockquote>
<p>说明</p>
</blockquote>
<ul>
<li><p>零拷贝，是从OS(操作系统)的角度来说的。因为内核缓冲区之间，没有数据是重复的</p>
</li>
<li><p>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，更少的CPU缓存伪共享以及无CPU校验和计算</p>
</li>
</ul>
<blockquote>
<p>mmap</p>
</blockquote>
<ul>
<li>mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数</li>
</ul>
<blockquote>
<p>mmap和sendFile的区别</p>
</blockquote>
<ul>
<li>mmp适合小数据量读写，sendFile适合大文件传输</li>
<li>mmap需要4次上下文切换，3次数据拷贝；sendFile需要3次上下文切换，最少2次数据拷贝</li>
<li>sendFile可以利用DMA(direct memory access: 直接内存拷贝)方式，减少CPU拷贝，mmap则不能(必须从内核拷贝到Socket缓冲区)</li>
</ul>
<h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h2><p>官网: <a target="_blank" rel="noopener" href="https://netty.io/">Netty.io</a></p>
<h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>Netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p>
<h3 id="1-2-设计"><a href="#1-2-设计" class="headerlink" title="1.2 设计"></a>1.2 设计</h3><ul>
<li>适用于各种传输类型的统一API-阻塞和非阻塞套接字</li>
<li>基于灵活且可扩展的事件模型，可将关注点明确分离</li>
<li>高度可定制的线程模型-单线程，一个或多个线程池，例如SEDA</li>
<li>真正的无连接数据报套接字支持（从3.1开始）</li>
</ul>
<h3 id="1-3-性能"><a href="#1-3-性能" class="headerlink" title="1.3 性能"></a>1.3 性能</h3><ul>
<li>更高的吞吐量，更低的延迟</li>
<li>减少资源消耗</li>
<li>减少不必要的内存复制</li>
</ul>
<h3 id="1-4-架构"><a href="#1-4-架构" class="headerlink" title="1.4 架构"></a>1.4 架构</h3><img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200921092848809.png" class="" title="image-20200921092848809">



<h2 id="3-Reactor"><a href="#3-Reactor" class="headerlink" title="3. Reactor"></a>3. Reactor</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><blockquote>
<p>反应器模式  |  分发者模式  |  通知者模式</p>
</blockquote>
<ul>
<li>基于I/O复用模型: 多个连接共用一个阻塞对象，应用程序只需要再一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理</li>
<li>基于线程池复用线程资源: 不必再为每个连接创建线程，键连接完成后的业务处理热舞分配给线程进行处理，一个线程可以处理多个连接的业务</li>
</ul>
<h3 id="2-2-组成"><a href="#2-2-组成" class="headerlink" title="2.2 组成"></a>2.2 组成</h3><ul>
<li>Reactor: Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。</li>
<li>Handlers: 处理程序执行I/O事件要完成的实际事件。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作。</li>
</ul>
<h3 id="2-3-分类"><a href="#2-3-分类" class="headerlink" title="2.3 分类"></a>2.3 分类</h3><ul>
<li>单Reactor单线程        ━━━━━▶    前台接待员和服务员是同一个人，全程为顾客服务</li>
<li>单Reactor多线程        ━━━━━▶    1个前台接待员，多个服务员，接待员只负责接待</li>
<li>主从Reactor多线程    ━━━━━▶    多个前台接待员，多个服务生</li>
</ul>
<h4 id="2-2-1-单Reactor单线程"><a href="#2-2-1-单Reactor单线程" class="headerlink" title="2.2.1 单Reactor单线程"></a>2.2.1 单Reactor单线程</h4><blockquote>
<p>图示</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200921181936951.png" class="" title="image-20200921181936951">

<blockquote>
<p>分析</p>
</blockquote>
<ol>
<li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li>
<li>缺点：性能问题，只有一个线程，无法发挥多核CPU的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li>
<li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li>
<li>使用场景：客户端的数量有限，业务处理非常快速</li>
</ol>
<h4 id="2-2-2-单Reactor多线程"><a href="#2-2-2-单Reactor多线程" class="headerlink" title="2.2.2 单Reactor多线程"></a>2.2.2 单Reactor多线程</h4><blockquote>
<p>图示</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200921182914960.png" class="" title="image-20200921182914960">

<blockquote>
<p>方案说明</p>
</blockquote>
<ol>
<li><code>Reactor</code>对象通过<code>select</code>监控客户端请求事件，收到事件后，通过<code>dispatch</code>进行分发</li>
<li>如果建立连接请求，则由<code>Acceptor</code>通过<code>accept</code>处理连接请求，然后从黄健一个Handler对象处理完成连接后的各种事件</li>
<li>如果不是连接请求，则由<code>Reactor</code>分发调用连接对应的<code>handler</code>读取数据后，会分发给后面的<code>Worker</code>线程池的某个线程处理业务</li>
<li><code>Handler</code>只负责响应事件，不做具体的业务处理，通过<code>read</code>读取数据后，会分发给后面的<code>worker</code>线程池的某个线程处理业务</li>
<li><code>Worker</code>线程池会分配独立线程完成真正的业务，并将结果返回给<code>Handler</code></li>
<li><code>Handler</code>收到响应后，通过<code>send</code>将结果返回给<code>Client</code></li>
</ol>
<blockquote>
<p>分析</p>
</blockquote>
<ol>
<li>优点：可以充分的利用多核<code>CPU</code>的处理能力</li>
<li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code>处理所有的事件的监听和响应，在单线程运行，在高并发场景容易成为性能瓶颈</li>
</ol>
<h4 id="2-2-3-主从Reactor多线程"><a href="#2-2-3-主从Reactor多线程" class="headerlink" title="2.2.3 主从Reactor多线程"></a>2.2.3 主从Reactor多线程</h4><blockquote>
<p>图示</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200921191731035.png" class="" title="image-20200921191731035">

<blockquote>
<p>方案说明</p>
</blockquote>
<ol>
<li><code>Reactor</code>主线程<code>MainReactor</code>对象通过<code>select</code>监听连接事件，收到事件后，通过<code>Acceptor</code>处理连接事件</li>
<li>当<code>Acceptor</code>处理连接事件后，<code>MainReactor</code>将连接分配给<code>SubReactor</code></li>
<li><code>SubReactor</code>将连接加入到连接队列进行监听，并创建<code>Handler</code>进行各种事件处理</li>
<li>当有新事件发生时，<code>SubReactor</code>就会调用对应的Handler处理</li>
<li><code>Worker</code>线程池分配独立的<code>Worker</code>线程进行业务处理，并返回结果</li>
<li><code>Handler</code>收到响应的结果后，再通过<code>send</code>将结果返回给<code>Client</code></li>
<li><code>Reactor</code>主线程可以对于多个<code>Reactor</code>子线程，即<code>MainReactor</code>，可以关联多个<code>SubReactor</code></li>
</ol>
<blockquote>
<p>分析</p>
</blockquote>
<ol>
<li><p>优点：父线程与子线程的职责明确，父线程只需要接收新连接，子线程完成后续的业务处理</p>
</li>
<li><p>优点：父线程与子线程的数据交互简单，<code>Reactor</code>主线程只需要把新连接传给子线程，子线程无需返回数据</p>
</li>
<li><p>缺点：编程复杂度较高</p>
</li>
</ol>
<h3 id="2-4-优点"><a href="#2-4-优点" class="headerlink" title="2.4 优点"></a>2.4 优点</h3><ul>
<li>响应快，不必为单个同步时间所阻塞，虽然<code>Reactor</code>本身依然是同步的</li>
<li>可以最大程度的比曼复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li>
<li>扩展性好，可以方便的通过增加<code>Reactor</code>实例个数来充分利用CPU资源</li>
<li>复用性好，<code>Reactor</code>模型本身与具体事件处理逻辑无关，具有很高的复用性</li>
</ul>
<h2 id="4-架构"><a href="#4-架构" class="headerlink" title="4. 架构"></a>4. 架构</h2><h3 id="3-1-图示"><a href="#3-1-图示" class="headerlink" title="3.1 图示"></a>3.1 图示</h3><img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20200921204851799.png" class="" title="image-20200921204851799">

<h3 id="3-2-说明"><a href="#3-2-说明" class="headerlink" title="3.2 说明"></a>3.2 说明</h3><ol>
<li><code>Netty</code>抽象出两组线程池<code>BossGroup</code>专门负责接收客户端的连接，<code>WorkerGroup</code>专门负责网络的读写</li>
<li><code>BossGroup</code>和<code>WorkerGroup</code>类型的本质都是<code>NioEventLoopGroup</code></li>
<li><code>NioEventLoopGroup</code>相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是<code>NioEventLoop</code></li>
<li><code>NioEventLoop</code>表示一个不断循环的执行处理任务的线程，每个<code>NioEventLoop</code>都有一个<code>selector</code>，用于监听绑定在其上的socket的网络通讯</li>
<li><code>NioEventLoopGroup</code>可以有多个线程，即可以含有多个<code>NioEventLoop</code></li>
<li>每个<code>Boss NioEventLoop</code>循环执行的步骤有三步:<ol>
<li>轮询<code>accept</code>事件</li>
<li>处理<code>accept</code>事件，与<code>client</code>建立连接，生成<code>NioSocketChannel</code>，并将其注册到某个<code>Worker NioEventLoop</code>上的<code>selector</code></li>
<li>处理任务队列的任务，即<code>runAllTasks</code></li>
</ol>
</li>
<li>每个<code>Worker NIOEventLoop</code>循环执行的步骤<ol>
<li>轮询<code>read</code>、<code>write</code>事件</li>
<li>处理i/o事件，即<code>read</code>、<code>write</code>事件，在对应<code>NioSocketChannel</code>处理</li>
<li>处理任务队列的任务，即<code>runAllTasks</code></li>
</ol>
</li>
</ol>
<h3 id="3-3-代码示例"><a href="#3-3-代码示例" class="headerlink" title="3.3 代码示例"></a>3.3 代码示例</h3><blockquote>
<p>NettyServer.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.simple;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;

/**
 * @author: KHighness
 * @date: 2020/9/21 21:53
 * @apiNote:
 */

public class NettyServer &#123;

    public static void main(String[] args) throws Exception&#123;

        /*
         * 创建BossGroup 和 WorkerGroup
         * 说明：
         * 1、创建两个线程组：bossGroup 和 workerGroup
         * 2、bossGroup处理连接请求
         * 3、workerGroup处理和客户端的业务
         * 4、两个都是无限循环
         */
        EventLoopGroup bossGroup = new NioEventLoopGroup();
        NioEventLoopGroup workerGroup = new NioEventLoopGroup();

        try &#123;
            // 创建服务器端的启动对象，配置参数
            ServerBootstrap bootstrap = new ServerBootstrap();

            // 使用链式编程来进行设置
            bootstrap.group(workerGroup, workerGroup)                         // 设置两个线程组
                    .channel(NioServerSocketChannel.class)                    // 使用NioSocketChannel作为服务器的通道实现
                    .option(ChannelOption.SO_BACKLOG, 128)              // 设置线程队列得到连接个数
                    .childOption(ChannelOption.SO_KEEPALIVE, true)      // 设置保持活动连接状态
                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;   // 创建一个通道测试对象
                        // 给Pipeline设置处理器
                        @Override
                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
                            socketChannel.pipeline().addLast(new NettyServerHandler());
                        &#125;
                    &#125;);  // 给workerGroup的EventLoop对应的管道设置处理器

            System.out.println(&quot;服务器已就绪···&quot;);

            // 绑定一个端口并且同步
            // 绑定端口并启动服务器
            ChannelFuture channelFuture = bootstrap.bind(3333).sync();

            // 对关闭通道进行监听
            channelFuture.channel().closeFuture().sync();
        &#125; finally &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>NettyHandler.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.simple;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;

/**
 * @author: KHighness
 * @date: 2020/9/21 22:20
 * @apiNote:
 */

/**
 * 说明：
 * 自定义一个Handler需要继承Netty规定好的某个HandlerAdapter
 */
public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;

    /**
     * 读取数据事件
     * @param ctx 上下文对象，含有管道pipline[处理数据]，通道channel[传输数据]，地址
     * @param msg 客户端发送的数据
     * @throws Exception
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        System.out.println(&quot;server ctx = &quot; + ctx);
        // 将msg转成ByteBuffer
        ByteBuf byteBuf = (ByteBuf) msg;
        System.out.println(&quot;客户端发送消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));
        System.out.println(&quot;客户端地址：&quot; + ctx.channel().remoteAddress());
    &#125;

    /**
     * 数据读取完毕
     * @param ctx
     * @throws Exception
     */
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;
        // 将数据写入到缓存，并刷新
        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Hello, 客户端~&quot;, CharsetUtil.UTF_8));
    &#125;

    /**
     * 处理异常
     * @param ctx
     * @param cause
     * @throws Exception
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        System.out.println(cause.getMessage());
        ctx.close();
    &#125;
&#125;</code></pre>
<blockquote>
<p>NettyClient.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.simple;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;

/**
 * @author: KHighness
 * @date: 2020/9/21 22:20
 * @apiNote:
 */

/**
 * 说明：
 * 自定义一个Handler需要继承Netty规定好的某个HandlerAdapter
 */
public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;

    /**
     * 读取数据事件
     * @param ctx 上下文对象，含有管道pipline[处理数据]，通道channel[传输数据]，地址
     * @param msg 客户端发送的数据
     * @throws Exception
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        System.out.println(&quot;server ctx = &quot; + ctx);
        // 将msg转成ByteBuffer
        ByteBuf byteBuf = (ByteBuf) msg;
        System.out.println(&quot;客户端发送消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));
        System.out.println(&quot;客户端地址：&quot; + ctx.channel().remoteAddress());
    &#125;

    /**
     * 数据读取完毕
     * @param ctx
     * @throws Exception
     */
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;
        // 将数据写入到缓存，并刷新
        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Hello, 客户端~&quot;, CharsetUtil.UTF_8));
    &#125;

    /**
     * 处理异常
     * @param ctx
     * @param cause
     * @throws Exception
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        System.out.println(cause.getMessage());
        ctx.close();
    &#125;
&#125;
</code></pre>
<blockquote>
<p>NettyClientHandler.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.simple;

import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.util.CharsetUtil;

/**
 * @author: KHighness
 * @date: 2020/9/22 19:09
 * @apiNote:
 */

public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123;

    /**
     * 通道就绪-&gt;触发
     * @param ctx
     * @throws Exception
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
        System.out.println(&quot;client &quot; +  ctx);
        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;Hello, server~喵&quot;, CharsetUtil.UTF_8));
    &#125;

    /**
     * 有读取事件时-&gt;触发
     * @param ctx
     * @param msg
     * @throws Exception
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        ByteBuf byteBuf = (ByteBuf) msg;
        System.out.println(&quot;服务器回复消息：&quot; + byteBuf.toString(CharsetUtil.UTF_8));
        System.out.println(&quot;服务器的地址：&quot; + ctx.channel().remoteAddress());
    &#125;

    /**
     * 处理异常
     * @param ctx
     * @param cause
     * @throws Exception
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        System.out.println(cause.getMessage());
        ctx.close();
    &#125;
&#125;</code></pre>
<h3 id="3-4-任务队列"><a href="#3-4-任务队列" class="headerlink" title="3.4 任务队列"></a>3.4 任务队列</h3><p>任务队列中的<code>Task</code>有三种典型使用场景</p>
<ul>
<li>用户程序自定义的普通任务</li>
<li>用户自定义定时任务</li>
<li>非当前<code>Reactor</code>线程调用<code>Channel</code>的各种方法</li>
</ul>
<h3 id="3-5-异步模型"><a href="#3-5-异步模型" class="headerlink" title="3.5 异步模型"></a>3.5 异步模型</h3><h4 id="3-5-1-基本介绍"><a href="#3-5-1-基本介绍" class="headerlink" title="3.5.1 基本介绍"></a>3.5.1 基本介绍</h4><ol>
<li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者</li>
<li><code>Netty</code>中的I/O操作是异步的，包括<code>Bind</code>、<code>Write</code>、<code>Connect</code>等操作会简单的返回一个<code>ChannelFuture</code></li>
<li>调用者并不能理科获得结果，而是通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果</li>
<li><code>Netty</code>的异步模型是建立在<code>future</code>和<code>callback</code>之上的。<code>callback</code>就是回调。重点是<code>future</code>，它的核心思想是：结社一个方法<code>fun</code>，计算过程可能非常耗时，等待<code>fun</code>返回显然不合适。那么可以在调用<code>fun</code>的时候立马返回一个<code>future</code>，后续可以通过<code>future</code>去监控方法<code>fun</code>的处理过程</li>
</ol>
<h4 id="3-5-2-Future说明"><a href="#3-5-2-Future说明" class="headerlink" title="3.5.2 Future说明"></a>3.5.2 Future说明</h4><ol>
<li><p>表示异步的执行结果，可以通过它提供的方法来检测执行是否完成</p>
</li>
<li><p><code>ChannelFuture</code>是一个接口: public interface ChannelFuture extends Future<Void></p>
<p>我们可以添加监听器，当监听的事件发生时，就会通知到监听器</p>
</li>
</ol>
<h4 id="3-5-3-Future-Listener机制"><a href="#3-5-3-Future-Listener机制" class="headerlink" title="3.5.3 Future-Listener机制"></a>3.5.3 Future-Listener机制</h4><ol>
<li><p>当<code>future</code>对象刚刚创建时，处于非完成状态，调用者可以通过返回的<code>ChannelFuture</code>来获取操作执行的状态，注册监听函数来执行完成后的操作</p>
</li>
<li><p>常见操作：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">isDone()</td>
<td align="center">判断当前操作是否完成</td>
</tr>
<tr>
<td align="center">isSuccess()</td>
<td align="center">判断已完成的当前操作是否成功</td>
</tr>
<tr>
<td align="center">getCause()</td>
<td align="center">获取已完成的当前操作失败的原因</td>
</tr>
<tr>
<td align="center">isCancelled()</td>
<td align="center">判断已完成的当前操作是否被取消</td>
</tr>
<tr>
<td align="center">addListener()</td>
<td align="center">注册监听器，当操作已完成(isDone返回完成)，将会通知指定的监听器；如果Future对象已完成，则通知指定的监听器</td>
</tr>
</tbody></table>
</li>
</ol>
<p>例如：</p>
<pre><code class="java">            // 绑定一个端口并且同步
            // 绑定端口并启动服务器
            ChannelFuture CF = bootstrap.bind(3333).sync();

            // 给CF注册监听器
            CF.addListener(new ChannelFutureListener() &#123;
                @Override
                public void operationComplete(ChannelFuture channelFuture) throws Exception &#123;
                    if (CF.isSuccess()) &#123;
                        System.out.println(&quot;服务器监听端口[3333]成功&quot;);
                    &#125; else &#123;
                        System.out.println(&quot;服务器监听端口[3333]失败&quot;);
                    &#125;
                &#125;
            &#125;);</code></pre>
<h3 id="3-6-Http服务"><a href="#3-6-Http服务" class="headerlink" title="3.6 Http服务"></a>3.6 Http服务</h3><blockquote>
<p>TestServer.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.http;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.nio.NioServerSocketChannel;

/**
 * @author: KHighness
 * @date: 2020/9/26 10:34
 * @apiNote:
 */

public class TestServer &#123;
    public static void main(String[] args) &#123;

        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        try &#123;
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .childHandler(new TestServerInitializer());

            ChannelFuture CF = serverBootstrap.bind(3333).sync();

            CF.channel().closeFuture().sync();

        &#125; catch (InterruptedException e) &#123;
            System.out.println(e.getMessage());
        &#125; finally&#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>TestServerInitializer.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.http;

import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.codec.http.HttpServerCodec;

/**
 * @author: KHighness
 * @date: 2020/9/26 10:39
 * @apiNote:
 */

public class TestServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;
    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        // 向管道加入处理器

        // 得到管道
        ChannelPipeline pipeline = socketChannel.pipeline();

        // 加入一个Netty提供的HttpServerCodeC codec =&gt; [coder - decoder]
        // 1、HttpServerCodeC: 处理http的编&amp;解码器
        pipeline.addLast(&quot;MyHttpServerCodec&quot;, new HttpServerCodec());
        // 2、增加一个自定义handler
        pipeline.addLast(&quot;MyTestServerHandler&quot;, new TestHttpServerHandler());
    &#125;
&#125;</code></pre>
<blockquote>
<p>TestHttpServerHandler.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.http;

import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.socket.SocketChannel;
import io.netty.handler.codec.http.HttpServerCodec;

/**
 * @author: KHighness
 * @date: 2020/9/26 10:39
 * @apiNote:
 */

public class TestServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;
    @Override
    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;
        // 向管道加入处理器

        // 得到管道
        ChannelPipeline pipeline = socketChannel.pipeline();

        // 加入一个Netty提供的HttpServerCodeC codec =&gt; [coder - decoder]
        // 1、HttpServerCodeC: 处理http的编&amp;解码器
        pipeline.addLast(&quot;MyHttpServerCodec&quot;, new HttpServerCodec());
        // 2、增加一个自定义handler
        pipeline.addLast(&quot;MyTestServerHandler&quot;, new TestHttpServerHandler());
    &#125;
&#125;</code></pre>
<h2 id="5-核心"><a href="#5-核心" class="headerlink" title="5. 核心"></a>5. 核心</h2><h3 id="4-1-BootStrap、ServerBootStrap"><a href="#4-1-BootStrap、ServerBootStrap" class="headerlink" title="4.1 BootStrap、ServerBootStrap"></a>4.1 BootStrap、ServerBootStrap</h3><blockquote>
<p>说明</p>
</blockquote>
<p><code>BootStrap</code>意思是引导程序，一个<code>Netty</code>应用通常由一个<code>BootStrap</code>开始，主要作用是配置整个<code>Netty</code>程序，串联各个组件，<code>Netty</code>中<code>BootStrap</code>类是客户端程序的启动引导类，<code>ServerBootStrap</code>是服务器端启动引导类</p>
<blockquote>
<p>常用方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">方法介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public ServerBootStrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</td>
<td align="center">该方法用于服务器端，用来设置两个EventLoop</td>
</tr>
<tr>
<td align="center">public B group(EventLoopGroup group)</td>
<td align="center">该方法用于客户端，用来设置一个EventLoop</td>
</tr>
<tr>
<td align="center">public B channel(Class&lt;? extends C&gt; channelClass)</td>
<td align="center">该方法用来设置一个服务器端的通道实现</td>
</tr>
<tr>
<td align="center">public <T> B option(ChannelOption<T> option, T value)</td>
<td align="center">用来给ServerChannel添加配置</td>
</tr>
<tr>
<td align="center">public  ServerBootstrap childOption(ChannelOption childOption, T value)</td>
<td align="center">用来给接收到的通道添加配置</td>
</tr>
<tr>
<td align="center">public ServerBootstrap childHandler(ChannelHandler childHandler)</td>
<td align="center">该方法用来设置业务处理类(自定义的handler)</td>
</tr>
<tr>
<td align="center">public ChannelFuture bind(int inetPort)</td>
<td align="center">该方法用于服务器端，用来设置占用的端口号</td>
</tr>
<tr>
<td align="center">public ChannelFuture connect(String inetHost, int inetPort)</td>
<td align="center">该方法用于客户端，用来连接服务器</td>
</tr>
</tbody></table>
<h3 id="4-2-Future、ChannelFuture"><a href="#4-2-Future、ChannelFuture" class="headerlink" title="4.2 Future、ChannelFuture"></a>4.2 Future、ChannelFuture</h3><blockquote>
<p>说明</p>
</blockquote>
<p><code>Netty</code>中所有的IO操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完或者直接注册一个监听，具体的实现就是通过<code>Future</code>和<code>ChannelFuture</code>，它们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p>
<blockquote>
<p>常用方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">方法介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Channel channel()</td>
<td align="center">返回当前正在进行IO操作的通道</td>
</tr>
<tr>
<td align="center">ChannelFuture sync()</td>
<td align="center">等待异步操作执行完毕，相当于将阻塞在当前</td>
</tr>
</tbody></table>
<h3 id="4-3-Channel"><a href="#4-3-Channel" class="headerlink" title="4.3 Channel"></a>4.3 Channel</h3><blockquote>
<p>说明</p>
</blockquote>
<ul>
<li><code>Netty</code>网络通信的组件，能够用于执行网络I/O操作</li>
<li>通过<code>Channel</code>可获得当前网络连接的通道的状态</li>
<li>通过<code>Channel</code>可获得网络连接的配置参数</li>
<li><code>Channel</code>通过异步的网络I/O操作(比如：建立连接、读写和绑定端口)，异步调用意味着任何I/O调用都将立即返回，并且不保证在调用结束时所请求的I/O操作已完成</li>
<li>调用立即返回一个<code>ChannelFuture</code>实例，通过注册器到<code>ChannelFuture</code>上，可以I/O操作成功、失败或取消时回调通知调用方 </li>
<li>支持关联I/O操作与对应的处理程序</li>
<li>不同协议、不同的阻塞类型的连接都有不同的<code>Channel</code>类型与之对应</li>
</ul>
<blockquote>
<p>常见Channel类型</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NioSocketChannel</td>
<td align="center">异步的客户端TCP Socket连接</td>
</tr>
<tr>
<td align="center">NioServerSocketChannel</td>
<td align="center">异步的服务器端TCP Socket连接</td>
</tr>
<tr>
<td align="center">NioDatagramChannel</td>
<td align="center">异步的UDP连接</td>
</tr>
<tr>
<td align="center">NioSctpChannel</td>
<td align="center">异步的客户端Sctp连接</td>
</tr>
<tr>
<td align="center">NioSctpServerChannel</td>
<td align="center">异步的Sctp服务器端连接，这些通道涵盖了UDP和TCP网络I/O以及文件I/O</td>
</tr>
</tbody></table>
<h3 id="4-4-Selector"><a href="#4-4-Selector" class="headerlink" title="4.4 Selector"></a>4.4 Selector</h3><blockquote>
<p>说明</p>
</blockquote>
<ul>
<li><code>Netty</code>基于<code>Selector</code>对象实现I/O多路复用，通过<code>Selector</code>一个线程可以监听多个连接的<code>Channel</code>事件</li>
<li>当向一个<code>Selector</code>中注册<code>Channel</code>后，<code>Selector</code>内部的机制就可以自动不断地查询(<code>Select</code>)这些注册的<code>Channel</code>是否有已就绪的I/O事件(比如：可读、可写、网络连接完成等)，这样程序就可以很简单地使用一个线程高效地管理多个<code>Channel</code></li>
<li>同时，<code>Netty</code>中对<code>Selector</code>中的<code>selectedKey</code>集合进行了替换，它替换成了一个它自己实现的一个<code>set</code>集合，这样效率更高</li>
</ul>
<h3 id="4-5-ChannelHandler及其实现类"><a href="#4-5-ChannelHandler及其实现类" class="headerlink" title="4.5 ChannelHandler及其实现类"></a>4.5 ChannelHandler及其实现类</h3><blockquote>
<p>说明</p>
</blockquote>
<ul>
<li><p><code>ChannelHandler</code>是一个接口，处理I/O事件或拦截I/O操作，并将其转发到<code>ChannelPipeline</code>(业务处理链)中的下一个处理程序</p>
</li>
<li><p><code>ChannelHandler</code>本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</p>
</li>
<li><p>我们经常需要自定义一个<code>Handler</code>类取继承<code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑</p>
<p>一般需要重写的方法</p>
<pre><code class="java">public class ChannelInboundHandlerAdapter extends ChannelHandlerAdapter implements ChannelInboundHandler &#123;

    //通道注册事件
    @Skip
    @Override
    public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;
        ctx.fireChannelRegistered();
    &#125;

    //通道取消注册事件
    @Skip
    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception &#123;
        ctx.fireChannelUnregistered();
    &#125;

    //通道就绪事件
    @Skip
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
        ctx.fireChannelActive();
    &#125;

    //通道断联事件
    @Skip
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
        ctx.fireChannelInactive();
    &#125;

    //通道读取数据事件
    @Skip
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;
        ctx.fireChannelRead(msg);
    &#125;

    //通道数据读取完毕事件
    @Skip
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;
        ctx.fireChannelReadComplete();
    &#125;

    //用法事件触发
    @Skip
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;
        ctx.fireUserEventTriggered(evt);
    &#125;

    //通道可写性更改事件
    @Skip
    @Override
    public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception &#123;
        ctx.fireChannelWritabilityChanged();
    &#125;

    //通道发生异常事件
    @Skip
    @Override
    @SuppressWarnings(&quot;deprecation&quot;)
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)
            throws Exception &#123;
        ctx.fireExceptionCaught(cause);
    &#125;
&#125;</code></pre>
<ul>
<li><code>ChannelInboundHandler</code>  用于处理入站I/O事件</li>
<li><code>ChannelOutboundHandler</code>  用于处理出战I/O事件</li>
</ul>
<blockquote>
<p>适配器</p>
</blockquote>
</li>
<li><p><code>ChannelInboundHandlerAdapter</code> 用于处理入站 I/O 事件</p>
</li>
<li><p><code>ChannelOutboundHandlerAdapter</code> 用于处理出站 I/O 操作</p>
</li>
<li><p><code>ChannelDuplexHandler</code> 用于处理入站和出站事件</p>
</li>
</ul>
<h3 id="4-6-Pipeline、Channel"><a href="#4-6-Pipeline、Channel" class="headerlink" title="4.6 Pipeline、Channel"></a>4.6 Pipeline、Channel</h3><blockquote>
<p>说明</p>
</blockquote>
<ul>
<li><p><code>ChannelPipeline</code>是一个Handler的集合，它负责处理和拦截<code>inbound</code>和<code>outbound</code>的事件和操作，相当于一个贯穿<code>Netty</code>的链（通俗的讲：<code>ChannelPipeline</code>是保存<code>ChannelHandler</code>的<code>list</code>，用于处理或拦截<code>Channel</code>的入站事件和出战操作）</p>
</li>
<li><p><code>ChanenelPipline</code>实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及<code>Channel</code>中各个的<code>ChannelHandler</code>如何相互交互</p>
</li>
<li><p>在<code>Netty</code>中每个<code>Channel</code>都有且仅有一个<code>ChannelPipeline</code>与之对应，他们的组成关系如下</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/1c6ba3e2/image-20201002192427279.png" class="" title="image-20201002192427279">
</li>
<li><p>一个<code>Channel</code>包含一个<code>ChannelPipeline</code>，而<code>ChannelPipeline</code>中又维护了一个由<code>ChannelHandlerContext</code>组成的双向链表，并且每个<code>ChannelHandlerContext</code>中又关联着一个<code>ChannelHandler</code></p>
</li>
<li><p>入站事件和出战事件在一个双向链表中，入站事件会从链表<code>head</code>往后传递到最后一个入站的handler，出站事件会从链表<code>tail</code>往前传递到最前一个出站的<code>handler</code>，两种类型的<code>handler</code>互不干扰</p>
</li>
</ul>
<blockquote>
<p>常用方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">方法介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ChannelPipeline addFirst(ChannelHandler… handlers)</td>
<td align="center">把一个业务处理类（handler）添加到链中的第一个位置</td>
</tr>
<tr>
<td align="center">ChannelPipeline addLast(ChannelHandler… handlers)</td>
<td align="center">把一个业务处理类（handler）添加到链中的最后一个位置</td>
</tr>
</tbody></table>
<h3 id="4-7-ChannelHandlerContext"><a href="#4-7-ChannelHandlerContext" class="headerlink" title="4.7 ChannelHandlerContext"></a>4.7 ChannelHandlerContext</h3><blockquote>
<p>说明</p>
</blockquote>
<ul>
<li>保存<code>Channel</code>相关的所有上下文信息，同时关联一个ChannelHandler对象</li>
<li>即<code>ChannelHandlerContext</code>中包含一个具体的事件处理器<code>ChannelHandler</code>，同时<code>ChannelHandlerContext</code>中也绑定了对应的<code>Pipeline</code>和<code>Channel</code>的信息，方便对<code>ChannelHandler</code>进行调用</li>
</ul>
<blockquote>
<p>常见方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">方法介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ChannelFuture close()</td>
<td align="center">关闭通道</td>
</tr>
<tr>
<td align="center">ChannelOutboundInvoker flush()</td>
<td align="center">刷新</td>
</tr>
<tr>
<td align="center">ChannelFuture writeAndFlush(Object msg)</td>
<td align="center">将数据写到ChannelPipeline中当前ChannelHandler的下一个ChannelHandler开始处理</td>
</tr>
</tbody></table>
<h3 id="4-8-ChannelOption"><a href="#4-8-ChannelOption" class="headerlink" title="4.8 ChannelOption"></a>4.8 ChannelOption</h3><blockquote>
<p>说明</p>
</blockquote>
<p><code>Netty</code>在创建<code>Channel</code>实例后，一般都需要设置<code>ChannelOption</code>参数</p>
<blockquote>
<p>参数如下：</p>
</blockquote>
<ul>
<li>ChannelOption.SO_BACKLOG:<ul>
<li>对应TCP/IP协议listen函数中的backlog参数，用来初始化服务器可连接队列大小</li>
<li>服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog参数指定了队列的大小</li>
</ul>
</li>
<li>ChannelOption.SO_KEEPALIVE:<ul>
<li>一直保持连接活动状态</li>
</ul>
</li>
</ul>
<h3 id="4-9-EventLoopGroup和其实现类NioEventLoopGroup"><a href="#4-9-EventLoopGroup和其实现类NioEventLoopGroup" class="headerlink" title="4.9 EventLoopGroup和其实现类NioEventLoopGroup"></a>4.9 EventLoopGroup和其实现类NioEventLoopGroup</h3><blockquote>
<p>说明</p>
</blockquote>
<ul>
<li><code>EventLoopGroup</code>是一组<code>EventLoop</code>的抽象，<code>Netty</code>为了更好的利用多核CPU资源，一般会有多个<code>EventLoop</code>同时工作，每个<code>EventLoop</code>维护者一个Selector实例。</li>
<li><code>EventLoopGroup</code>提供next接口，可以从组里面按照一定规则获取其中一个<code>EventLoop</code>来处理任务。在Netty服务器端编程中，我们一般都需要提供两个<code>EventLoopGroup</code>，<code>BossGroup</code>和<code>WorkerGroup</code></li>
<li>通常一个服务端口即一个<code>ServerSocketChannel</code>对应一个<code>Selector</code>和一个<code>EventLoop</code>线程。<code>BossEventLoop</code>负责接收客户端的连接并将<code>SocketChannel</code>交给<code>WorkerEventLoopGroup</code>来进行IO处理</li>
<li><code>BossEventLoopGroup</code>通常是一个单线程的<code>EventLoop</code>，<code>EventLoop</code>维护着一个注册了<code>ServerSocketChannel</code>的<code>Selector</code>实例<code>BossEventLoop</code>不断轮询<code>Selector</code>将连接事件分离出来</li>
<li>通常是OP_ACCEPT事件，然后将接收到的<code>SocketChannel</code>交给<code>WorkerEventLoopGroup</code></li>
<li><code>WorkerEventLoopGroup</code>会由<code>next</code>选择其中一个<code>EventLoop</code>来将这个<code>SocketChannel</code>注册到其维护的<code>Selector</code>并对其后续的IO事件进行处理</li>
</ul>
<blockquote>
<p>常用方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">方法介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public NioEventLoopGroup()</td>
<td align="center">构造方法</td>
</tr>
<tr>
<td align="center">public Future&lt;?&gt; shutdownGracefully()</td>
<td align="center">断开连接，关闭线程</td>
</tr>
</tbody></table>
<h3 id="4-10-Unpooled"><a href="#4-10-Unpooled" class="headerlink" title="4.10 Unpooled"></a>4.10 Unpooled</h3><blockquote>
<p>说明</p>
</blockquote>
<p><code>Netty</code>提供一个专门用来操作缓冲区（即<code>Netty</code>的数据容器）的工具类</p>
<blockquote>
<p>常用方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">方法名称</th>
<th align="center">方法介绍</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public static ByteBuf copiedBuffer(CharSequence string, Charset charset)</td>
<td align="center">通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别）</td>
</tr>
</tbody></table>
<h3 id="4-11-群聊系统"><a href="#4-11-群聊系统" class="headerlink" title="4.11 群聊系统"></a>4.11 群聊系统</h3><blockquote>
<p>要求</p>
</blockquote>
<ul>
<li>编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li>
<li>实现多人群聊</li>
<li>服务器：可以监测用户上线，离线，并实现消息转发功能</li>
<li>客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(由服务器转发得到)</li>
</ul>
<blockquote>
<p>GroupChatServer.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.groupChat;

import com.kag.nio.groupchat.GroupChatClient;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;

/**
 * @author: KHighness
 * @date: 2020/10/2 8:19
 * @apiNote:
 */

public class GroupChatServer &#123;

    private int port;

    public GroupChatServer(int port) &#123;
        this.port = port;
    &#125;

    public void run() &#123;

        // 创建两个线程组
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        EventLoopGroup workerGroup = new NioEventLoopGroup();

        ServerBootstrap serverBootstrap = new ServerBootstrap();

        serverBootstrap.group(workerGroup, workerGroup)
                .channel(NioServerSocketChannel.class)
                .option(ChannelOption.SO_BACKLOG, 128)
                .childOption(ChannelOption.SO_KEEPALIVE, true)
                .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel channel) throws Exception &#123;
                        // 获取pipeline
                        ChannelPipeline pipeline = channel.pipeline();;
                        // 向pipeline加入解码器
                        pipeline.addLast(&quot;decoder&quot;, new StringDecoder());
                        // 向pipeline加入编码器
                        pipeline.addLast(&quot;encoder&quot;, new StringEncoder());
                        // 加入自己的业务处理handler
                        pipeline.addLast(new GroupChatServerHandler());
                    &#125;
                &#125;);

        try &#123;
            System.out.println(&quot;▶-----Netty服务器启动-----◀&quot;);
            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();

            // 监听关闭
            channelFuture.channel().closeFuture().sync();
        &#125; catch (InterruptedException e) &#123;
            System.out.println(e.getMessage());
        &#125; finally &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        new GroupChatServer(3333).run();
    &#125;
&#125;</code></pre>
<blockquote>
<p>GroupChatServerHandler.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.groupChat;

import io.netty.channel.Channel;
import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;
import io.netty.channel.group.ChannelGroup;
import io.netty.channel.group.DefaultChannelGroup;
import io.netty.util.concurrent.EventExecutor;
import io.netty.util.concurrent.GlobalEventExecutor;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

/**
 * @author: KHighness
 * @date: 2020/10/2 8:33
 * @apiNote:
 */

public class GroupChatServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;

    // 定义一个channel组，管理所有的channel
    // GlobalEventExecutor.INSTANCE 是全局的时间执行器，是一个单例
    EventExecutor executor;
    private static ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);

    private String now() &#123;
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        return simpleDateFormat.format(new Date());
    &#125;

    /**
     * HandlerAdded
     * 表示连接建立，一旦连接，第一个被执行
     * @param ctx
     * @throws Exception
     */
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;
        Channel channel = ctx.channel();
        // 将该客户加入聊天的信息推送给其他在线的客户
        // 该方法会将channelGroup中的所有channel遍历，并发送消息
        channelGroup.writeAndFlush(now() + &quot; [客户端]&quot; + channel.remoteAddress() + &quot;加入聊天\n&quot;);
        channelGroup.add(channel);
    &#125;

    /**
     * HandlerRemoved
     * 表示断开连接，将XX客户离线信息推送给当前在线客户
     * @param ctx
     * @throws Exception
     */
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;
        Channel channel = ctx.channel();
        channelGroup.writeAndFlush(now() + &quot; [客户端]&quot; + channel.remoteAddress() + &quot;离开聊天\n&quot;);
        System.out.println(&quot;Channel Group Size = &quot; + channelGroup.size());
    &#125;

    /**
     * channelActive
     * 表示channel处于活动状态，提示XX上线
     * @param ctx
     * @throws Exception
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;
        System.out.println(now() + &quot; &quot; + ctx.channel().remoteAddress() + &quot;上线&quot;);
    &#125;

    /**
     * channelInactive
     * 表示channel处于非活动状态
     * @param ctx
     * @throws Exception
     */
    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;
        System.out.println(now() + &quot; &quot; + ctx.channel().remoteAddress() + &quot;离线&quot;);
    &#125;

    /**
     * ChannelRead0
     * 转发消息
     * @param channelHandlerContext
     * @param s
     * @throws Exception
     */
    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;
        Channel channel = channelHandlerContext.channel();
        // 遍历ChannelGroup
        channelGroup.forEach(ch -&gt; &#123;
            if (channel != ch) // 不是当前channel，直接转发
                ch.writeAndFlush(now() + &quot; [客户]&quot; + channel.remoteAddress() + &quot;：&quot; + s + &quot;\n&quot;);
            else // 当前channel是自己
                ch.writeAndFlush(now() + &quot; [自己]: &quot; + s + &quot;\n&quot;);
        &#125;);
    &#125;

    /**
     * 异常处理
     * @param ctx
     * @param cause
     * @throws Exception
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;
        super.exceptionCaught(ctx, cause);
    &#125;

&#125;</code></pre>
<blockquote>
<p>GroupChatClient.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.groupChat;

import io.netty.bootstrap.Bootstrap;
import io.netty.channel.*;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioSocketChannel;
import io.netty.handler.codec.string.StringDecoder;
import io.netty.handler.codec.string.StringEncoder;

import java.net.SocketAddress;
import java.util.Scanner;

/**
 * @author: KHighness
 * @date: 2020/10/2 9:22
 * @apiNote:
 */

public class GroupChatClient &#123;

    private final String host;
    private final int port;

    public GroupChatClient(String host, int port) &#123;
        this.host = host;
        this.port = port;
    &#125;

    public void run() &#123;
        EventLoopGroup group = new NioEventLoopGroup();

        Bootstrap bootstrap = new Bootstrap()
                .group(group)
                .channel(NioSocketChannel.class)
                .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                    @Override
                    protected void initChannel(SocketChannel channel) throws Exception &#123;
                        // 得到pipeline
                        ChannelPipeline pipeline = channel.pipeline();
                        // 加入相关handler
                        pipeline.addLast(&quot;decoder&quot;, new StringDecoder());
                        pipeline.addLast(&quot;encoder&quot;, new StringEncoder());
                        // 加入自定义的handler
                        pipeline.addLast(new GroupChatClientHandler());
                    &#125;
                &#125;);

        try &#123;
            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();
            Channel channel = channelFuture.channel();
            System.out.println(&quot;▶-----&quot; + channel.localAddress().toString().substring(1) + &quot;-----◀&quot;);
            // 输入信息
            Scanner scanner = new Scanner(System.in);
            while (scanner.hasNextLine()) &#123;
                String msg = scanner.nextLine();
                // 通过channel发送到服务器端
                channel.writeAndFlush(msg + &quot;\r\n&quot;);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            System.out.println(e.getMessage());
        &#125; finally &#123;
            group.shutdownGracefully();
        &#125;
    &#125;

    public static void main(String[] args) throws Exception&#123;
        new GroupChatClient(&quot;127.0.0.1&quot;, 3333).run();
    &#125;
&#125;</code></pre>
<blockquote>
<p>GroupChatClientHandler.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.groupChat;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.SimpleChannelInboundHandler;

/**
 * @author: KHighness
 * @date: 2020/10/2 10:06
 * @apiNote:
 */

public class GroupChatClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, String s) throws Exception &#123;
        System.out.println(s.trim());
    &#125;
&#125;</code></pre>
<h3 id="4-12-心跳检测"><a href="#4-12-心跳检测" class="headerlink" title="4.12 心跳检测"></a>4.12 心跳检测</h3><blockquote>
<p>要求</p>
</blockquote>
<ul>
<li>当服务器超过3秒没有读操作时，就提示读空闲</li>
<li>当服务器超过5秒没有写操作时，就提示写空闲</li>
<li>当服务器超过7秒没有读或写时，就提示读写空闲</li>
</ul>
<blockquote>
<p>MyServer.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.heartbeat;

import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelPipeline;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.logging.LogLevel;
import io.netty.handler.logging.LoggingHandler;
import io.netty.handler.timeout.IdleStateHandler;

import java.util.concurrent.TimeUnit;

/**
 * @author: KHighness
 * @date: 2020/10/2 10:25
 * @apiNote:
 */

public class MyServer &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        NioEventLoopGroup bossGroup = new NioEventLoopGroup(1);
        NioEventLoopGroup workerGroup = new NioEventLoopGroup();

        try &#123;
            ServerBootstrap serverBootstrap = new ServerBootstrap();
            serverBootstrap.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class)
                    .handler(new LoggingHandler(LogLevel.INFO))  //为BossGroup中的请求添加日志处理Handler
                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;
                        @Override
                        protected void initChannel(SocketChannel ch) throws Exception &#123;
                            ChannelPipeline pipeline = ch.pipeline();
                            /**
                             * 加入一个 netty 提供的 IdleStateHandler
                             * 说明
                             * 1、IdleStateHandler 是 netty 提供的检测空闲状态的处理器
                             * 2、long readerIdleTime：表示多长时间没有读，就会发送一个心跳检测包检测是否还是连接的状态
                             * 3、long writerIdleTime：表示多长时间没有写，就会发送一个心跳检测包检测是否还是连接的状态
                             * 4、long allIdleTime：表示多长时间没有读写，就会发送一个心跳检测包检测是否还是连接的状态
                             * 5、当 IdleStateEvent 触发后，就会传递给管道的下一个 Handler，通过调用（触发）下一个Handler的 userEventTriggered，在该方法区处理这个事件。
                             */
                            pipeline.addLast(new IdleStateHandler(3, 5, 7, TimeUnit.SECONDS));

                            //加入一个对空闲检测进一步处理的Handler（自定义）
                            pipeline.addLast(new MyServerHandler());
                        &#125;
                    &#125;);
            //启动服务器，设置为同步模式
            ChannelFuture channelFuture = serverBootstrap.bind(3333).sync();
            channelFuture.channel().closeFuture().sync();
        &#125; finally &#123;
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>MyServerHandler.java</p>
</blockquote>
<pre><code class="java">package com.kag.netty.heartbeat;

import io.netty.channel.ChannelHandlerContext;
import io.netty.channel.ChannelInboundHandlerAdapter;
import io.netty.handler.timeout.IdleStateEvent;

/**
 * @author: KHighness
 * @date: 2020/10/2 10:48
 * @apiNote:
 */

public class MyServerHandler extends ChannelInboundHandlerAdapter &#123;

    /**
     *
     * @param ctx 上下文
     * @param evt 事件
     * @throws Exception
     */
    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;
        if (evt instanceof IdleStateEvent) &#123;
            // 将evt向下转型
            IdleStateEvent event = (IdleStateEvent) evt;
            String eventType = null;
            switch (event.state()) &#123;
                case READER_IDLE:
                    eventType = &quot;读空闲&quot;;
                    break;
                case WRITER_IDLE:
                    eventType = &quot;写空闲&quot;;
                    break;
                case ALL_IDLE:
                    eventType = &quot;读写空闲&quot;;
                    break;
            &#125;
            System.out.println(ctx.channel().remoteAddress() + &quot;——&gt;超时：&quot; + eventType);

            // 如果发生空闲，直接关闭通道
//            ctx.channel().close();
//            System.out.println(&quot;服务器关闭通道···&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="4-13-简单总结"><a href="#4-13-简单总结" class="headerlink" title="4.13 简单总结"></a>4.13 简单总结</h3><blockquote>
<p>服务器</p>
</blockquote>
<ol>
<li>创建两个线程组，<code>bossGroup</code>和<code>workerGroup</code></li>
<li>创建服务器启动对象<code>ServerBootStrap</code></li>
<li>链式编程配置<code>ServerBootStrap</code>的参数<ol>
<li><code>group</code>：设置线程组<code>bossGroup</code>和<code>workerGroup</code></li>
<li><code>channel</code>：设置通道实现，一般选择<code>NioServerSocketChannel</code></li>
<li><code>option</code>：设置可连接线程队列以及大小，一般选择<code>SO_BACKLOG</code></li>
<li><code>childOption</code>：设置保持活动连接状态，选择<code>SO_KEEPALIVE</code></li>
<li><code>handler</code>：给<code>bossGroup</code>设置<code>Handler</code></li>
<li><code>childHandler</code>：给<code>workerGroup</code>设置<code>Hadnler</code></li>
</ol>
</li>
<li><code>ServerBootStrap</code>绑定端口，设置同步，并且监听通道关闭事件</li>
</ol>
<blockquote>
<p>客户端</p>
</blockquote>
<ol>
<li>创建一个线程组<code>group</code></li>
<li>创建客户端启动对象<code>BootStrap</code></li>
<li>链式编程配置<code>BootStrap</code>的参数<ol>
<li><code>group</code>：设置线程组<code>group</code></li>
<li><code>channel</code>：设置通道实现，一般选择<code>NioSocketChannel</code></li>
<li><code>handler</code>：设置<code>Handler</code></li>
</ol>
</li>
<li><code>BootStrap</code>绑定端口，设置同步，并且监听通道关闭事件</li>
</ol>
<blockquote>
<p>常见Handler</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Handler</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SimpleChannelInboundHandler</td>
<td align="center">处理通信(服务器最常用)</td>
</tr>
<tr>
<td align="center">IdleStateHandler</td>
<td align="center">检测空闲状态(心跳检测)</td>
</tr>
<tr>
<td align="center">WebSocketServerProtocolHandler</td>
<td align="center">将http协议升级ws协议，保持长连接</td>
</tr>
</tbody></table>
<blockquote>
<p>Handler常用方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Method</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">handlerAdded(ChannelHandlerContext ctx)</td>
<td align="center">连接建立，一旦建立连接，第一个被执行的方法</td>
</tr>
<tr>
<td align="center">handlerRemoved(ChannelHandlerContext ctx)</td>
<td align="center">连接断开，将XX客户离线信息推送给当前在线客户</td>
</tr>
<tr>
<td align="center">channelActive(ChannelHandlerContext ctx)</td>
<td align="center">表示channel处于活动状态，提示XX上线</td>
</tr>
<tr>
<td align="center">channelInactive(ChannelHandlerContext ctx)</td>
<td align="center">表示channel处于非活动状态，提示XX离线</td>
</tr>
<tr>
<td align="center">channelRead0(ChannelHandlerContext channelHandlerContext, String s)</td>
<td align="center">读取数据，并进行消息转发</td>
</tr>
<tr>
<td align="center">exceptionCaught(ChannelHandlerContext ctx, Throwable cause)</td>
<td align="center">异常处理</td>
</tr>
<tr>
<td align="center">userEventTriggered(ChannelHandlerContext ctx, Object evt)</td>
<td align="center">事件触发器。在<code>IdleStateHandler</code>后面加上一个触发器，可以检测心跳。</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://parak.top">Khighness</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://parak.top/posts/1c6ba3e2">https://parak.top/posts/1c6ba3e2</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"> CC BY-NC-SA 4.0 </a>许可协议。转载请注明来自<a href="https://www.parak.top">炒菜K殿下</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Server/">Server</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/wepay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/wepay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/ec060e02/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/images/top/bg-4.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">大数据</div></div></a></div><div class="next-post pull-right"><a href="/posts/3e51ba23/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-2.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java8-Stream</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-IO"><span class="toc-text">1. IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-BIO"><span class="toc-text">1.1 BIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%AE%9E%E4%BE%8B"><span class="toc-text">1.1.2 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E9%85%8D%E7%BD%AE"><span class="toc-text">1.1.3 配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E8%BF%90%E8%A1%8C"><span class="toc-text">1.1.4 运行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-5-%E4%B8%8D%E8%B6%B3"><span class="toc-text">1.1.5 不足</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-NIO"><span class="toc-text">1.2 NIO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.2.1 介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E6%AF%94%E8%BE%83"><span class="toc-text">1.2.2 比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E7%BB%84%E4%BB%B6"><span class="toc-text">1.2.3 组件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-1-Buffer"><span class="toc-text">1.2.3.1 Buffer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-2-Channel"><span class="toc-text">1.2.3.2 Channel</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-3-3-Selector"><span class="toc-text">1.2.3.3 Selector</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E7%BC%96%E7%A8%8B"><span class="toc-text">1.2.3 编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-4-%E5%AE%9E%E4%BE%8B"><span class="toc-text">1.2.4 实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-5-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-text">1.2.5 零拷贝</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A6%82%E8%BF%B0"><span class="toc-text">2. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">1.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%AE%BE%E8%AE%A1"><span class="toc-text">1.2 设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%80%A7%E8%83%BD"><span class="toc-text">1.3 性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%9E%B6%E6%9E%84"><span class="toc-text">1.4 架构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Reactor"><span class="toc-text">3. Reactor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D"><span class="toc-text">2.1 介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E7%BB%84%E6%88%90"><span class="toc-text">2.2 组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%88%86%E7%B1%BB"><span class="toc-text">2.3 分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.2.1 单Reactor单线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%8D%95Reactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.2.2 单Reactor多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-%E4%B8%BB%E4%BB%8EReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">2.2.3 主从Reactor多线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E4%BC%98%E7%82%B9"><span class="toc-text">2.4 优点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9E%B6%E6%9E%84"><span class="toc-text">4. 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%9B%BE%E7%A4%BA"><span class="toc-text">3.1 图示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%AF%B4%E6%98%8E"><span class="toc-text">3.2 说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.3 代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="toc-text">3.4 任务队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-text">3.5 异步模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-1-%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">3.5.1 基本介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-2-Future%E8%AF%B4%E6%98%8E"><span class="toc-text">3.5.2 Future说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-3-Future-Listener%E6%9C%BA%E5%88%B6"><span class="toc-text">3.5.3 Future-Listener机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-Http%E6%9C%8D%E5%8A%A1"><span class="toc-text">3.6 Http服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%A0%B8%E5%BF%83"><span class="toc-text">5. 核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-BootStrap%E3%80%81ServerBootStrap"><span class="toc-text">4.1 BootStrap、ServerBootStrap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Future%E3%80%81ChannelFuture"><span class="toc-text">4.2 Future、ChannelFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Channel"><span class="toc-text">4.3 Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Selector"><span class="toc-text">4.4 Selector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-ChannelHandler%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">4.5 ChannelHandler及其实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-Pipeline%E3%80%81Channel"><span class="toc-text">4.6 Pipeline、Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-ChannelHandlerContext"><span class="toc-text">4.7 ChannelHandlerContext</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-ChannelOption"><span class="toc-text">4.8 ChannelOption</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-EventLoopGroup%E5%92%8C%E5%85%B6%E5%AE%9E%E7%8E%B0%E7%B1%BBNioEventLoopGroup"><span class="toc-text">4.9 EventLoopGroup和其实现类NioEventLoopGroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-Unpooled"><span class="toc-text">4.10 Unpooled</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-%E7%BE%A4%E8%81%8A%E7%B3%BB%E7%BB%9F"><span class="toc-text">4.11 群聊系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-12-%E5%BF%83%E8%B7%B3%E6%A3%80%E6%B5%8B"><span class="toc-text">4.12 心跳检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-13-%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93"><span class="toc-text">4.13 简单总结</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Khighness/cdn/common/footer.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Khighness</div><div class="footer_custom_text"><a href="https://www.foreverblog.cn/" target="_blank" > <img src="https://img.foreverblog.cn/logo_en_default.png" alt="" style="width:auto;height:16px;"> </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'hexo-2grv2lyu1131c342',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'hexo-2grv2lyu1131c342',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Py2eOHzSdrnxKPzKrOJaHJOq-9Nh9j0Va',
      appKey: '9eQhwuCgyshpYKn4rtEhqt4R',
      placeholder: '',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: 'https://cdn.jsdelivr.net/gh/imaegoo/emotion/owo.json',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick, mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/js/Valine.min.js').then(initValine)
}

if ('Twikoo' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'hexo-2grv2lyu1131c342',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>