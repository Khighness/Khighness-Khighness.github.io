<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JUC-2(共享模型之管程) | Khighness</title><meta name="keywords" content="Java"><meta name="author" content="Khighness"><meta name="copyright" content="Khighness"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="2.1 第一部分-线程安全2.1.1 线程安全问题 案例  两个线程对初始值为0的静态变量一个做自增，一个做自增，一个做自减，结果是0吗？ @Slf4j(topic &#x3D; &quot;AddSub&quot;) public class AddSubDemo &amp;#123;      static int counter &#x3D; 0;      public static void main(String">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC-2(共享模型之管程)">
<meta property="og:url" content="https://www.parak.top/posts/62531/index.html">
<meta property="og:site_name" content="Khighness">
<meta property="og:description" content="2.1 第一部分-线程安全2.1.1 线程安全问题 案例  两个线程对初始值为0的静态变量一个做自增，一个做自增，一个做自减，结果是0吗？ @Slf4j(topic &#x3D; &quot;AddSub&quot;) public class AddSubDemo &amp;#123;      static int counter &#x3D; 0;      public static void main(String">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-23.jpg">
<meta property="article:published_time" content="2021-04-24T16:00:00.000Z">
<meta property="article:modified_time" content="2021-05-05T14:39:43.447Z">
<meta property="article:author" content="Khighness">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-23.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/K.jpg"><link rel="canonical" href="https://www.parak.top/posts/62531/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//s4.cnzz.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16576652";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" data-pjax="data-pjax" src="https://s4.cnzz.com/z_stat.php?id=1279324689&amp;web_id=1279324689"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Khighness","link":"链接: ","source":"来源: Khighness","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-05-05 22:39:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/iconfont/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Khighness" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/Khighness.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-23.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Khighness</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JUC-2(共享模型之管程)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-24T16:00:00.000Z" title="发表于 2021-04-25 00:00:00">2021-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-05-05T14:39:43.447Z" title="更新于 2021-05-05 22:39:43">2021-05-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JUC/">JUC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JUC-2(共享模型之管程)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="2-1-第一部分-线程安全"><a href="#2-1-第一部分-线程安全" class="headerlink" title="2.1 第一部分-线程安全"></a>2.1 第一部分-线程安全</h2><h3 id="2-1-1-线程安全问题"><a href="#2-1-1-线程安全问题" class="headerlink" title="2.1.1 线程安全问题"></a>2.1.1 线程安全问题</h3><blockquote>
<p>案例</p>
</blockquote>
<p>两个线程对初始值为0的静态变量一个做自增，一个做自增，一个做自减，结果是0吗？</p>
<pre><code class="java">@Slf4j(topic = &quot;AddSub&quot;)
public class AddSubDemo &#123;

    static int counter = 0;

    public static void main(String[] args) throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                counter++;
            &#125;
        &#125;, &quot;t1&quot;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                counter--;
            &#125;
        &#125;);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug(&quot;counter = &#123;&#125;&quot;, counter);
    &#125;
&#125;</code></pre>
<p>结果是变化的。</p>
<blockquote>
<p>分析</p>
</blockquote>
<p>对于静态变量i，自增和自减的字节码指令如下：</p>
<pre><code class="java"># i++
getstatic i // 获取静态变量i的值
iconst_1    // 准备常量1
iadd        // 自增
putstatic i // 将修改后的值存入静态变量i
# i--
getstatic i // 获取静态变量i的值
iconst_1    // 准备常量1
isub        // 自减
putstatic i // 将修改后的值存入静态变量i</code></pre>
<p>Java的内存模型如下，完成静态变量的自增和自减，需要在主存和工作内存中进行数据交换：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210407174859979.png" class="" title="image-20210407174859979">

<p>如果是单线程顺序执行以上8行字节码指令，不会出现问题：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210407175158573.png" class="" title="image-20210407175158573">

<p>但是在双线程的情况下，会产生指令重排序，导致各种问题，比如脏读（读取更新未保存的数据）：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210407175406638.png" class="" title="image-20210407175406638">



<blockquote>
<p>拓展</p>
</blockquote>
<p><code>i++</code>、<code>i--</code>、<code>++i</code>、<code>--i</code>等操作都是非原子性的，因为JVM指令可并非一条。可以分析一下字节码指令（<code>javap -v</code>）。</p>
<p><code>i++</code>的代码如下：</p>
<pre><code class="java">int i = 0;
System.out.println(i++);</code></pre>
<p>字节码指令：</p>
<pre><code>0 iconst_0                                         # 将常量0加载到栈顶
1 istore_1                                         # 弹出栈顶元素，并赋值给局部变量表中索引为1的位置
2 getstatic #2 &lt;java/lang/System.out&gt;              # 获取系统类的静态属性
5 iload_1                                          # 将局部变量表中索引为1的元素加载到栈顶
6 iinc 1 by 1                                      # 直接把局部变量表中索引为1的元素值+1
9 invokevirtual #3 &lt;java/io/PrintStream.println&gt;   # 调用流的打印方法</code></pre>
<p>顺序：先将元素加载到栈顶，然后更新局部变量表的元素的值。</p>
<p><code>++i</code>的代码如下：</p>
<pre><code class="java">int i = 0;
System.out.println(++i);</code></pre>
<p>字节码指令：</p>
<pre><code class="j">0 iconst_0                                         # 将常量0加载到栈顶
1 istore_1                                         # 弹出栈顶元素，并赋值给局部变量表中索引为1的位置
2 getstatic #2 &lt;java/lang/System.out&gt;              # 获取系统类的静态属性
5 iinc 1 by 1                                      # 直接把局部变量表中索引为1的元素值+1
8 iload_1                                          # 将局部变量表中索引为1的元素加载到栈顶
9 invokevirtual #3 &lt;java/io/PrintStream.println&gt;   # 调用流的打印方法</code></pre>
<p>顺序：先更新局部变量表的元素的值，再将元素加载到栈顶。</p>
<blockquote>
<p>临界区</p>
</blockquote>
<p>一段代码块内如果内存堆共享资源的多线程读写操作，称这段代码块为临界区。</p>
<blockquote>
<p>竞态条件</p>
</blockquote>
<p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件。</p>
<h3 id="2-1-2-synchronized解决方案"><a href="#2-1-2-synchronized解决方案" class="headerlink" title="2.1.2 synchronized解决方案"></a>2.1.2 synchronized解决方案</h3><blockquote>
<p>应用互斥</p>
</blockquote>
<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的：</p>
<ul>
<li>阻塞式的解决方案：<code>synchoronized</code>，<code>Lock</code></li>
<li>非阻塞式的解决方案：原子变量<code>AtomicInteger</code>、<code>AtomicLong</code></li>
</ul>
<blockquote>
<p>synchronized</p>
</blockquote>
<p>语法;</p>
<pre><code class="java">synchronized (对象) &#123;
    临界区
&#125;</code></pre>
<p>解决：</p>
<pre><code class="java">@Slf4j(topic = &quot;AddSub&quot;)
public class SafeAddSubDemo &#123;

    static Integer counter = 0;
    static Object lock = new Object();

    public static void main(String[] args) throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                synchronized (lock) &#123;
                    counter++;
                &#125;
            &#125;
        &#125;, &quot;t1&quot;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                synchronized (lock) &#123;
                    counter--;
                &#125;
            &#125;
        &#125;);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug(&quot;counter = &#123;&#125;&quot;, counter);
    &#125;
&#125;</code></pre>
<p>这样就能保证输出结果为0了。</p>
<blockquote>
<p>思考</p>
</blockquote>
<p><code>synchronized</code>实际是用对象锁保证了临界区代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p>
<p>思考如下问题：</p>
<ul>
<li><p>如果把<code>synchronized(obj)</code>放在for循环的外面, 如何理解？</p>
<p>for循环也是一个原子操作, 表现出原子性。</p>
</li>
<li><p>如果t1<code>synchronized(obj1)</code> 而 t2<code>synchronized(obj2)</code>会怎么运行?<br>因为t1,、t2拿到不是同一把对象锁,，所以他们仍然会发现安全问题， 必须要是同一把对象锁。</p>
</li>
<li><p>如果t1<code>synchronized(obj)</code>而t2没有加会怎么样 ?<br>因为t2没有加锁，所以t2不需要获取t1的锁， 直接就可以执行下面的代码, 仍然会出现安全问题。</p>
</li>
</ul>
<blockquote>
<p>面向对象改进</p>
</blockquote>
<pre><code class="java">@Slf4j(topic = &quot;BetterAddAndSub&quot;)
public class BetterAddSubDemo &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        Room room = new Room();
        Thread t1 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                room.increment();
            &#125;
        &#125;, &quot;t1&quot;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 5000; i++) &#123;
                room.decrement();
            &#125;
        &#125;);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug(&quot;counter = &#123;&#125;&quot;, room.getCounter());
    &#125;
&#125;

class Room &#123;
    private int counter = 0;

    public void increment() &#123;
        synchronized (this) &#123;
            counter++;
        &#125;
    &#125;

    public void decrement() &#123;
        synchronized (this) &#123;
            counter--;
        &#125;
    &#125;

    public int getCounter() &#123;
        synchronized (this) &#123;
            return counter;
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="2-1-3-八锁现象"><a href="#2-1-3-八锁现象" class="headerlink" title="2.1.3 八锁现象"></a>2.1.3 八锁现象</h3><blockquote>
<p>方法上的synchronized</p>
</blockquote>
<pre><code class="java">class Test &#123;
    public synchronized void test() &#123; 
        // do something
    &#125;
    // 等价于（锁住的是实例对象）
    public void test() &#123;
        synchronized(this) &#123;
        // do something
        &#125;
    &#125;

    public synchronized static void test() &#123;
        // do something
    &#125;
    // 等价于（锁住的是类对象）
    public static void test() &#123;
        synchronized(Test.class) &#123;
            // do something
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>八锁现象</p>
</blockquote>
<p>情况一：<code>synchronized</code>方法锁住的是实例对象，两个方法使用同一个锁，谁先获取锁谁先执行。</p>
<p>结果：<u>AB</u></p>
<pre><code class="java">@Slf4j(topic = &quot;LockTest&quot;)
public class LockDemo1 &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        Lock lock = new Lock();
        new Thread(lock::printA, &quot;A&quot;).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(lock::printB, &quot;B&quot;).start();
    &#125;
&#125;
@Slf4j(topic = &quot;Lock&quot;)
class Lock &#123;
    public synchronized void printA() &#123; log.debug(&quot;A =&gt; [&#123;&#125;]&quot;, System.nanoTime()); &#125;
    public synchronized void printB() &#123; log.debug(&quot;B =&gt; [&#123;&#125;]&quot;, System.nanoTime()); &#125;
&#125;</code></pre>
<p>情况二：<code>synchronized</code>方法锁住的是实例对象，两个方法使用同一个锁，谁先获取锁谁先执行。</p>
<p>结果：<u>AB</u></p>
<pre><code class="java">@Slf4j(topic = &quot;LockTest1&quot;)
public class LockDemo2 &#123;
    @SneakyThrows
    public static void main(String[] args) &#123;
        Lock2 lock = new Lock2();
        new Thread(lock::printA, &quot;A&quot;).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(lock::printB, &quot;B&quot;).start();
    &#125;
&#125;
@Slf4j(topic = &quot;Lock&quot;)
class Lock2 &#123;
    @SneakyThrows
    public synchronized void printA() &#123;
        TimeUnit.SECONDS.sleep(2);
        log.debug(&quot;A =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
    public synchronized void printB() &#123;
        log.debug(&quot;B =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
&#125;</code></pre>
<p>情况三：未加<code>synchronized</code>的方法不需要等待锁。</p>
<p>结果：<u>CAB</u></p>
<pre><code class="java">@Slf4j(topic = &quot;LockTest3&quot;)
public class LockDemo3 &#123;
    @SneakyThrows
    public static void main(String[] args) &#123;
        Lock3 lock = new Lock3();
        new Thread(lock::printA, &quot;A&quot;).start();
        new Thread(lock::printB, &quot;B&quot;).start();
        new Thread(lock::printC, &quot;C&quot;).start();
    &#125;
&#125;

@Slf4j(topic = &quot;Lock3&quot;)
class Lock3 &#123;
    @SneakyThrows
    public synchronized void printA() &#123;
        TimeUnit.SECONDS.sleep(1); // 会让出CPU执行权
        log.debug(&quot;A =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
    public synchronized void printB() &#123;
        log.debug(&quot;B =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
    public void printC() &#123;
        log.debug(&quot;C =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
&#125;</code></pre>
<p>情况四：两个线程的方法锁住是各自的实例对象，不存在互斥，并且睡眠会让出CPU执行权。</p>
<p>结果：<u>BA</u></p>
<pre><code class="java">@Slf4j(topic = &quot;LockTest4&quot;)
public class LockDemo4 &#123;
    public static void main(String[] args) &#123;
        Lock4 lock1 = new Lock4();
        Lock4 lock2 = new Lock4();
        new Thread(lock1::printA, &quot;A&quot;).start();
        new Thread(lock2::printB, &quot;B&quot;).start();
    &#125;
&#125;
@Slf4j(topic = &quot;Lock4&quot;)
class Lock4 &#123;
    @SneakyThrows
    public synchronized void printA() &#123;
        TimeUnit.SECONDS.sleep(1); 
        log.debug(&quot;A =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
    public synchronized void printB() &#123;
        log.debug(&quot;B =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
&#125;</code></pre>
<p>情况5：<code>static synchronized</code>方法锁住的是类对象，<code>synchronized</code>方法锁住的是实例对象。两线程锁住的对象不同，不存在互斥。</p>
<p>结果：<u>BA</u></p>
<pre><code class="java">@Slf4j(topic = &quot;LockTest5&quot;)
public class LockDemo5 &#123;
    public static void main(String[] args) &#123;
        Lock5 lock5 = new Lock5();
        new Thread(Lock5::printA, &quot;A&quot;).start();
        new Thread(lock5::printB, &quot;B&quot;).start();
    &#125;
&#125;
@Slf4j(topic = &quot;Lock5&quot;)
class Lock5 &#123;
    @SneakyThrows
    public static synchronized void printA() &#123;
        TimeUnit.SECONDS.sleep(1);
        log.debug(&quot;A =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
    public synchronized void printB() &#123;
        log.debug(&quot;B =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
&#125;</code></pre>
<p>情况六：<code>synchronized</code>方法锁住的是类对象，两线程使用同一个锁，谁先获取谁先执行。</p>
<p>结果：<u>AB</u></p>
<pre><code class="java">@Slf4j(topic = &quot;LockTest6&quot;)
public class LockDemo6 &#123;
    public static void main(String[] args) &#123;
        new Thread(Lock6::printA, &quot;A&quot;).start();
        new Thread(Lock6::printB, &quot;B&quot;).start();
    &#125;
&#125;
@Slf4j(topic = &quot;Lock6&quot;)
class Lock6 &#123;
    @SneakyThrows
    public static synchronized void printA() &#123;
        TimeUnit.SECONDS.sleep(1);
        log.debug(&quot;A =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
    public static synchronized void printB() &#123;
        log.debug(&quot;B =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
&#125;</code></pre>
<p>情况七：两个线程使用的一个是类对象，一个是实例对象，不存在互斥。</p>
<p>结果：<u>BA</u></p>
<pre><code class="java">@Slf4j(topic = &quot;LockTest7&quot;)
public class LockDemo7 &#123;
    public static void main(String[] args) &#123;
        Lock7 lock7 = new Lock7();
        new Thread(Lock7::printA, &quot;A&quot;).start();
        new Thread(lock7::printB, &quot;B&quot;).start();
    &#125;
&#125;
@Slf4j(topic = &quot;Lock7&quot;)
class Lock7 &#123;
    @SneakyThrows
    public static synchronized void printA() &#123;
        TimeUnit.SECONDS.sleep(1);
        log.debug(&quot;A =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
    public synchronized void printB() &#123;
        log.debug(&quot;B =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
&#125;</code></pre>
<p>情况八：两个线程的方法锁住的都是类对象，谁先获取谁先执行。</p>
<p>结果：<u>AB</u></p>
<pre><code class="java">@Slf4j(topic = &quot;LockTest8&quot;)
public class LockDemo8 &#123;
    public static void main(String[] args) &#123;
        new Thread(Lock8::printA, &quot;A&quot;).start();
        new Thread(Lock8::printB, &quot;B&quot;).start();
    &#125;
&#125;
@Slf4j(topic = &quot;Lock8&quot;)
class Lock8 &#123;
    @SneakyThrows
    public static synchronized void printA() &#123;
        TimeUnit.SECONDS.sleep(1);
        log.debug(&quot;A =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
    public static synchronized void printB() &#123;
        log.debug(&quot;B =&gt; [&#123;&#125;]&quot;, System.nanoTime());
    &#125;
&#125;</code></pre>
<h3 id="2-1-4-变量的线程安全"><a href="#2-1-4-变量的线程安全" class="headerlink" title="2.1.4  变量的线程安全"></a>2.1.4  变量的线程安全</h3><blockquote>
<p>成员变量和静态变量</p>
</blockquote>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了：<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<blockquote>
<p>局部变量</p>
</blockquote>
<ul>
<li>局部变量是线程安全的</li>
<li>局部变量的引用未必是线程安全的<ul>
<li>如果该对象没有逃离方法的作用范围，它是线程安全的</li>
<li>如果该对象逃离了方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<blockquote>
<p>成员变量案例分析</p>
</blockquote>
<p>有如下类：</p>
<pre><code class="java">class UnsafeOperation &#123;
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();

    public void method1(int loopNumber) &#123;
        for (int i = 0; i &lt; loopNumber; i++) &#123;
            // &#123; 临界区，会产生竞态条件
                method2();
                method3();
            // &#125; 临界区
        &#125;
    &#125;

    private void method2() &#123; list.add(&quot;1&quot;); &#125;

    private void method3() &#123; list.remove(0); &#125;
&#125;</code></pre>
<p>执行如下代码则会出现线程安全问题：</p>
<pre><code class="java">@Slf4j(topic = &quot;UnsafeArrayList&quot;)
public class UnsafeArrayListDemo &#123;
    static final int THREAD_NUMBER = 2;
    static final int LOOP_NUMBER = 200;

    public static void main(String[] args) &#123;
        UnsafeOperation operation = new UnsafeOperation();
        for (int i = 0; i &lt; THREAD_NUMBER; i++) &#123;
            new Thread(() -&gt; operation.method1(LOOP_NUMBER), &quot;Thread&quot; + (i + 1)).start();
        &#125;
    &#125;
&#125;</code></pre>
<p>分析：</p>
<ul>
<li>两个线程中的<code>method2</code>引用的都是同一个对象中的list成员变量。</li>
<li><code>method3</code>和<code>method2</code>分析相同。</li>
</ul>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210407220707659.png" class="" title="image-20210407220707659">

<p>将原类中的成员变量修改为局部变量则不会有线程安全问题：</p>
<pre><code class="java">class SafeOperation &#123;

    public void method1(int loopNumber) &#123;
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; loopNumber; i++) &#123;
            method2(list);
            method3(list);
        &#125;
    &#125;

    private void method2(ArrayList&lt;String&gt; list) &#123; list.add(&quot;1&quot;); &#125;

    private void method3(ArrayList&lt;String&gt; list) &#123; list.remove(0); &#125;
&#125;</code></pre>
<p>分析：</p>
<ul>
<li><code>list</code>是局部变量，每个线程调用时会创建其不同实例，没有共享。</li>
<li><code>method2</code>的参数是从<code>method1</code>中传递过来的，与<code>method1</code>中引用同一个对象。</li>
<li><code>method3</code>的参数分析与<code>method2</code>相同。</li>
</ul>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210407221447318.png" class="" title="image-20210407221447318">



<blockquote>
<p>private或final的重要性</p>
</blockquote>
<p>在上述的<code>SafeOperation</code>中，如果把<code>method2</code>和<code>method3</code>的方法修改为<code>public</code>会不会导致线程安全问题？</p>
<p>情况一：有其他线程调用<code>method2</code>和<code>method3</code>。</p>
<p>结果：不会导致线程安全问题，因为一个线程调用<code>method1</code>中的局部变量<code>list</code>与其他线程传给<code>method2</code>和<code>method3</code>的参数不同。</p>
<p>情况二：为<code>SafeOperation</code>添加子类，子类覆盖<code>method3</code>方法。</p>
<pre><code class="java">class SubSafeOperation extends SafeOperation&#123;
    @Override
    public void method3(ArrayList&lt;String&gt; list) &#123;
        new Thread(() -&gt; list.remove(0)).start();
    &#125;
&#125;</code></pre>
<p>结果：由于<code>method3</code>的访问权限为<code>public</code>，此时子类重写父类的方法，子类和父类共享<code>list</code>对象，在子类中新开线程来操作<code>list</code>对象，此时就会出现线程安全问题。</p>
<p>所以不想子类重写父类的方法的，需要将父类中的方法设置为<code>private</code>或者<code>final</code>，这便是开闭原则中的【闭】。</p>
<blockquote>
<p>4.5 常见线程安全类</p>
</blockquote>
<ul>
<li>String</li>
<li>Integer</li>
<li>StringBuffer</li>
<li>Random</li>
<li>Vector</li>
<li>HashTable</li>
<li>ConcurrentMap</li>
<li>java.util.concurrent</li>
</ul>
<p>它们的每个方法是原子的，但是它们多个方法的组合不是原子的。</p>
<h3 id="2-1-5-习题"><a href="#2-1-5-习题" class="headerlink" title="2.1.5 习题"></a>2.1.5 习题</h3><blockquote>
<p>卖票</p>
</blockquote>
<pre><code class="java">@Slf4j(topic = &quot;ExerciseSell&quot;)
public class ExerciseSellDemo &#123;
    // Random为线程安全
    static Random random = new Random();

    // 随机数1~5
    public static int randomAmount() &#123;
        return random.nextInt(5) + 1;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        // 售票窗口，总共1000张票
        TicketWindow window = new TicketWindow(1000);
        // 线程集合，模拟多人买票
        List&lt;Thread&gt; threadList = new ArrayList&lt;&gt;();
        // 卖出的票数统计，Vector线程安全
        List&lt;Integer&gt; amountList = new Vector&lt;&gt;();
        // 模拟1000个人买票
        for (int i = 0; i &lt; 1000; i++) &#123;
            Thread thread = new Thread(() -&gt; &#123;
                // 买票
                int amount = window.sell(randomAmount());
                // 睡眠
                try &#123;
                    Thread.sleep(randomAmount());
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                // 统计买票数
                amountList.add(amount);
            &#125;);
            threadList.add(thread);
            thread.start();
        &#125;
        for (Thread thread : threadList) &#123;
            thread.join();
        &#125;
        // 查看余票数量和售票数量之和是否为1000
        log.debug(&quot;余票 =&gt; [&#123;&#125;]&quot;, window.getCount());
        log.debug(&quot;售票 =&gt; [&#123;&#125;]&quot;, amountList.stream().mapToInt(i -&gt; i).sum());
    &#125;
&#125;

/**
 * 售票窗口
 */
class TicketWindow &#123;
    // 票总数
    private int count;

    public TicketWindow(int count) &#123;
        this.count = count;
    &#125;

    // 获取余票数量
    public int getCount() &#123;
        return count;
    &#125;

    // 售票
    public int sell(int amount) &#123;
        if (this.count &gt;= amount) &#123;
            this.count -= amount;
            return amount;
        &#125; else &#123;
            return 0;
        &#125;
    &#125;
&#125;</code></pre>
<p>为了测出异常结果，使用windows测试脚本：</p>
<pre><code class="powershell">for /L %n in (1,1,10) do java -cp &quot;.;C:\Java\maven\localRepository\org\projectlombok\lombok\1.18.12\lombok-1.18.12.jar;C:\Java\maven\localRepository\ch\qos\logback\logback-classic\1.1.2\logback-classic-1.1.2.jar;C:\Java\maven\localRepository\ch\qos\logback\logback-core\1.1.2\logback-core-1.1.2.jar;C:\Java\maven\localRepository\org\slf4j\slf4j-api\1.7.6\slf4j-api-1.7.6.jar&quot; top.parak.safe.ExerciseSellDemo</code></pre>
<p>多次测试，终于发现错误结果：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210408140200022.png" class="" title="image-20210408140200022">

<p>分析原因，就在于临界区<code>TicketWindow</code>的<code>sell()</code>方法，多个线程对类的成员变量<code>count</code>进行写操作，而这个方法并未受到保护，于是出现线程安全问题。只需要在方法头上标识<code>synchronized</code>即可，锁住实例对象，则线程安全。</p>
<blockquote>
<p>转账</p>
</blockquote>
<pre><code class="java">@Slf4j(topic = &quot;ExerciseTransfer&quot;)
public class ExerciseTransferDemo &#123;
    // Random为线程安全
    static Random random = new Random();

    // 随机数1~100
    public static int randomAmount() &#123;
        return random.nextInt(100) + 1;
    &#125;

    public static void main(String[] args) throws InterruptedException &#123;
        // 模拟两个账户
        Account k1 = new Account(1000);
        Account k2 = new Account(1000);
        // 互相转账1000次
        Thread t1 = new Thread(() -&gt; &#123;
           for (int i = 0; i &lt; 1000; i++) &#123;
               k1.transfer(k2, randomAmount());
           &#125;
        &#125;, &quot;t1&quot;);
        Thread t2 = new Thread(() -&gt; &#123;
            for (int i = 0; i &lt; 1000; i++) &#123;
                k2.transfer(k1, randomAmount());
            &#125;
        &#125;, &quot;t2&quot;);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        // 查看转账2000次后的余额
        log.debug(&quot;k1 =&gt; [&#123;&#125;]&quot;, k1.getMoney());
        log.debug(&quot;k2 =&gt; [&#123;&#125;]&quot;, k2.getMoney());
    &#125;
&#125;

/**
 * 账户
 */
class Account &#123;
    private int money;

    public Account(int money) &#123;
        this.money = money;
    &#125;

    public int getMoney() &#123;
        return money;
    &#125;

    public void setMoney(int money) &#123;
        this.money = money;
    &#125;

    public void transfer(Account target, int amount) &#123;
        if (this.money &gt;= amount) &#123;
            this.setMoney(this.getMoney() - amount);
            target.setMoney(target.getMoney() + amount);
        &#125;
    &#125;
&#125;</code></pre>
<p>运行一次：</p>
<pre><code>2021-04-08 14:47:33.703 [main] DEBUG ExerciseTransfer - k1 =&gt; [1]
2021-04-08 14:47:33.706 [main] DEBUG ExerciseTransfer - k2 =&gt; [145]</code></pre>
<p>发现<code>k1</code>和<code>k2</code>的余额之和不为2000，所以<code>Account</code>是线程不安全的。</p>
<p>由于转账需要操作自己和对方的<code>money</code>，所以需要直接锁住两个类的<code>money</code>，即锁住<code>Account</code>类。</p>
<p>改进如下：</p>
<pre><code class="java">public void transfer(Account target, int amount) &#123;
    synchronized (Account.class) &#123;
        if (this.money &gt;= amount) &#123;
            this.setMoney(this.getMoney() - amount);
            target.setMoney(target.getMoney() + amount);
        &#125;
    &#125;
&#125;</code></pre>
<h2 id="2-2-第二部分-Monitor"><a href="#2-2-第二部分-Monitor" class="headerlink" title="2.2 第二部分-Monitor"></a>2.2 第二部分-Monitor</h2><h3 id="2-2-1-Monitor"><a href="#2-2-1-Monitor" class="headerlink" title="2.2.1 Monitor"></a>2.2.1 Monitor</h3><blockquote>
<p>Java对象头</p>
</blockquote>
<p>普通对象</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210408123514132.png" class="" title="image-20210408123514132">

<p>数组对象</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210408123633123.png" class="" title="image-20210408123633123">

<p>其中Mark Word结构为：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210408123818981.png" class="" title="image-20210408123818981">

<ul>
<li><code>Normal</code>：一般状态，没有加任何锁，Mark Word前面30位保存的是对象的信息，最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</li>
<li><code>Biased</code>：偏向状态，使用偏向锁，Mark Word前面30位保存当前线程的ID，最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</li>
<li><code>Lightweight</code>：使用轻量级锁，Mark Word前30位保存的是锁记录的指针，最后2位为状态（00）</li>
<li><code>Heavyweight</code>：使用重量级锁，Mark Word前30位保存的是Monitor的地址指针，最后2位状态（10）</li>
</ul>
<blockquote>
<p>Monitor</p>
</blockquote>
<p>Monitor被翻译为监视器或管程</p>
<p>每个Java对象都可以关联一个Monitor对象，如果使用<code>synchronized</code>给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor对象的指针。</p>
<p>Monitor结构如下：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210408204555166.png" class="" title="image-20210408204555166">

<ul>
<li>刚开始<code>Monitor</code>中<code>Owner</code>为null。</li>
<li>当<code>Thread-2</code>执行<code>synchronized(obj)</code>就会将<code>Monitor</code>的所有者<code>Owner</code>置为<code>Thread-2</code>，<code>Monitor</code>中只能有一个<code>Owner</code>。</li>
<li>当<code>Thread-2</code>上锁的过程中，如果<code>Thread-3</code>、<code>Thread-4</code>、<code>Thread-5</code>也来执行<code>synchronized(obj)</code>，就会进入<code>EntryList BLOCKED</code>。</li>
<li><code>Thread-2</code>执行完同步代码块的内容，然后唤醒<code>EntryList</code>中等待的线程来竞争锁，竞争的是非公平的。</li>
<li>图中的<code>WaitSet</code>中的<code>Thread-0</code>、<code>Thread-1</code>是之前获得过锁，但条件不满足进入<code>WAITING</code>状态的线程。</li>
</ul>
<p>注意：</p>
<ul>
<li>synchronized必须是进入同一个对象的Monitor才有上述的效果。</li>
<li>不加synchronized的对象不会关联监视器，不遵从以上规则。</li>
</ul>
<h3 id="2-2-2-synchronized原理"><a href="#2-2-2-synchronized原理" class="headerlink" title="2.2.2 synchronized原理"></a>2.2.2 synchronized原理</h3><p>Demo：</p>
<pre><code class="java">static final Object lock = new Object();
static int counter = 0;

public static void main(String[] args) &#123;
    synchronized (lock) &#123;
        counter++;
    &#125;
&#125;</code></pre>
<p>字节码如下：</p>
<pre><code class="java"> public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=3, args_size=1
         0: getstatic     #2         // 从类中获取静态变量lock (synchronized开始)
         3: dup                      // 复制操作数栈的栈顶数值
         4: astore_1                 // 将复制的引用插入到局部变量表索引为1的位置
         5: monitorenter             // 进入lock对象的MarkWord的monitor
         6: getstatic     #3         // 从类中获取静态变量i
         9: iconst_1                 // 将i放入常量池
        10: iadd                     // 让i自增
        11: putstatic     #3         // 将类中的静态变量i值设置为新值
        14: aload_1                  // 导出局部变量表中索引为1的位置的对象，即lock引用
        15: monitorexit              // 退出lock对象的MarkWord的monitor，唤醒EntryList
        16: goto          24         // 直接goto24的return 
        19: astore_2                 // 将异常对象插入到局部变量表索引为2的位置
        20: aload_1                  // 加载局部变量表中索引为1的位置的对象，即lock引用
        21: monitorexit              // 退出lock对象的MarkWord的monitor，唤醒EntryList
        22: aload_2                  // 加载局部变量表中索引为2的位置的对象，即异常
        23: athrow                   // throw Exception
        24: return
      Exception table:
         from    to  target type
             6    16    19   any     // 同步代码块6-16，共享一个异常
            19    22    19   any     // 同步代码块19-22，共享一个异常</code></pre>
<h3 id="2-2-3-轻量级锁"><a href="#2-2-3-轻量级锁" class="headerlink" title="2.2.3 轻量级锁"></a>2.2.3 轻量级锁</h3><p>使用场景：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。</p>
<p>轻量级锁对使用者是透明的，即语法仍然是<code>synchronized</code>。</p>
<p>假设有两个方法同步块，利用同一个对象加锁：</p>
<pre><code class="java">static final Object obj = new Object();
public static vod method1() &#123;
    synchronized (obj) &#123;
        // 同步块A
        method2();
    &#125;
&#125;

public static void method2() &#123;
    synchronized (obj) &#123;
        // 同步块B
    &#125;
&#125;</code></pre>
<p>加锁流程：</p>
<ul>
<li><p>栈帧中创建锁记录（Lock Record）对象：每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的Mark Word</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409150238190.png" class="" title="image-20210409150238190">
</li>
<li><p>让锁记录中Object reference指向锁对象，并尝试用CAS替换Object的Mark Word，将Mark Word的值存入锁记录</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409150651052.png" class="" title="image-20210409150651052">
</li>
<li><p>如果CAS替换成功，对象头中存储了锁记录地址和状态，表示由该线程给对象加锁，这时图示如下：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409155409161.png" class="" title="image-20210409155409161">
</li>
<li><p>如果CAS替换失败，有两种情况：</p>
<ul>
<li>如果是其他线程已经持有了该Object的轻量级锁，这时表明有竞争，进入锁膨胀过程</li>
<li>如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数。在上面的代码中</li>
</ul>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409155939040.png" class="" title="image-20210409155939040">
</li>
<li><p>当退出synchronized代码块（解锁时）如果有取值位null的锁记录，表示有重入，这是重置锁记录，表示重入计数减一</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409160448791.png" class="" title="image-20210409160448791">
</li>
<li><p>当退出synchronized代码块（解锁时）锁记录的值不为null，这时使用CAS将Mark Word的值恢复给对象头。</p>
<ul>
<li>成功，则解锁成功</li>
<li>失败，说明轻量级锁进行了锁膨胀或已经升级位重量级锁，进入重量级锁解锁流程</li>
</ul>
</li>
</ul>
<h3 id="2-2-4-重量级锁"><a href="#2-2-4-重量级锁" class="headerlink" title="2.2.4 重量级锁"></a>2.2.4 重量级锁</h3><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁（有竞争），这是需要进行锁膨胀，将轻量级锁变为重量级锁。</p>
<pre><code class="java">static Object obj = new Object();
public static void method1() &#123;
    synchronized (obj) &#123;
        // 同步块
    &#125;
&#125;</code></pre>
<ul>
<li><p>当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409161426089.png" class="" title="image-20210409161426089">
</li>
<li><p>这时Thread-1加轻量级锁失败，进入锁膨胀流程（因为Thread-1线程加轻量级锁失败，轻量级锁没有阻塞队列的概念，所以此时就要为对象申请Monitor锁（重量级锁），让Object指向重量级锁，然后Thread-1自己进入了Monitor的EntryList变成BLOCKED状态。）</p>
<ul>
<li>即为Object对象申请Monitor锁，让Object指向重量级锁地址</li>
<li>然后自己进入Monitor的EntryList BLOCKED</li>
</ul>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409163035688.png" class="" title="image-20210409163035688">
</li>
<li><p>当Thread-0退出同步块解锁时，使用CAS将Mark Word的值恢复给对象头，肯定恢复失败，因为对象的对象头中存储的是重量级锁的地址。这时会进入重量级解锁流程，即按照Monitor地址找到Monitor对象，设置Owner为null，唤醒EntryList中BLOCKED线程Thread-1。</p>
</li>
</ul>
<blockquote>
<p>自旋锁优化</p>
</blockquote>
<p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。</p>
<p>在Java 6之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。</p>
<p>Java 7之后不能控制是否开启自旋功能。</p>
<h3 id="2-2-5-偏向锁"><a href="#2-2-5-偏向锁" class="headerlink" title="2.2.5 偏向锁"></a>2.2.5 偏向锁</h3><p>轻量级锁在没有竞争时，每次重入仍然需要执行CAS操作。</p>
<p>Java 6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就表示没有竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有。</p>
<p>例如：</p>
<pre><code class="java">static final Object obj = new Object();
public static void m1() &#123;
    synchronized (obj) &#123;
        // 同步块A
        m2();
    &#125;
&#125;
public static void m2() &#123;
    synchronized (obj) &#123;
        // 同步块B
        m3();
    &#125;
&#125;
public static void m3() &#123;
    synchronized (obj) &#123;
        // 同步块C
    &#125;
&#125;</code></pre>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409171350303.png" class="" title="image-20210409171350303">



<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210409171429240.png" class="" title="image-20210409171429240">



<blockquote>
<p>偏向状态</p>
</blockquote>
<p>一个对象创建时：</p>
<ul>
<li><p>如果开启了偏向锁（默认开启），那么对象创建后，Mark Word值为0x05即最后三位为101，这时它的thread_id、epoch、age都为0。</p>
</li>
<li><p>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加VM参数</p>
<p><code>-XX:BiasedLockingStartupDelay=0</code>来禁用延迟。</p>
</li>
<li><p>如果没有开启偏向锁，那么对象创建后，Mark Word值为0x01即最后3位为001，这时它的hashcode、age都为0，第一次用到hashcode时才会赋值。</p>
</li>
<li><p>JVM禁用偏向锁：<code>-XX:-UseBiasedLocking</code></p>
</li>
</ul>
<p>代码如下：</p>
<pre><code class="java">@Slf4j(topic = &quot;Biased&quot;)
public class BiasedDemo &#123;

    public static void main(String[] args) throws InterruptedException &#123;
        Biased biased = new Biased();
        log.debug(&quot;Before Biased Lock&quot;);
        log.debug(ClassLayout.parseInstance(biased.toPrintable());
        TimeUnit.SECONDS.sleep(3);
        log.debug(&quot;After Biased Lock&quot;);
        log.debug(ClassLayout.parseInstance(biased).toPrintable());
    &#125;
&#125;

class Biased &#123;

&#125;</code></pre>
<p>运行结果：</p>
<pre><code>2021-04-09 19:14:30.487 [main] DEBUG Biased - Before Biased Lock
2021-04-09 19:14:32.083 [main] DEBUG Biased - top.parak.safe.Biased object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           70 b8 01 f8 (01110000 10111000 00000001 11111000) (-134104976)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total

2021-04-09 19:14:35.096 [main] DEBUG Biased - After Biased Lock
2021-04-09 19:14:35.097 [main] DEBUG Biased - top.parak.safe.Biased object internals:
 OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)
      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
      8     4        (object header)                           70 b8 01 f8 (01110000 10111000 00000001 11111000) (-134104976)
     12     4        (loss due to the next object alignment)
Instance size: 16 bytes
Space losses: 0 bytes internal + 4 bytes external = 4 bytes total</code></pre>
<p>因为偏向锁有延迟，所以在第二次创建对象前延时5S。</p>
<p>第一次创建对象时，可以看到，对象头的第一个字节为<code>00000001</code>，即没有加锁，</p>
<p>第二次创建对象时，可以看到，对象头的第一个字节为<code>00000101</code>，即加偏向锁。</p>
<blockquote>
<p>工具类</p>
</blockquote>
<p>这个工具类主要是将繁琐的<code>ClassLayout.parseInstance(obj).toPrintable()</code>的详细信息输出做一步简化，只输出关于Mark Word锁那一行的部分：</p>
<pre><code class="java">import org.openjdk.jol.info.ClassLayout;

/**
 * @author KHighness
 * @since 2021-04-09
 */

public class ClassLayoutUtil &#123;

    private final static int FIRST_LINE_START = 185;
    private final static int LINE_LENGTH = 53;

    public static String printSimple(ClassLayout instance) &#123;
        return instance.toPrintable().substring(FIRST_LINE_START, FIRST_LINE_START + LINE_LENGTH);
    &#125;

&#125;</code></pre>
<blockquote>
<p>撤销偏向锁-hashcode方法</p>
</blockquote>
<p>使用偏向锁则进入Biased状态，使用<code>hashcode()</code>方法则进入Normal状态。</p>
<p>Normal状态下：Mark Word(32) = hashcode(25) + age(4) + biased(1) + 01(2)</p>
<p>Biased状态下：Mark Word(32) = thread_id(23) + epoch(2) + biased(1) + 01(2) </p>
<pre><code class="java">@Slf4j(topic = &quot;HashcodeBiased&quot;)
public class HashcodeBiasedDemo &#123;
    /**
     * -XX:BiasedLockingStartupDelay=0  禁用偏向锁延迟
     */
    public static void main(String[] args) &#123;
        HashcodeBiased biased = new HashcodeBiased();
        log.debug(ClassLayoutUtil.printSimple(ClassLayout.parseInstance(biased))); // 偏向锁
        log.debug(String.valueOf(biased.hashCode()));
        log.debug(ClassLayoutUtil.printSimple(ClassLayout.parseInstance(biased))); // 无锁
    &#125;
&#125;

class HashcodeBiased &#123;

&#125;</code></pre>
<p>输出结果：</p>
<pre><code>2021-04-09 23:03:39.378 [main] DEBUG HashcodeBiased - 00 00 00 (00000101 00000000 00000000 00000000) (5)
2021-04-09 23:03:39.380 [main] DEBUG HashcodeBiased - 1268650975
2021-04-09 23:03:39.381 [main] DEBUG HashcodeBiased - df 13 9e (00000001 11011111 00010011 10011110) (-1642</code></pre>
<p>可以看到第一行为<code>101</code>，第三行为<code>001</code>，说明对象的偏向锁被撤销。</p>
<blockquote>
<p>撤销偏向锁-其他线程使用对象</p>
</blockquote>
<p>当有其他线程使用偏向锁对象时，会将偏向锁升级为轻量级锁。</p>
<pre><code class="java">@Slf4j(topic = &quot;OtherThreadBiased&quot;)
public class OtherThreadBiasedDemo &#123;
    /**
     * -XX:BiasedLockingStartupDelay=0  禁用偏向锁延迟
     */
    public static void main(String[] args) &#123;
        OtherThreadBiased biased = new OtherThreadBiased();
        new Thread(() -&gt; &#123;
            log.debug(ClassLayoutUtil.printSimple(ClassLayout.parseInstance(biased)));     //  偏向锁
            synchronized (biased) &#123;
                log.debug(ClassLayoutUtil.printSimple(ClassLayout.parseInstance(biased))); // 偏向锁
            &#125;
            log.debug(ClassLayoutUtil.printSimple(ClassLayout.parseInstance(biased)));     // 偏向锁
            synchronized (OtherThreadBiased.class) &#123;
                OtherThreadBiased.class.notify();
            &#125;
        &#125;, &quot;t1&quot;).start();
        new Thread(() -&gt; &#123;
            synchronized (OtherThreadBiased.class) &#123;
                try &#123;
                    OtherThreadBiased.class.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            log.debug(ClassLayoutUtil.printSimple(ClassLayout.parseInstance(biased)));      // 偏向锁
            synchronized (biased) &#123;
                log.debug(ClassLayoutUtil.printSimple(ClassLayout.parseInstance(biased)));  // 偏向锁
            &#125;
            log.debug(ClassLayoutUtil.printSimple(ClassLayout.parseInstance(biased)));      // 无锁
        &#125;, &quot;t2&quot;).start();
    &#125;
&#125;

class OtherThreadBiased &#123;

&#125;</code></pre>
<p>输出结果：</p>
<pre><code>2021-04-09 23:20:08.722 [t1] DEBUG OtherThreadBiased - 05 00 00 00 (00000101 00000000 00000000 00000000) (5)
2021-04-09 23:20:08.724 [t1] DEBUG OtherThreadBiased - 05 80 71 20 (00000101 10000000 01110001 00100000) (54
2021-04-09 23:20:08.725 [t1] DEBUG OtherThreadBiased - 05 80 71 20 (00000101 10000000 01110001 00100000) (54
2021-04-09 23:20:08.726 [t2] DEBUG OtherThreadBiased - 05 80 71 20 (00000101 10000000 01110001 00100000) (54
2021-04-09 23:20:08.727 [t2] DEBUG OtherThreadBiased - a0 f2 c0 20 (10100000 11110010 11000000 00100000) (54
2021-04-09 23:20:08.728 [t2] DEBUG OtherThreadBiased - 01 00 00 00 (00000001 00000000 00000000 00000000) (1)</code></pre>
<blockquote>
<p>撤销偏向锁-调用wait/notify</p>
</blockquote>
<p>因为wait/notify只有重量级锁才有。</p>
<blockquote>
<p>批量重定向</p>
</blockquote>
<p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的Thread ID。</p>
<p>当撤销偏向锁阈值超过20次后，JVM会这样觉得，我是不是偏向错了呢，于是会再给这些对象加锁时重新偏向至加锁线程。</p>
<blockquote>
<p>批量撤销</p>
</blockquote>
<p>当撤销偏向锁阈值超过40次后，JVM会这样觉得，自己确实偏向错了，根本就不该偏向，于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的。</p>
<blockquote>
<p>锁消除</p>
</blockquote>
<ul>
<li>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</li>
<li>在动态编译同步块的时候，JIT编译器可以借助逃逸分析来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。</li>
<li>如果没有，那么JIT编译器在编译这个同步块的时候就会取消对这部分代码的同步。</li>
</ul>
<h2 id="2-3-第三部分-模式"><a href="#2-3-第三部分-模式" class="headerlink" title="2.3 第三部分-模式"></a>2.3 第三部分-模式</h2><h3 id="2-3-1-wait-notify"><a href="#2-3-1-wait-notify" class="headerlink" title="2.3.1 wait notify"></a>2.3.1 wait notify</h3><blockquote>
<p>wait/notify原理</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210410164622176.png" class="" title="image-20210410164622176">



<ul>
<li><code>Owner</code>线程发现条件不满足，调用<code>wait</code>方法，即可进入<code>WaitSet</code>变成<code>WAITING</code>状态</li>
<li><code>BLOCKED</code>和<code>WAITING</code>的线程都处于阻塞状态，不占用CPU时间片</li>
<li><code>BLOCKED</code>线程会在<code>Owner</code>线程加锁时唤醒</li>
<li><code>WAITING</code>线程会在<code>Owner</code>线程调用<code>notify</code>或<code>notifyAll</code>时唤醒，但唤醒后并不意味着立刻获得锁，仍需进入<code>EntryList</code>重新竞争。</li>
</ul>
<blockquote>
<p>API介绍</p>
</blockquote>
<ul>
<li><code>obj.wait()</code> 让进入object监视器的线程到<code>WaitSet</code>等待</li>
<li><code>obj.notify()</code> 在object上正在<code>WaitSet</code>等待的线程中挑一个唤醒</li>
<li><code>obj.notifyAll()</code> 让object上正在<code>WaitSet</code>等待的线程全部唤醒</li>
</ul>
<p>它们都是线程之间进行协作的手段，都属于object对象的方法，必须获得此对象的锁，才能调用这几个方法。</p>
<p>案例：</p>
<pre><code class="java">@Slf4j(topic = &quot;WaitNotify&quot;)
public class WaitNotifyDemo &#123;
    final static Object obj = new Object();

    public static void main(String[] args) throws InterruptedException &#123;
        new Thread(() -&gt; &#123;
            synchronized (obj) &#123;
                log.debug(&quot;执行...&quot;);
                try &#123;
                    obj.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                log.debug(&quot;其它代码...&quot;);
            &#125;
        &#125;, &quot;t1&quot;).start();
        new Thread(() -&gt; &#123;
            synchronized (obj) &#123;
                log.debug(&quot;执行...&quot;);
                try &#123;
                    obj.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                log.debug(&quot;其它代码...&quot;);
            &#125;
        &#125;, &quot;t2&quot;).start();
        TimeUnit.SECONDS.sleep(1);
        log.debug(&quot;唤醒obj上其他线程&quot;);
        synchronized (obj) &#123;
            obj.notify();     // (1)
            obj.notifyAll();  // (2)
        &#125;
    &#125;
&#125;
</code></pre>
<p>注释（2），即调用<code>obj.notify()</code>：</p>
<pre><code>2021-04-10 19:53:10.709 [t1] DEBUG WaitNotify - 执行...
2021-04-10 19:53:10.711 [t2] DEBUG WaitNotify - 执行...
2021-04-10 19:53:11.717 [main] DEBUG WaitNotify - 唤醒obj上其他线程
2021-04-10 19:53:11.717 [t1] DEBUG WaitNotify - 其它代码...</code></pre>
<p>注释（1），即调用<code>obj.notifyAll()</code>：</p>
<pre><code>2021-04-10 19:54:13.288 [t1] DEBUG WaitNotify - 执行...
2021-04-10 19:54:13.289 [t2] DEBUG WaitNotify - 执行...
2021-04-10 19:54:14.296 [main] DEBUG WaitNotify - 唤醒obj上其他线程
2021-04-10 19:54:14.296 [t2] DEBUG WaitNotify - 其它代码...
2021-04-10 19:54:14.296 [t1] DEBUG WaitNotify - 其它代码...</code></pre>
<p>可以看到<code>notify</code>只能唤醒一个线程，而<code>notifyAll</code>唤醒了所有线程。</p>
<blockquote>
<p>sleep与wait</p>
</blockquote>
<p><code>Thread#sleep()</code>与<code>Object#wait()</code></p>
<p>相同点：</p>
<ul>
<li>线程进入了<code>sleep</code>和<code>wait</code>都进入<code>TIMED_WAITING</code>状态。</li>
</ul>
<p>不同点：</p>
<ul>
<li><code>sleep</code>不需要强制和<code>synchronized</code>配合使用，但是<code>wait</code>一定要和<code>synchronized</code>配合使用</li>
<li><code>sleep</code>在睡眠的同时不会释放对象锁，但是<code>wait</code>在等待时会释放对象锁。</li>
</ul>
<p>案例：</p>
<pre><code class="java">@Slf4j(topic = &quot;SleepAndWait&quot;)
public class SleepAndWaitDemo &#123;

    private static final Object lock = new Object();

    public static void main(String[] args) throws InterruptedException &#123;
        new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                log.debug(&quot;获得锁&quot;);
                try &#123;
                    Thread.sleep(20_000);  // (1)
                    lock.wait(20_000);   // (2)
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;, &quot;t1&quot;).start();
        TimeUnit.SECONDS.sleep(1);
        synchronized (lock) &#123;
            log.debug(&quot;获得锁&quot;);
        &#125;
    &#125;
&#125;</code></pre>
<p>注释（2），即调用<code>Thread.sleep()</code>：</p>
<pre><code>2021-04-10 20:23:40.382 [t1] DEBUG SleepAndWait - 获得锁
2021-04-10 20:24:00.386 [main] DEBUG SleepAndWait - 获得锁</code></pre>
<p>注释（1），即调用<code>obj.wait()</code>：</p>
<pre><code class="java">2021-04-10 20:26:40.335 [t1] DEBUG SleepAndWait - 获得锁
2021-04-10 20:26:41.335 [main] DEBUG SleepAndWait - 获得锁</code></pre>
<p>可以看到sleep情况下主线程20S后才拿到锁，而wait情况下主线程立即可以拿到锁。</p>
<blockquote>
<p>wait/notify正确姿势</p>
</blockquote>
<pre><code class="java">// 一个线程
synchronized (lock) &#123;
    while (condition) &#123; // 防止虚假唤醒
        lock.wait();
    &#125;
    // do something
&#125;

// 另一个线程
synchronized (lock) &#123;
    lock.notifyAll();
&#125;</code></pre>
<h3 id="2-3-2-同步模式之保护性暂停"><a href="#2-3-2-同步模式之保护性暂停" class="headerlink" title="2.3.2 同步模式之保护性暂停"></a>2.3.2 同步模式之保护性暂停</h3><blockquote>
<p>要点</p>
</blockquote>
<p>Guarded Suspension，用在一个线程等待另一个线程的执行结果。</p>
<ul>
<li>有一个结果需要从一个线程传递到另一个线程，让他们关联到一个Guarded Object</li>
<li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者）</li>
<li>JDK中，join的实现、future的实现，采用的就是此模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210411112747728.png" class="" title="image-20210411112747728">



<blockquote>
<p>示例</p>
</blockquote>
<p>一个线程需要等待另一个线程的下载结果，并且设置超时时间。</p>
<pre><code class="java">@Slf4j(topic = &quot;GuardedObject&quot;)
public class GuardedObjectDemo &#123;

    public static void main(String[] args) &#123;
        GuardedObject guardedObject = new GuardedObject();
        // 获取结果线程
        new Thread(() -&gt; &#123;
            log.debug(&quot;等待结果&quot;);
            List&lt;String&gt; response = (List&lt;String&gt;) guardedObject.getResponse(5000);
            if (response != null) &#123;
                log.debug(&quot;结果大小：&#123;&#125;&quot;, response.size());
            &#125; else &#123;
                log.debug(&quot;下载失败&quot;);
            &#125;
        &#125;, &quot;receive&quot;).start();
        // 下载内容线程
        new Thread(() -&gt; &#123;
            log.debug(&quot;执行下载&quot;);
            List&lt;String&gt; download = ParaKDownloader.download(&quot;https://www.parak.top&quot;);
            guardedObject.setResponse(download);
        &#125;, &quot;download&quot;).start();
    &#125;
&#125;

class GuardedObject &#123;
    // 结果
    private Object response;

    // 获取结果
    public Object getResponse(long timeout) &#123;
        synchronized (this) &#123;
            // 开始时间
            long start = System.currentTimeMillis();
            // 经历时间
            long pass = 0;
            // 没有结果
            while (response == null) &#123;
                // 此轮循环应该等待的时间
                long wait = timeout - pass;
                if (wait &lt;= 0) &#123;
                    break;
                &#125;
                try &#123;
                    this.wait(wait);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                pass = System.currentTimeMillis() - start;
            &#125;
            return response;
        &#125;
    &#125;

    // 产生结果
    public void setResponse(Object response) &#123;
        synchronized (this) &#123;
            this.response = response;
            this.notifyAll();
        &#125;
    &#125;
&#125;

class ParaKDownloader &#123;
    public static List&lt;String&gt; download(String url) &#123;
        HttpURLConnection connection = null;
        List&lt;String&gt; res = new ArrayList&lt;&gt;();
        String line = null;
        try &#123;
            connection = (HttpURLConnection) new URL(url).openConnection();
            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8));
            while ((line = reader.readLine()) != null) &#123;
                res.add(line);
            &#125;
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        return res;
    &#125;
&#125;</code></pre>
<blockquote>
<p>join原理</p>
</blockquote>
<p>看一看<code>Thread#join()</code>的源代码，即是同步模式之保护性暂停的应用。</p>
<pre><code class="java">public final synchronized void join(long millis) throws InterruptedException &#123;
    long base = System.currentTimeMillis();  // 开始时间
    long now = 0;                            // 当前时间
    if (millis &lt; 0) &#123; // 参数校验
        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
    &#125;

    if (millis == 0) &#123; // 一直等待，直到线程结束
        while (isAlive()) &#123;
            wait(0);
        &#125;
    &#125; else &#123;
        while (isAlive()) &#123;
            long delay = millis - now; // 这轮需要等待的时间
            if (delay &lt;= 0) &#123;
                break;
            &#125;
            wait(delay);               // 等待
            now = System.currentTimeMillis() - base; // 经过时间
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>扩展</p>
</blockquote>
<p>如果需要在多个类中间使用<code>GuardedObject</code>对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类。</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210411231829154.png" class="" title="image-20210411231829154">

<p>比如一个小区有一个信箱，每个居民只需要在信箱里根据ID取到自己的信件，而每一封信件都由不同的邮递员送达。</p>
<pre><code class="java">public class MailBoxesDemo &#123;
    public static void main(String[] args) throws InterruptedException &#123;
        for (int i = 0; i &lt; 5; i++) &#123;
            new People().start();
        &#125;
        TimeUnit.SECONDS.sleep(1);
        for (Integer id : MailBoxes.getIds()) &#123;
            new Postman(id, &quot;内容&quot; + id).start();
        &#125;
    &#125;
&#125;

// 居民
@Slf4j(topic = &quot;People&quot;)
class People extends Thread &#123;
    @Override
    public void run() &#123;
        Mail mail = MailBoxes.createMail();
        log.debug(&quot;开始收信: &#123;&#125;&quot;, mail.getId());
        String content = (String) mail.getContent(5000);
        log.debug(&quot;收到信件: &#123;&#125;&quot;,  content);
    &#125;
&#125;

// 邮递员
@Slf4j(topic = &quot;Postman&quot;)
class Postman extends Thread&#123;
    private int id;
    private String content;

    public Postman(int id, String content) &#123;
        this.id = id;
        this.content = content;
    &#125;

    @Override
    public void run() &#123;
        Mail mail = MailBoxes.getMail(id);
        log.debug(&quot;送信 [id=&#123;&#125;, content=&#123;&#125;]&quot;, id, content);
        mail.setContent(content);
    &#125;
&#125;

// 信箱
class MailBoxes &#123;
    private static Map&lt;Integer, Mail&gt; boxes = new Hashtable&lt;&gt;();

    private static int id = 0;

    private static synchronized int generateId() &#123;
        return ++id;
    &#125;

    public static Mail getMail(int id) &#123;
        return boxes.remove(id);
    &#125;

    public static Mail createMail() &#123;
        int id = generateId();
        Mail mail = new Mail(id);
        boxes.put(id, mail);
        return mail;
    &#125;

    public static Set&lt;Integer&gt; getIds() &#123;
        return boxes.keySet();
    &#125;
&#125;

// 信件
class Mail &#123;
    // 信件ID
    private final int id;

    public Mail(int id) &#123;
        this.id = id;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    // 信件内容
    private Object content;

    // 获取内容
    public Object getContent(long timeout) &#123;
        synchronized (this) &#123;
            // 开始时间
            long start = System.currentTimeMillis();
            // 经历时间
            long pass = 0;
            // 没有结果
            while (content == null) &#123;
                // 此轮循环应该等待的时间
                long wait = timeout - pass;
                if (wait &lt;= 0) &#123;
                    break;
                &#125;
                try &#123;
                    this.wait(wait);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                pass = System.currentTimeMillis() - start;
            &#125;
            return content;
        &#125;
    &#125;

    // 设置内容
    public void setContent(Object content) &#123;
        synchronized (this) &#123;
            this.content = content;
            this.notifyAll();
        &#125;
    &#125;
&#125;</code></pre>
<h3 id="2-3-3-异步模式之生产者-消费者"><a href="#2-3-3-异步模式之生产者-消费者" class="headerlink" title="2.3.3 异步模式之生产者/消费者"></a>2.3.3 异步模式之生产者/消费者</h3><blockquote>
<p>要点</p>
</blockquote>
<ul>
<li>消费队列可以平衡生产和消费的资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据</li>
<li>JDK中各种阻塞队列，采用的就是这种模式</li>
</ul>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210411232117401.png" class="" title="image-20210411232117401">



<blockquote>
<p>实现</p>
</blockquote>
<pre><code class="java">public class MessageQueueDemo &#123;
    public static void main(String[] args) &#123;
        MessageQueue queue = new MessageQueue(2);
        // 3个生产者
        for (int i = 0; i &lt; 3; i++) &#123;
            final int id = i + 1;
            new Thread(() -&gt; &#123;
                queue.put(new Message(id, &quot;值&quot; + id));
            &#125;, &quot;生产者&quot; + id).start();
        &#125;
        // 1个消费者
        new Thread(() -&gt; &#123;
            while (true) &#123;
                // 1S消费一个线程
                try &#123;
                    TimeUnit.SECONDS.sleep(1);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                queue.get();
            &#125;
        &#125;, &quot;消费者&quot;).start();
    &#125;
&#125;

// 消息队列类
@Slf4j(topic = &quot;MessageDemo&quot;)
class MessageQueue &#123;
    // 消息队列集合
    private LinkedList&lt;Message&gt; list;
    // 消息队列容量
    private int capacity;

    public MessageQueue(int capacity) &#123;
        this.capacity = capacity;
        this.list = new LinkedList&lt;&gt;();
    &#125;

    // 获取消息
    public Message get() &#123;
        // 检查队列是否为空
        synchronized (list) &#123;
            while (list.isEmpty()) &#123;
                try &#123;
                    log.debug(&quot;队列为空，消费者线程等待&quot;);
                    list.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            // 从队列头部获取消息并返回
            Message message = list.removeFirst();
            log.debug(&quot;消费消息 &lt;= &#123;&#125;&quot;, message.toString());
            list.notifyAll();
            return message;
        &#125;
    &#125;

    // 存入消息
    public void put(Message message) &#123;
        synchronized (list) &#123;
            // 检查队列是否已满
            while (list.size() == capacity) &#123;
                try &#123;
                    log.debug(&quot;队列已满，生产者线程等待&quot;);
                    list.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
            // 将消息加入队列尾部
            list.addLast(message);
            log.debug(&quot;生产消息 =&gt; &#123;&#125;&quot;, message.toString());
            list.notifyAll();
        &#125;
    &#125;
&#125;

// 消息
class Message &#123;
    private int id;
    private Object value;

    public Message(int id, Object value) &#123;
        this.id = id;
        this.value = value;
    &#125;

    public int getId() &#123;
        return id;
    &#125;

    public Object getValue() &#123;
        return value;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;Message[&quot; +
                &quot;id=&quot; + id +
                &quot;, value=&quot; + value +
                &#39;]&#39;;
    &#125;
&#125;</code></pre>
<h3 id="2-3-4-park-unprak"><a href="#2-3-4-park-unprak" class="headerlink" title="2.3.4 park unprak"></a>2.3.4 park unprak</h3><blockquote>
<p>介绍</p>
</blockquote>
<p>它们是<code>LockSupport</code>类中的方法：</p>
<pre><code class="java">// 暂停当前线程
LockSupport.park();
// 恢复线程运行
LockSupport.unpark(Thread thread);</code></pre>
<blockquote>
<p>特点</p>
</blockquote>
<p><code>park &amp; unpark</code> 与<code>wait &amp; notify</code></p>
<ul>
<li><code>wai</code>t、<code>notify</code>和<code>notifyAll</code>必须配合Object Monitor一起使用，而<code>park</code>和<code>unpark</code>不必。</li>
<li><code>park/unpark</code>是以线程为单位类【阻塞】和【唤醒】线程，而<code>notify</code>只能随机唤醒一个等待线程，<code>notifyAll</code>是唤醒所有等待线程，就不那么【精确】。</li>
<li><code>park &amp; unpark</code>可以先<code>unpark</code>，而<code>wait &amp; notify</code>不能先<code>notify</code>。</li>
</ul>
<blockquote>
<p>示例</p>
</blockquote>
<pre><code class="java">@Slf4j(topic = &quot;ParkUnpark&quot;)
public class ParkUnparkDemo &#123;
    public static void main(String[] args) &#123;
        Scanner sc = new Scanner(System.in);
        String str  = null;
        while (!(str = sc.nextLine()).equals(&quot;&quot;)) &#123;
            String[] s = str.split(&quot; &quot;);
            int time1 = Integer.parseInt(s[0]);
            int time2 = Integer.parseInt(s[1]);

            // park
            Thread t1 = new Thread(() -&gt; &#123;
                log.debug(&quot;start...&quot;);
                try &#123;
                    TimeUnit.SECONDS.sleep(time1);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                log.debug(&quot;park...&quot;);
                LockSupport.park();
                log.debug(&quot;continue...&quot;);
            &#125;, &quot;t1&quot;);
            t1.start();
            // unpark
            try &#123;
                TimeUnit.SECONDS.sleep(time2);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            // unpark既可以在park之前调用，也可以在park之后调用
            log.debug(&quot;unpark...&quot;);
            LockSupport.unpark(t1);
        &#125;
    &#125;
&#125;</code></pre>
<p>运行结果：</p>
<pre><code class="powershell">1 2
2021-04-18 20:20:53.213 [t1] DEBUG ParkUnpark - start...
2021-04-18 20:20:54.217 [t1] DEBUG ParkUnpark - park...
2021-04-18 20:20:55.226 [main] DEBUG ParkUnpark - unpark...
2021-04-18 20:20:55.226 [t1] DEBUG ParkUnpark - continue...
2 1
2021-04-18 20:20:57.756 [t1] DEBUG ParkUnpark - start...
2021-04-18 20:20:58.771 [main] DEBUG ParkUnpark - unpark...
2021-04-18 20:20:59.762 [t1] DEBUG ParkUnpark - park...
2021-04-18 20:20:59.762 [t1] DEBUG ParkUnpark - continue...
</code></pre>
<p>第一次输入，<code>time1</code> = 1， <code>time2</code> = 2，于是先执行<code>park</code>，后执行<code>unpark</code>，最终执行了<code>continue</code>；</p>
<p>第一次输入，<code>time1</code> = 2， <code>time2</code> = 1，于是先执行<code>unpark</code>，后执行<code>park</code>，最终也执行了<code>continue</code>。</p>
<p>证明<code>unpark</code>的执行比较随意。</p>
<blockquote>
<p>park/unpark原理</p>
</blockquote>
<p>每个线程都有自己的Parker对象，由三部分组成：<code>_countrer</code>、<code>_cond</code>和<code> _mutex</code>打个比喻。</p>
<ul>
<li>线程就像一个旅人，Parker就像为他随身携带的背包，<code>_cond</code>就好比背包中的帐篷，<code>_counter</code></li>
</ul>
<p>就好比背包中的备用干粮（0为耗尽，1为充足）</p>
<ul>
<li>调用<code>park</code>就是要看需不需要停下来歇息<ul>
<li>如果备用干粮耗尽（<code>_counter</code> = 0），那么钻进帐篷歇息。</li>
<li>如果备用干粮充足（<code>_counter</code> = 1），那么就不需停留，继续前进。</li>
</ul>
</li>
<li>调用<code>unpark</code>，就好比向背包中补充干粮<ul>
<li>如果这时线程还在敞篷，就唤醒让他继续前进。</li>
<li>如果这时线程还在运行，那么下次他调用<code>park</code>时，仅是消耗掉备用干粮，不需停留继续前进。<ul>
<li>因为背包空间有限，多次调用<code>unpark</code>仅会补充一份备用干粮。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>图示</strong></p>
<p>（1）先调用<code>park</code>再调用<code>unpark</code></p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210418212139187.png" class="" title="image-20210418212139187">

<ol>
<li>当前线程调用<code>Unsafe.park()</code>方法</li>
<li>检查<code>_counter</code>，本情况为0，这时，获得<code>_mutex</code>互斥锁</li>
<li>线程进入<code>_cond</code>条件变量阻塞</li>
<li>设置<code>_counter = 0</code></li>
</ol>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210419110033795.png" class="" title="image-20210419110033795">

<ol>
<li>调用<code>Unsafe.unpark(Thread_0)</code>方法，设置<code>_counter</code>为1</li>
<li>唤醒<code>_cond</code>条件变量中的<code>Thread_0</code></li>
<li><code>Thread_0</code>恢复运行</li>
<li>设置<code>_counter</code>为0</li>
</ol>
<p>（2）先调用<code>unpark</code>再调用<code>park</code></p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210419214214099.png" class="" title="image-20210419214214099">

<ol>
<li>调用<code>Unsafe.unpark(Thread)0</code>方法，设置<code>_counter</code>为1</li>
<li>当前线程调用<code>Unsafe.park()</code>方法</li>
<li>检查<code>_counter</code>，本情况为1，这时线程无需阻塞，继续运行</li>
<li>设置<code>_counter</code>为0</li>
</ol>
<h3 id="2-3-5-线程状态转换"><a href="#2-3-5-线程状态转换" class="headerlink" title="2.3.5 线程状态转换"></a>2.3.5 线程状态转换</h3><img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210419222926434.png" class="" title="image-20210419222926434">

<p>假设有线程t:</p>
<p>（1）情况1：<code>NEW</code> ==&gt; <code>RUNNABLE</code></p>
<p>当调用<code>t.start()</code>方法时，由<code>NEW</code> =&gt; <code>RUNNABLE</code></p>
<p>（2）情况2：<code>RUNNABLE</code> &lt;==&gt; <code>WAITING</code></p>
<p><code>t</code>线程用<code>synchronized(obj)</code>获取了对象锁后</p>
<ul>
<li><p>调用<code>obj.wait()</code>方法时，t线程从<code>RUNNABLE</code> ==&gt; <code>WAITING</code></p>
</li>
<li><p>调用<code>obj.notify()</code>、<code>obj.notifyAll()</code>、<code>t.interrupt()</code>时</p>
<ul>
<li>竞争锁成功，t线程从<code>WAITING</code> ==&gt; <code>RUNNABLE</code></li>
<li>竞争锁失败，t线程从<code>WAITING</code> ==&gt; <code>BLOCKED</code></li>
</ul>
</li>
</ul>
<p>（3）情况3：<code>RUNNABLE</code> &lt;==&gt; <code> WAITING</code></p>
<ul>
<li>当前线程调用<code>t.join()</code>方法时，当前线程从<code>RUNNABLE</code> ==&gt; <code>WAITING</code><ul>
<li>注意是当前线程在<code>t</code>线程对象的监视器上等待 </li>
</ul>
</li>
<li><code>t</code>线程运行结束，或调用了当前线程的<code>interrupt()</code>时，当前线程从<code>WAITING</code> ==&gt; <code>RUNNABLE</code></li>
</ul>
<p>（4）情况4：<code>RUNNABLE</code> &lt;==&gt; <code>WAITING</code></p>
<ul>
<li>当前线程调用<code>LockSupport.park()</code>方法会让当前线程从<code>RUNNABLE</code> ==&gt; <code>WAITING</code></li>
<li>调用<code>LockSupport.unpark(目标线程)</code>或者调用了线程的<code>interrupt()</code>，会让目标线程从<code>WAITING</code> ==&gt; <code>RUNNABLE</code></li>
</ul>
<p>（5）情况5：<code>RUNNABLE</code> &lt;==&gt; <code>WAITING</code></p>
<p><code>t</code>线程用<code>synchronized(obj)</code>获取了对象锁后</p>
<ul>
<li>调用<code>obj.wait(long n)</code>方法时，<code>t</code>线程从<code>RUNNABLE</code> ==&gt; <code>TIMED_WAITING</code></li>
<li><code>t</code>线程等待时间超过了n毫秒，或调用<code>obj.notify()</code>，<code>obj.notifyAll()</code>，<code>t.interrupt()</code>时<ul>
<li>竞争时成功，<code>t</code>线程从<code>TIMED_WAITING</code> ==&gt; <code>RUNNABLE</code></li>
<li>竞争锁失败，<code>t</code>线程从<code>TIMED_WAITING</code> ==&gt; <code>BLOCKED</code></li>
</ul>
</li>
</ul>
<p>（6）情况6：<code>RUNNABLE</code> &lt;==&gt; <code>TIMED_WAITING</code></p>
<ul>
<li>当前线程调用<code>t.join(long n)</code>方法时，当前线程从<code>RUNNABLE</code> ==&gt; <code>TIMED_WAITING</code><ul>
<li>注意是当前线程在<code>t</code>线程对象的监视器上等待</li>
</ul>
</li>
<li>当前线程等待时间超过了n毫秒，或者<code>t</code>线程运行结束，或者调用了当前线程的<code>interrupt()</code>时，当前线程从<code>TIMED_WAITING</code> ==&gt; <code>RUNNABLE</code></li>
</ul>
<p>（7）情况7：<code>RUNNABLE</code> &lt;==&gt; <code>TIMED_WAITING</code></p>
<ul>
<li>当前线程调用<code>Thread.sleep(long n)</code>，当前线程从<code>RUNNABLE</code> ==&gt; <code>TIMED_WAITING</code></li>
<li>当前线程等待时间超过了n毫秒，当前线程从<code>TIMED_WAITING</code> ==&gt; <code>RUNNABLE</code></li>
</ul>
<p>（8）情况8：<code>RUNNABLE</code> &lt;==&gt; <code>TIMED_WAITING</code></p>
<ul>
<li>当前线程调用<code>LockSupport.parkNanos(long nanos)</code>或<code>LockSupport.parkUntil(long millons)</code>，当前线程从<code>RUNNABLE</code> ==&gt; <code>TIMED_WAITING</code></li>
<li>调用<code>LockSupport.unpark(目标线程)</code>或者调用了线程的<code>interrupt()</code>，或时等待超时，会让目标线程从<code>TIMED_WAITING</code> ==&gt; <code>RUNNABLE</code></li>
</ul>
<p>（9）情况9：<code>RUNNABLE</code> &lt;==&gt; <code>BLOCKED</code></p>
<ul>
<li><code>t</code>线程用<code>synchronized(obj)</code>获取了对象锁时如果竞争失败，从<code>RUNNABLE</code> ==&gt; <code>BLOCKED</code></li>
<li>持<code>obj</code>锁线程的同步代码块执行完毕，会唤醒该对象上所有<code>BLOCKED</code>的线程重新竞争，如果其中<code>t</code>线程竞争成功，从<code>BLOCKED</code> ==&gt; <code>RUNNABLE</code>，其他失败的线程仍然<code>BLOCKED</code></li>
</ul>
<p>（10）情况10：<code>RUNNABLE</code> &lt;==&gt; <code>TERMINATED</code></p>
<p>当先线程所有代码运行完毕，进入<code>TERMINATED</code></p>
<h2 id="2-4-第四部分-锁"><a href="#2-4-第四部分-锁" class="headerlink" title="2.4 第四部分-锁"></a>2.4 第四部分-锁</h2><h3 id="2-4-1-多把锁"><a href="#2-4-1-多把锁" class="headerlink" title="2.4.1 多把锁"></a>2.4.1 多把锁</h3><p><strong>多把不相干的锁</strong></p>
<p>一件大屋子有两个功能：睡觉、学习，互不相干。</p>
<p>现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低。</p>
<p>例如：</p>
<pre><code class="java">public class MultiLockDemo &#123;
    public static void main(String[] args) &#123;
        BigRoom bigRoom = new BigRoom();
        new Thread(() -&gt; &#123;
            try &#123;
                bigRoom.study();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, &quot;小南&quot;).start();
        new Thread(() -&gt; &#123;
            try &#123;
                bigRoom.sleep();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;, &quot;小女&quot;).start();
    &#125;
&#125;

@Slf4j(topic = &quot;BigRoom&quot;)
class BigRoom &#123;
    public void sleep() throws InterruptedException &#123;
        synchronized (this) &#123;
            log.debug(&quot;sleep2个小时&quot;);
            TimeUnit.SECONDS.sleep(2);
        &#125;
    &#125;

    public void study() throws InterruptedException &#123;
        synchronized (this) &#123;
            log.debug(&quot;sleep1个小时&quot;);
            TimeUnit.SECONDS.sleep(1);
        &#125;
    &#125;
&#125;</code></pre>
<p>解决方法是准备多个房间（多个对象锁），让小南和小女获得不同的锁：</p>
<pre><code class="java">@Slf4j(topic = &quot;BigRoom&quot;)
class BigRoom &#123;
    /* 书房 */
    private final Object studyRoom = new Object();
    /* 卧室 */
    private final Object sleepRoom = new Object();
    public void sleep() throws InterruptedException &#123;
        synchronized (sleepRoom) &#123;
            log.debug(&quot;sleep2个小时&quot;);
            TimeUnit.SECONDS.sleep(2);
        &#125;
    &#125;

    public void study() throws InterruptedException &#123;
        synchronized (studyRoom) &#123;
            log.debug(&quot;sleep1个小时&quot;);
            TimeUnit.SECONDS.sleep(1);
        &#125;
    &#125;
&#125;</code></pre>
<p>锁的粒度细分：</p>
<ul>
<li>好处：增强程序的并发性。</li>
<li>坏处：如果一个线程需要同时获得多把锁，就容易发生死锁。</li>
</ul>
<h3 id="2-4-2-活跃性"><a href="#2-4-2-活跃性" class="headerlink" title="2.4.2 活跃性"></a>2.4.2 活跃性</h3><ul>
<li><p>因为某种原因，使得代码一直无法执行完毕，这样的现象叫做活跃性。</p>
</li>
<li><p>活跃性相关的一系列问题都可以用<code>ReentrantLock</code>进行解决。</p>
</li>
</ul>
<h4 id="2-4-2-1-死锁"><a href="#2-4-2-1-死锁" class="headerlink" title="2.4.2.1 死锁"></a>2.4.2.1 死锁</h4><blockquote>
<p>说明</p>
</blockquote>
<p>一个线程需要同时获得多把锁，这时就容易发生死锁。</p>
<p>如：线程1获取A对象锁，线程2获取B对象锁，此时线程1又想获取B对象锁，线程2又想获取A对象锁，它们都等着对象释放锁，此时就称为死锁。</p>
<p>例如：</p>
<pre><code class="java">@Slf4j(topic = &quot;DeadLock&quot;)
public class DeadLockDemo &#123;
    public static void main(String[] args) &#123;
        final Object A = new Object();
        final Object B = new Object();
        new Thread(() -&gt; &#123;
            synchronized (A) &#123;
                log.debug(&quot;lock A&quot;);
                try &#123;
                    TimeUnit.SECONDS.sleep(1);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (B) &#123;
                    log.debug(&quot;lock B&quot;);
                &#125;
            &#125;
        &#125;, &quot;t1&quot;).start();
        new Thread(() -&gt; &#123;
            synchronized (B) &#123;
                log.debug(&quot;lock B&quot;);
                try &#123;
                    TimeUnit.SECONDS.sleep(1);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (A) &#123;
                    log.debug(&quot;lock A&quot;);
                &#125;
            &#125;
        &#125;, &quot;t2&quot;).start();
    &#125;
&#125;</code></pre>
<p>运行：</p>
<pre><code class="java">2021-04-22 22:48:27.708 [t2] DEBUG DeadLock - lock B
2021-04-22 22:48:27.708 [t1] DEBUG DeadLock - lock A</code></pre>
<blockquote>
<p>发生死锁的必要条件</p>
</blockquote>
<ul>
<li>互斥条件：在一段时间内，一种资源只能被一个进程所使用。</li>
<li>请求和保持条件：进程已经拥有了至少一种资源，同时又去申请其他资源。因为其他资源被别的进程所使用，该进程进入阻塞状态，并且不释放自己已有的资源。</li>
<li>不可剥夺条件：进程对已获得的资源在未使用完成前不能被强占，只能在进程使用完后自己释放。</li>
<li>循环等待条件：发生死锁时，必然存在一个进程——资源的循环链。</li>
</ul>
<blockquote>
<p>定位死锁的方法</p>
</blockquote>
<p>先运行上述死锁示例，保证系统中存在死锁进程。</p>
<ol>
<li>jps进程id + jstack定位死锁</li>
</ol>
<pre><code class="powershell">PS &gt; jps
13616 Jps
14432 Launcher 
13796 DeadLockDemo      // 死锁进程
16676
26428 RemoteMavenServer36
PS &gt; jstack 13796
2021-04-22 11:15:43
Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.221-b11 mixed mode):

......

Found one Java-level deadlock: // 发现一个Java级别的死锁
=============================
// 死锁的引用情况
&quot;t2&quot;:
  waiting to lock monitor 0x000000001d390b08 (object 0x000000076cfd4e58, a java.lang.Object),
  which is held by &quot;t1&quot;
&quot;t1&quot;:
  waiting to lock monitor 0x000000001d393028 (object 0x000000076cfd4e68, a java.lang.Object),
  which is held by &quot;t2&quot;

Java stack information for the threads listed above:
===================================================
&quot;t2&quot;:
        at top.parak.share.DeadLockDemo.lambda$main$1(DeadLockDemo.java:39) // 发生死锁的位置
        - waiting to lock &lt;0x000000076cfd4e58&gt; (a java.lang.Object)
        - locked &lt;0x000000076cfd4e68&gt; (a java.lang.Object)
        at top.parak.share.DeadLockDemo$$Lambda$2/885951223.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)
&quot;t1&quot;:
        at top.parak.share.DeadLockDemo.lambda$main$0(DeadLockDemo.java:26) // 发生死锁的位置
        - waiting to lock &lt;0x000000076cfd4e68&gt; (a java.lang.Object)
        - locked &lt;0x000000076cfd4e58&gt; (a java.lang.Object)
        at top.parak.share.DeadLockDemo$$Lambda$1/1854778591.run(Unknown Source)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.</code></pre>
<ol start="2">
<li>jconsole工具检测死锁</li>
</ol>
<p>powershell输入<code>jconsole</code>，连接本地进程，选择线程界面</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210422112258636.png" class="" title="image-20210422112258636">

<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210422112653368.png" class="" title="image-20210422112653368">



<blockquote>
<p>死锁举例：哲学家就餐问题</p>
</blockquote>
<p>有五位哲学家，围坐在圆桌旁：</p>
<ul>
<li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭接着思考。</li>
<li>吃饭时要用两根筷子吃，桌子上共有五根筷子，每位哲学家左右手边各有一根筷子。</li>
<li>如果筷子被身边的人拿着，自己就得等待。</li>
</ul>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210422110000353.png" class="" title="image-20210422110000353">

<p>当每位哲学家即线程持有一根筷子时，他们都在等待另一个线程释放锁，因此造成了死锁。</p>
<p>代码：</p>
<pre><code class="java">public class PhilosophersEatingDemo &#123;
    private final static int NUM = 5;
    public static void main(String[] args) &#123;
        Chopstick[] c = new Chopstick[NUM];
        for (int i = 0; i &lt; NUM; i++) &#123;
            c[i] = new Chopstick(String.valueOf(i));
        &#125;
        new Philosopher(&quot;苏格拉底&quot;, c[0], c[1]).start();
        new Philosopher(&quot;柏拉图&quot;, c[1], c[2]).start();
        new Philosopher(&quot;亚里士多德&quot;, c[2], c[3]).start();
        new Philosopher(&quot;郝拉克利特&quot;, c[3], c[4]).start();
        new Philosopher(&quot;阿基米德&quot;, c[4], c[0]).start();
    &#125;
&#125;

// 哲学家
@Slf4j(topic = &quot;Philosopher&quot;)
class Philosopher extends Thread &#123;
    final Chopstick left;  // 左手筷子
    final Chopstick right; // 右手筷子

    public Philosopher(String name, Chopstick left, Chopstick right) &#123;
        super(name);
        this.left = left;
        this.right = right;
    &#125;

    public void run() &#123;
        while (true) &#123;
            // 尝试获得左手筷子
            synchronized (left) &#123;
                // 尝试获得右手筷子
                synchronized (right) &#123;
                    eat();
                &#125;
            &#125;
        &#125;
    &#125;

    // 吃饭
    private void eat() &#123;
        log.debug(&quot;eating...&quot;);
        try &#123;
            TimeUnit.SECONDS.sleep(1);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

// 筷子
class Chopstick &#123;
    String name;

    public Chopstick(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;筷子[&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;]&#39;;
    &#125;
&#125;</code></pre>
<p>运行：</p>
<pre><code class="powershell">2021-04-22 14:15:57.623 [亚里士多德] DEBUG Philosopher - eating...
2021-04-22 14:15:57.623 [苏格拉底] DEBUG Philosopher - eating...
2021-04-22 14:15:58.632 [亚里士多德] DEBUG Philosopher - eating...
2021-04-22 14:15:58.632 [苏格拉底] DEBUG Philosopher - eating...
2021-04-22 14:15:59.643 [柏拉图] DEBUG Philosopher - eating...
2021-04-22 14:16:00.647 [柏拉图] DEBUG Philosopher - eating...</code></pre>
<p>jconsole检测死锁：</p>
<pre><code>---------------------------------------------------------------------
名称: 苏格拉底
状态: top.parak.share.Chopstick@798c4fad【筷子1】上的BLOCKED, 拥有者: 柏拉图
总阻止数: 8, 总等待数: 6

堆栈跟踪: 
top.parak.share.Philosopher.run(PhilosophersEatingDemo.java:45)
   - 已锁定 top.parak.share.Chopstick@6ea242ba【筷子0】
---------------------------------------------------------------------
名称: 柏拉图
状态: top.parak.share.Chopstick@6057af47【筷子2】上的BLOCKED, 拥有者: 亚里士多德
总阻止数: 3, 总等待数: 2

堆栈跟踪: 
top.parak.share.Philosopher.run(PhilosophersEatingDemo.java:45)
   - 已锁定 top.parak.share.Chopstick@798c4fad【筷子1】
---------------------------------------------------------------------
名称: 亚里士多德
状态: top.parak.share.Chopstick@6796caf6【筷子3】上的BLOCKED, 拥有者: 郝拉克利特
总阻止数: 8, 总等待数: 2

堆栈跟踪: 
top.parak.share.Philosopher.run(PhilosophersEatingDemo.java:45)
   - 已锁定 top.parak.share.Chopstick@6057af47【筷子2】
---------------------------------------------------------------------
名称: 郝拉克利特
状态: top.parak.share.Chopstick@16b56e05【筷子4】上的BLOCKED, 拥有者: 阿基米德
总阻止数: 2, 总等待数: 0

堆栈跟踪: 
top.parak.share.Philosopher.run(PhilosophersEatingDemo.java:45)
   - 已锁定 top.parak.share.Chopstick@6796caf6【筷子3】
---------------------------------------------------------------------
名称: 阿基米德
状态: top.parak.share.Chopstick@6ea242ba【筷子0】上的BLOCKED, 拥有者: 苏格拉底
总阻止数: 1, 总等待数: 0

堆栈跟踪: 
top.parak.share.Philosopher.run(PhilosophersEatingDemo.java:45)
   - 已锁定 top.parak.share.Chopstick@16b56e05【筷子4】</code></pre>
<p>大家都拿着一根筷子，等着另一根筷子，造成死锁，解决得看后面的<code>ReentrantLock</code>。</p>
<h4 id="2-4-2-2-活锁"><a href="#2-4-2-2-活锁" class="headerlink" title="2.4.2.2 活锁"></a>2.4.2.2 活锁</h4><blockquote>
<p>说明</p>
</blockquote>
<p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束。</p>
<p>例如：</p>
<pre><code class="java">@Slf4j(topic = &quot;LiveLock&quot;)
public class LiveLockDemo &#123;

    static volatile int count = 10;
    static final Object lock = new Object();

    public static void main(String[] args) &#123;
        new Thread(() -&gt; &#123;
            // 期望减到0，退出循环
            while (count &gt; 0) &#123;
                try &#123;
                    TimeUnit.MILLISECONDS.sleep(10);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                count--;
                log.debug(&quot;count: &#123;&#125;&quot;, count);
            &#125;
        &#125;, &quot;t1&quot;).start();
        new Thread(() -&gt; &#123;
            // 期望超过20退出循环
            while (count &lt; 20) &#123;
                try &#123;
                    TimeUnit.MILLISECONDS.sleep(10);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                count++;
                log.debug(&quot;count: &#123;&#125;&quot;, count);
            &#125;
        &#125;, &quot;t2&quot;).start();
    &#125;
&#125;</code></pre>
<p>解决：在线程执行时，中途给予不同的间隔时间，让某个线程先结束即可。</p>
<p>死锁与活锁的区别：</p>
<ul>
<li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时线程阻塞，停止运行的现象。</li>
<li>活锁是因为线程间修改了对方的结束条件，从而导致代码一直在运行，却一直运行不完的现象。</li>
</ul>
<h4 id="2-4-2-3-饥饿"><a href="#2-4-2-3-饥饿" class="headerlink" title="2.4.2.3 饥饿"></a>2.4.2.3 饥饿</h4><blockquote>
<p>说明</p>
</blockquote>
<p>某些线程因为优先级太低，始终得不到CPU调度执行，也不能够结束。</p>
<p>在使用顺序加锁时，可能会出现饥饿现象：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210422165813526.png" class="" title="image-20210422165813526">

<p>顺序加锁的解决方案：</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/62531/image-20210422205258032.png" class="" title="image-20210422205258032">



<h3 id="2-4-3-ReentrantLock"><a href="#2-4-3-ReentrantLock" class="headerlink" title="2.4.3 ReentrantLock"></a>2.4.3 ReentrantLock</h3><blockquote>
<p>特点（synchronized不具备的）</p>
</blockquote>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
</ul>
<p>与<code>synchronized</code>一样，都支持可重入。</p>
<blockquote>
<p>比较</p>
</blockquote>
<table>
<thead>
<tr>
<th></th>
<th>Lock</th>
<th>synchronized</th>
</tr>
</thead>
<tbody><tr>
<td>层次方面</td>
<td>（1）<code>Lock</code>是一个接口，是在类级别上的实现；（2）JDK层次的实现</td>
<td>（1）<code>synchronized</code>是Java关键字；（2）JVM层次定义 的</td>
</tr>
<tr>
<td>灵活性方面</td>
<td><code>Lock</code>接口提供的<code>lock()</code>和<code>unlock()</code>方法，可以随时获得锁、释放锁，非常灵活。</td>
<td>释放锁、获得锁是被动的。释放锁只有两种情况：（1）同步代码块执行完毕（2）抛出异常，同步器执行<code>monitor.exit()</code>释放锁。</td>
</tr>
<tr>
<td>锁的状态方面</td>
<td>（1）<code>Lock</code>可以判断锁的状态，它会提供<code>tryLock()</code>方法来告诉我们是否获得锁成功。（2）<code>tryLock()</code>有返回值，用来尝试获取锁，如果获取成功，则返回false；获取失败，返回false，这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</td>
<td>（1）在锁的状态方面，<code>synchronized</code>完全是被动的，没法判断锁的状态。（2）<code>synchronized</code>在拿不到锁时，则会阻塞在那里，一直等待。</td>
</tr>
<tr>
<td>锁的类型方面</td>
<td>基于<code>Lock</code>接口，有多种锁的实现，如：（1）可重入锁：<code>ReentrantLock</code>；（2）可重入读写锁：<code>ReentrantReadWriteLock</code>等。针对可重入锁，还有公平锁和非公平锁之分。</td>
<td>对于<code>synchronized</code>来说，它只是一个JVM层次的关键字，并不是一个接口，没有具体实现。</td>
</tr>
</tbody></table>
<blockquote>
<p>语法</p>
</blockquote>
<pre><code class="java">// 获取锁
reentrantLock.lock();
try &#123;
    // 临界区
&#125; finally &#123;
    // 释放锁
    reentrantLock.unlock();
&#125;</code></pre>
<h4 id="2-4-3-1-可重入"><a href="#2-4-3-1-可重入" class="headerlink" title="2.4.3.1 可重入"></a>2.4.3.1 可重入</h4><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁。如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。</p>
<p>例如：</p>
<pre><code class="java">@Slf4j(topic = &quot;ReentrantLock&quot;)
public class ReentrantLockDemo &#123;

    private static ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) &#123;
        lock.lock();
        try &#123;
            log.debug(&quot;enter main&quot;);
            m1();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public static void m1() &#123;
        lock.lock();
        try &#123;
            log.debug(&quot;enter m1&quot;);
            m2();
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

    public static void m2() &#123;
        lock.lock();
        try &#123;
            log.debug(&quot;enter m2&quot;);
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;

&#125;</code></pre>
<p>运行：</p>
<pre><code>2021-04-22 22:49:46.320 [main] DEBUG ReentrantLock - enter main
2021-04-22 22:49:46.322 [main] DEBUG ReentrantLock - enter m1
2021-04-22 22:49:46.322 [main] DEBUG ReentrantLock - enter m2</code></pre>
<h4 id="2-4-3-2-可打断"><a href="#2-4-3-2-可打断" class="headerlink" title="2.4.3.2 可打断"></a>2.4.3.2 可打断</h4><p><code>synchoronized</code>和<code>reentrantLock.lock()</code>的锁，是不可被打断的，也就是说别的线程已经获得了锁，我的线程就需要一直等待下去，不能中断。</p>
<p>可被中断的锁，通过<code>reentrantLock.lockInterruptibly()</code>获取的锁对象，可以通过调用阻塞线程的<code>interrupt()</code>方法。</p>
<p>如果某个线程处于阻塞状态，可以调用其<code>interrupt()</code>方法让其停止阻塞，获得锁失败。处于阻塞状态的线程，被打断了就不用阻塞了，直接停止就行。</p>
<p>可中断的锁，在一定程度上可以被动的减少死锁的概率，之所以被动，是因为我们需要手动调用阻塞线程的<code>interrupt()</code>方法。</p>
<p>例如：</p>
<pre><code class="java">@Slf4j(topic = &quot;LockInterruptibly&quot;)
public class LockInterruptiblyDemo &#123;
    private static ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            try &#123;
                // 如果没有竞争那么此方法就会获取lock对象锁
                // 如果有竞争就进入阻塞队列，可以被其他线程用interrupt方法打断
                log.debug(&quot;尝试获得锁&quot;);
                lock.lockInterruptibly();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
                log.debug(&quot;未获取锁&quot;);
                return;
            &#125;
            try &#123;
                log.debug(&quot;获取到锁&quot;);
            &#125; finally &#123;
                lock.unlock();
            &#125;
        &#125;, &quot;t1&quot;);
        lock.lock();
        t1.start();
        try &#123;
            TimeUnit.SECONDS.sleep(1);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        log.debug(&quot;打断t1线程&quot;);
        t1.interrupt();
    &#125;
&#125;</code></pre>
<p>结果：</p>
<pre><code>2021-04-22 22:57:01.129 [t1] DEBUG LockInterruptibly - 尝试获得锁
2021-04-22 22:57:02.148 [main] DEBUG LockInterruptibly - 打断t1线程
2021-04-22 22:57:02.149 [t1] DEBUG LockInterruptibly - 未获取锁
java.lang.InterruptedException</code></pre>
<h4 id="2-4-3-3-锁超时"><a href="#2-4-3-3-锁超时" class="headerlink" title="2.4.3.3 锁超时"></a>2.4.3.3 锁超时</h4><p>防止无限制等待，减少死锁。</p>
<ul>
<li><code>reentrantLock.tryLock()</code>会返回锁是否成功。如果成功则返回true，反之则返回false。</li>
<li><code>tryLock(long timeout， TimeUnit unit)</code>可以设置指定等待时间，其中timeout为最长等待时间，unit为时间单位。</li>
</ul>
<p>例如：</p>
<pre><code>@Slf4j(topic = &quot;TryLock&quot;)
public class TryLockDemo &#123;
    private static final ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException &#123;
        Thread t1 = new Thread(() -&gt; &#123;
            log.debug(&quot;尝试获取锁&quot;);
            try &#123;
                if (!lock.tryLock(2, TimeUnit.SECONDS)) &#123; // 尝试等待2S，获取锁
                    log.debug(&quot;获取不到锁&quot;);
                    return;
                &#125;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
                log.debug(&quot;获取不到锁&quot;);
                return;
            &#125;
            try &#123;
                log.debug(&quot;获取到锁&quot;);
            &#125; finally &#123;
                lock.unlock();
            &#125;
        &#125;, &quot;t1&quot;);
        lock.lock();
        log.debug(&quot;获取到锁&quot;);
        t1.start();
        TimeUnit.SECONDS.sleep(1);
        lock.unlock();
        log.debug(&quot;释放了锁&quot;);
    &#125;
&#125;</code></pre>
<p>运行：</p>
<pre><code>2021-04-23 00:46:54.944 [main] DEBUG TryLock - 获取到锁
2021-04-23 00:46:54.946 [t1] DEBUG TryLock - 尝试获取锁
2021-04-23 00:46:55.949 [main] DEBUG TryLock - 释放了锁
2021-04-23 00:46:55.949 [t1] DEBUG TryLock - 获取到锁</code></pre>
<blockquote>
<p>解决哲学家就餐的问题</p>
</blockquote>
<p>尝试获取筷子，获取不到就放下。</p>
<pre><code class="java">public class PhilosophersEatingDemo &#123;
    private final static int NUM = 5;
    public static void main(String[] args) &#123;
        Chopstick[] c = new Chopstick[NUM];
        for (int i = 0; i &lt; NUM; i++) &#123;
            c[i] = new Chopstick(String.valueOf(i));
        &#125;
        new Philosopher(&quot;苏格拉底&quot;, c[0], c[1]).start();
        new Philosopher(&quot;柏拉图&quot;, c[1], c[2]).start();
        new Philosopher(&quot;亚里士多德&quot;, c[2], c[3]).start();
        new Philosopher(&quot;郝拉克利特&quot;, c[3], c[4]).start();
        new Philosopher(&quot;阿基米德&quot;, c[4], c[0]).start();
    &#125;
&#125;

// 哲学家
@Slf4j(topic = &quot;Philosopher&quot;)
class Philosopher extends Thread &#123;
    final Chopstick left;  // 左手筷子
    final Chopstick right; // 右手筷子

    public Philosopher(String name, Chopstick left, Chopstick right) &#123;
        super(name);
        this.left = left;
        this.right = right;
    &#125;

    public void run() &#123;
        while (true) &#123;
            if (left.tryLock()) &#123; // 尝试获得左手筷子
                try &#123;
                    if (right.tryLock()) &#123; // 尝试获得右手筷子
                        try &#123;
                            eat();
                        &#125; finally &#123;
                            right.unlock(); // 释放右手筷子
                        &#125;
                    &#125;
                &#125; finally &#123;
                    left.unlock();  // 释放左手筷子
                &#125;
            &#125;
        &#125;
    &#125;

    // 吃饭
    private void eat() &#123;
        log.debug(&quot;eating...&quot;);
        try &#123;
            TimeUnit.SECONDS.sleep(1);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

// 筷子
class Chopstick extends ReentrantLock  &#123;
    String name;

    public Chopstick(String name) &#123;
        this.name = name;
    &#125;

    @Override
    public String toString() &#123;
        return &quot;筷子[&quot; + &quot;name=&#39;&quot; + name + &#39;]&#39;;
    &#125;
&#125;</code></pre>
<h4 id="2-4-3-4-公平锁"><a href="#2-4-3-4-公平锁" class="headerlink" title="2.4.3.4 公平锁"></a>2.4.3.4 公平锁</h4><ul>
<li>可以把竞争的线程放在一个先进先出的阻塞队列上</li>
<li>只要持有锁的线程执行完了，唤醒阻塞队列中的下一个线程获取锁即可</li>
<li>先进入队列的线程先获取到锁</li>
</ul>
<p>synchronized是不公平锁。一个线程持有锁，其他线程进入阻塞队列；当这个线程释放了锁，那么阻塞队列的线程就会一起去争抢，而不是按照先来先得的顺序。</p>
<p>ReentrantLock默认是不公平的，但是可以切换为公平锁，看一眼带参构造方法：</p>
<pre><code class="java">public ReentrantLock(boolean fair) &#123;
    sync = fair ? new FairSync() : new NonfairSync();
&#125;</code></pre>
<p>构造一个公平锁<code>new ReentrantLock(true)</code>，公平锁没有必要，会降低并发度。</p>
<h4 id="2-4-3-5-条件变量"><a href="#2-4-3-5-条件变量" class="headerlink" title="2.4.3.5 条件变量"></a>2.4.3.5 条件变量</h4><p>synchronized中也有条件变量，就是<code>waitSet</code>，当条件不满足时进入<code>waitSet</code>，当条件不满足时进入<code>waitSet</code>等待。<code>ReentrantLock</code>的条件变量比<code>synchronized</code>强大之处在于，它是支持多个条件变量的。</p>
<ul>
<li><code>synchronized</code>让那些不满足条件的线程都在一间休息室等消息</li>
<li><code>ReentrantLock</code>支持多间休息室，有专门等的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
<p>使用流程：</p>
<ul>
<li><code>await</code>前需要获得锁</li>
<li><code>await</code>执行后，会释放锁，进入<code>conditionObject</code>等待</li>
<li><code>await</code>的线程被唤醒（或打断、或超时）重新竞争lock锁</li>
<li>竞争lock锁成功后，从await后继续执行</li>
</ul>
<p>示例：</p>
<pre><code class="java">@Slf4j(topic = &quot;CorrectPostureStep4&quot;)
public class CorrectPostureStep4Demo &#123;
    static boolean hasCigarette = false;
    static boolean hasTakeAway = false;
    static ReentrantLock ROOM = new ReentrantLock();
    // 等烟的休息室
    static Condition waitCigaretteSet = ROOM.newCondition();
    // 等外卖的休息室
    static Condition waitTakeAwaySet = ROOM.newCondition();

    public static void main(String[] args) throws InterruptedException &#123;
        new Thread(() -&gt; &#123;
            ROOM.lock();
            try &#123;
                String name = Thread.currentThread().getName();
                log.debug(&quot;有烟吗 ? [&#123;&#125;]&quot;, hasCigarette);
                while (!hasCigarette) &#123; // 防止虚假唤醒
                    log.debug(&quot;没有烟 =&gt; [&#123;&#125;]先歇会...&quot;, name);
                    waitCigaretteSet.await();
                &#125;
                log.debug(&quot;再看看有烟吗 ? [&#123;&#125;]&quot;, hasCigarette);
                if (hasCigarette) &#123;
                    log.debug(&quot;有烟了 =&gt; [&#123;&#125;]开始干活ing&quot;, name);
                &#125; else &#123;
                    log.debug(&quot;依然没有烟 =&gt; [&#123;&#125;]不干活了&quot;, name);
                &#125;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; finally &#123;
                ROOM.unlock();
            &#125;
        &#125;, &quot;FlowerK&quot;).start();
        new Thread(() -&gt; &#123;
            ROOM.lock();
            try &#123;
                String name = Thread.currentThread().getName();
                log.debug(&quot;外卖是否送到 ? [&#123;&#125;]&quot;, hasTakeAway);
                if (!hasTakeAway) &#123;
                    log.debug(&quot;外卖还未送到 =&gt; [&#123;&#125;]先歇会...&quot;, name);
                    waitTakeAwaySet.await();
                &#125;
                log.debug(&quot;再看看外卖是否送到 ? [&#123;&#125;]&quot;, hasTakeAway);
                if (hasTakeAway) &#123;
                    log.debug(&quot;外卖已经送到 =&gt; [&#123;&#125;]开始干活ing&quot;, name);
                &#125; else &#123;
                    log.debug(&quot;外卖仍然未到 =&gt; [&#123;&#125;]不干活了&quot;, hasTakeAway);
                &#125;
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; finally &#123;
                ROOM.unlock();
            &#125;
        &#125;, &quot;RubbishK&quot;).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; &#123;
            ROOM.lock();
            try &#123;
                hasTakeAway = true;
                waitTakeAwaySet.signal();
                log.debug(&quot;外卖已送到&quot;);
            &#125; finally &#123;
                ROOM.unlock();
            &#125;
        &#125;, &quot;美团外卖&quot;).start();
        TimeUnit.SECONDS.sleep(1);
        new Thread(() -&gt; &#123;
            ROOM.lock();
            try &#123;
                hasCigarette = true;
                waitCigaretteSet.signal();
                log.debug(&quot;烟已送到&quot;);
            &#125; finally &#123;
                ROOM.unlock();
            &#125;
        &#125;, &quot;饿了么&quot;).start();
    &#125;
&#125;</code></pre>
<h3 id="2-4-4-同步模式之顺序控制"><a href="#2-4-4-同步模式之顺序控制" class="headerlink" title="2.4.4 同步模式之顺序控制"></a>2.4.4 同步模式之顺序控制</h3><h4 id="2-4-4-1-固定输出"><a href="#2-4-4-1-固定输出" class="headerlink" title="2.4.4.1 固定输出"></a>2.4.4.1 固定输出</h4><p>有两个线程，线程A打印1，线程B打印2。</p>
<p>要求：程序必须先打印2再打印1。</p>
<blockquote>
<p>wait/notify版本</p>
</blockquote>
<pre><code class="java">@Slf4j(topic = &quot;OrderWaitNotify&quot;)
public class OrderWaitNotifyDemo &#123;
    private static final Object lock = new Object();
    private static boolean bRunned = false; // 表示t2是否运行
    public static void main(String[] args) &#123;
        Thread a = new Thread(() -&gt; &#123;
            synchronized (lock) &#123;
                while (!bRunned) &#123;
                    try &#123;
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
            log.debug(&quot;1&quot;);
        &#125;, &quot;A&quot;);
        Thread b = new Thread(() -&gt; &#123;
            synchronized (lock)  &#123;
                log.debug(&quot;2&quot;);
                bRunned = true;
                lock.notify();
            &#125;
        &#125;, &quot;B&quot;);
        a.start();
        b.start();
    &#125;
&#125;</code></pre>
<blockquote>
<p>await/signal版本</p>
</blockquote>
<pre><code class="java">@Slf4j(topic = &quot;OrderReentrant&quot;)
public class OrderReentrantDemo &#123;
    private static final ReentrantLock lock = new ReentrantLock();
    private static final Condition condition = lock.newCondition();
    private static boolean bRunned = false;
    public static void main(String[] args) &#123;
        Thread a = new Thread(() -&gt; &#123;
            lock.lock();
            try &#123;
                if (!bRunned) &#123;
                    condition.await();
                &#125;
                log.debug(&quot;1&quot;);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; finally &#123;
                lock.unlock();
            &#125;
        &#125;, &quot;A&quot;);
        Thread b = new Thread(() -&gt; &#123;
            lock.lock();
            try &#123;
                log.debug(&quot;2&quot;);
                bRunned = true;
                condition.signal();
            &#125; finally &#123;
                lock.unlock();
            &#125;
        &#125;, &quot;B&quot;);
        a.start();
        b.start();
    &#125;
&#125;</code></pre>
<blockquote>
<p>park/unpark版本</p>
</blockquote>
<pre><code class="java">@Slf4j(topic = &quot;OrderParkUnpark&quot;)
public class OrderParkUnparkDemo &#123;
    public static void main(String[] args) &#123;
        Thread a = new Thread(() -&gt; &#123;
            LockSupport.park();
            log.debug(&quot;1&quot;);
        &#125;, &quot;A&quot;);
        Thread b = new Thread(() -&gt; &#123;
            log.debug(&quot;2&quot;);
            LockSupport.unpark(a);
        &#125;, &quot;B&quot;);
        a.start();
        b.start();
    &#125;
&#125;</code></pre>
<h4 id="2-4-4-2-交替输出"><a href="#2-4-4-2-交替输出" class="headerlink" title="2.4.4.2 交替输出"></a>2.4.4.2 交替输出</h4><p>线程A输出a五次，线程B输出b五次，线程C输出c五次。</p>
<p>要求：程序交替输出5次<code>abc</code>。</p>
<blockquote>
<p>wait/notify版本</p>
</blockquote>
<pre><code class="java">public class AlternateWaitNotifyDemo &#123;
    public static void main(String[] args) &#123;
        AlternateWaitNotify alternateWaitNotify = new AlternateWaitNotify(1, 5);
        new Thread(() -&gt; alternateWaitNotify.print(&quot;a&quot;, 1, 2), &quot;A&quot;).start();
        new Thread(() -&gt; alternateWaitNotify.print(&quot;b&quot;, 2, 3), &quot;B&quot;).start();
        new Thread(() -&gt; alternateWaitNotify.print(&quot;c&quot;, 3, 1), &quot;C&quot;).start();
    &#125;
&#125;

@Slf4j(topic = &quot;AlternateWaitNotify&quot;)
class AlternateWaitNotify &#123;
    // 当前标记
    private int flag;
    // 循环次数
    private final int loopNumber;

    public AlternateWaitNotify(int flag, int loopNumber) &#123;
        this.flag = flag;
        this.loopNumber = loopNumber;
    &#125;

    /**
     *   输出内容   等待标记   下个标记
     *      a         1         2
     *      b         2         3
     *      c         3         1
     *
     * @param str       输出内容
     * @param waitFlag  等待标记
     * @param nextFlag  下个标记
     */
    public void print(String str, int waitFlag, int nextFlag) &#123;
        for (int i = 0; i &lt; loopNumber; i++) &#123;
            synchronized (this) &#123;
                while (waitFlag != this.flag) &#123;
                    try &#123;
                        this.wait();
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
                log.debug(str);
                this.flag = nextFlag;
                this.notifyAll();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>await/signal版本</p>
</blockquote>
<pre><code class="java">public class AlternateAwaitSignalDemo &#123;
    public static void main(String[] args) &#123;
        AlternateAwaitSignal alternateWaitNotify = new AlternateAwaitSignal(5);
        Condition aCondition = alternateWaitNotify.newCondition();
        Condition bCondition = alternateWaitNotify.newCondition();
        Condition cCondition = alternateWaitNotify.newCondition();
        new Thread(() -&gt; alternateWaitNotify.print(&quot;a&quot;, aCondition, bCondition), &quot;A&quot;).start();
        new Thread(() -&gt; alternateWaitNotify.print(&quot;b&quot;, bCondition, cCondition), &quot;B&quot;).start();
        new Thread(() -&gt; alternateWaitNotify.print(&quot;c&quot;, cCondition, aCondition), &quot;C&quot;).start();
    &#125;
&#125;

@Slf4j(topic = &quot;AlternateAwaitSignal&quot;)
class AlternateAwaitSignal extends ReentrantLock &#123;
    private final int loopNumber;

    public AlternateAwaitSignal(int loopNumber) &#123;
        this.loopNumber = loopNumber;
    &#125;

    /**
     * @param str   打印内容
     * @param curr  当前休息室
     * @param next  下个休息室
     */
    public void print(String str, Condition curr, Condition next) &#123;
        for (int i = 0; i &lt; loopNumber; i++) &#123;
            lock();
            try &#123;
                curr.await();
                log.debug(str);
                next.signal();
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125; finally &#123;
                unlock();
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>park/unpark版本</p>
</blockquote>
<pre><code class="java">public class AlternateParkUnparkDemo &#123;
    static Thread t1;
    static Thread t2;
    static Thread t3;
    public static void main(String[] args) &#123;
        AlternateParkUnpark alternateParkUnpark = new AlternateParkUnpark(5);
        t1 = new Thread(() -&gt; alternateParkUnpark.print(&quot;a&quot;, t2), &quot;t1&quot;);
        t2 = new Thread(() -&gt; alternateParkUnpark.print(&quot;b&quot;, t3), &quot;t2&quot;);
        t3 = new Thread(() -&gt; alternateParkUnpark.print(&quot;c&quot;, t1), &quot;t3&quot;);
        t1.start();
        t2.start();
        t3.start();
        LockSupport.unpark(t1);
    &#125;
&#125;

@Slf4j(topic = &quot;AlternateParkUnpark&quot;)
class AlternateParkUnpark &#123;
    private final int loopNumber;

    public AlternateParkUnpark(int loopNumber) &#123;
        this.loopNumber = loopNumber;
    &#125;

    public void print(String str, Thread next) &#123;
        for (int i = 0; i &lt; loopNumber; i++) &#123;
            LockSupport.park();
            log.debug(str);
            LockSupport.unpark(next);
        &#125;
    &#125;
&#125;</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<p>重点掌握：</p>
<ul>
<li>分析多线程访问资源时，哪些代码片段属于临界区</li>
<li>使用<code>synchronized</code>互斥解决临界区的线程安全问题<ul>
<li>掌握<code>synchronized</code>锁对象语法</li>
<li>掌握<code>synchronized</code>加载成员方法和静态方法语法</li>
<li>掌握<code>wait/notify</code>同步方法</li>
</ul>
</li>
<li>使用<code>Lock</code>互斥解决临界区的线程安全问题<ul>
<li>掌握<code>Lock</code>的使用细节：可打断、锁超时、公平锁、条件变量</li>
</ul>
</li>
<li>学会分析变量的线程安全性、掌握常见线程安全类的使用</li>
<li>了解线程活跃性问题：死锁、活锁、饥饿</li>
<li>应用方面<ul>
<li>互斥：使用<code>synchronized</code>或<code>Lock</code>达到共享资源互斥效果</li>
<li>同步：使用<code>wait/notify</code>或<code>Lock</code>的条件变量来达到线程间通信效果</li>
</ul>
</li>
<li>原理方面<ul>
<li><code>monitor</code>、<code>sychronized</code>、<code>wait/notify</code>原理</li>
<li><code>synchronized</code>进阶原理</li>
<li><code>park &amp; unpark</code>原理</li>
</ul>
</li>
<li>模式方面<ul>
<li>同步模式之保护性暂停</li>
<li>异步模式之生产者消费者</li>
<li>同步模式之顺序控制</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://parak.top">Khighness</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://parak.top/posts/62531">https://parak.top/posts/62531</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"> CC BY-NC-SA 4.0 </a>许可协议。转载请注明来自<a href="https://www.parak.top">炒菜K殿下</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-23.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/wepay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/wepay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/37386/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-24.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JUC-3(共享模型之内存)</div></div></a></div><div class="next-post pull-right"><a href="/posts/9175/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-22.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JUC-1(线程基础)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/11567/" title="JVM-15(垃圾回收器)"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-44.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-06-01</div><div class="title">JVM-15(垃圾回收器)</div></div></a></div><div><a href="/posts/31658/" title="JVM-14(垃圾回收概念)"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-43.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-31</div><div class="title">JVM-14(垃圾回收概念)</div></div></a></div><div><a href="/posts/25/" title="JVM-13(垃圾回收算法)"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-42.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-30</div><div class="title">JVM-13(垃圾回收算法)</div></div></a></div><div><a href="/posts/59786/" title="JVM-12(String Table)"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-41.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-29</div><div class="title">JVM-12(String Table)</div></div></a></div><div><a href="/posts/58113/" title="JVM-11(执行引擎)"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-40.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-28</div><div class="title">JVM-11(执行引擎)</div></div></a></div><div><a href="/posts/6513/" title="JVM-10(直接内存)"><img class="cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-39.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-27</div><div class="title">JVM-10(直接内存)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">2.1 第一部分-线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">2.1.1 线程安全问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-synchronized%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">2.1.2 synchronized解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E5%85%AB%E9%94%81%E7%8E%B0%E8%B1%A1"><span class="toc-text">2.1.3 八锁现象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">2.1.4  变量的线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-%E4%B9%A0%E9%A2%98"><span class="toc-text">2.1.5 习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-Monitor"><span class="toc-text">2.2 第二部分-Monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Monitor"><span class="toc-text">2.2.1 Monitor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-synchronized%E5%8E%9F%E7%90%86"><span class="toc-text">2.2.2 synchronized原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">2.2.3 轻量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text">2.2.4 重量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text">2.2.5 偏向锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.3 第三部分-模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-wait-notify"><span class="toc-text">2.3.1 wait notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C"><span class="toc-text">2.3.2 同步模式之保护性暂停</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">2.3.3 异步模式之生产者&#x2F;消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-park-unprak"><span class="toc-text">2.3.4 park unprak</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text">2.3.5 线程状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E9%94%81"><span class="toc-text">2.4 第四部分-锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E5%A4%9A%E6%8A%8A%E9%94%81"><span class="toc-text">2.4.1 多把锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-text">2.4.2 活跃性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-1-%E6%AD%BB%E9%94%81"><span class="toc-text">2.4.2.1 死锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-2-%E6%B4%BB%E9%94%81"><span class="toc-text">2.4.2.2 活锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-3-%E9%A5%A5%E9%A5%BF"><span class="toc-text">2.4.2.3 饥饿</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-ReentrantLock"><span class="toc-text">2.4.3 ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-1-%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-text">2.4.3.1 可重入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-2-%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-text">2.4.3.2 可打断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-3-%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-text">2.4.3.3 锁超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-4-%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text">2.4.3.4 公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-5-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">2.4.3.5 条件变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-text">2.4.4 同步模式之顺序控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-1-%E5%9B%BA%E5%AE%9A%E8%BE%93%E5%87%BA"><span class="toc-text">2.4.4.1 固定输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-2-%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="toc-text">2.4.4.2 交替输出</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Khighness/cdn/common/footer.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Khighness</div><div class="footer_custom_text"><a href="https://www.foreverblog.cn/" target="_blank" > <img src="https://img.foreverblog.cn/logo_en_default.png" alt="" style="width:auto;height:16px;"> </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'hexo-2grv2lyu1131c342',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'hexo-2grv2lyu1131c342',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Py2eOHzSdrnxKPzKrOJaHJOq-9Nh9j0Va',
      appKey: '9eQhwuCgyshpYKn4rtEhqt4R',
      placeholder: '',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: 'https://cdn.jsdelivr.net/gh/imaegoo/emotion/owo.json',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick, mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/js/Valine.min.js').then(initValine)
}

if ('Twikoo' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'hexo-2grv2lyu1131c342',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>