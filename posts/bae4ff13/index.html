<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis | Khighness</title><meta name="keywords" content="缓存"><meta name="author" content="Khighness"><meta name="copyright" content="Khighness"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 📩NoSQL概述1.1 📃简介 ⚡ NoSQL  NoSQL !&#x3D; 非SQL  NoSQL &#x3D;&#x3D; Not Only SQL 不仅仅是SQL！ 泛指非关系型的数据库。克服大并发。 很多的数据类型，用户的个人信息、社交网络和地理位置，这些数据类型的存储不需要一个固定的格式，不需要多元的操作就可以横向扩展。">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://www.parak.top/posts/bae4ff13/index.html">
<meta property="og:site_name" content="Khighness">
<meta property="og:description" content="1. 📩NoSQL概述1.1 📃简介 ⚡ NoSQL  NoSQL !&#x3D; 非SQL  NoSQL &#x3D;&#x3D; Not Only SQL 不仅仅是SQL！ 泛指非关系型的数据库。克服大并发。 很多的数据类型，用户的个人信息、社交网络和地理位置，这些数据类型的存储不需要一个固定的格式，不需要多元的操作就可以横向扩展。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-7.jpg">
<meta property="article:published_time" content="2020-10-07T16:00:00.000Z">
<meta property="article:modified_time" content="2021-06-03T14:47:00.443Z">
<meta property="article:author" content="Khighness">
<meta property="article:tag" content="缓存">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-7.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/K.jpg"><link rel="canonical" href="https://www.parak.top/posts/bae4ff13/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//s4.cnzz.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="yandex-verification" content="{&quot;theme_color&quot;:{&quot;enable&quot;:true,&quot;main&quot;:&quot;#49B1F5&quot;,&quot;paginator&quot;:&quot;#00c4b6&quot;,&quot;button_hover&quot;:&quot;#FF7242&quot;,&quot;text_selection&quot;:&quot;#00c4b6&quot;,&quot;link_color&quot;:&quot;#99a9bf&quot;,&quot;meta_color&quot;:&quot;#858585&quot;,&quot;hr_color&quot;:&quot;#A4D8FA&quot;,&quot;code_foreground&quot;:&quot;#F47466&quot;,&quot;code_background&quot;:&quot;rgba(27, 31, 35, .05)&quot;,&quot;toc_color&quot;:&quot;#00c4b6&quot;,&quot;blockquote_padding_color&quot;:&quot;#49b1f5&quot;,&quot;blockquote_background_color&quot;:&quot;#49b1f5&quot;}}"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?16576652";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" data-pjax="data-pjax" src="https://s4.cnzz.com/z_stat.php?id=1279324689&amp;web_id=1279324689"></script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Khighness","link":"链接: ","source":"来源: Khighness","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-06-03 22:47:00'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/iconfont/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="Khighness" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/Khighness.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">26</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Khighness</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw iconfont icon-index"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw iconfont icon-tianchongxing-1"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw iconfont icon-tianchongxing-"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw iconfont icon-fenlei"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw iconfont icon-ziyuan"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw iconfont icon-K"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-10-07T16:00:00.000Z" title="发表于 2020-10-08 00:00:00">2020-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-06-03T14:47:00.443Z" title="更新于 2021-06-03 22:47:00">2021-06-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>105分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="1-📩NoSQL概述"><a href="#1-📩NoSQL概述" class="headerlink" title="1. 📩NoSQL概述"></a>1. 📩NoSQL概述</h2><h3 id="1-1-📃简介"><a href="#1-1-📃简介" class="headerlink" title="1.1 📃简介"></a>1.1 📃简介</h3><blockquote>
<p>⚡ NoSQL</p>
</blockquote>
<p>NoSQL != 非SQL </p>
<p>NoSQL == Not Only SQL</p>
<p>不仅仅是SQL！</p>
<p>泛指非关系型的数据库。克服大并发。</p>
<p>很多的数据类型，用户的个人信息、社交网络和地理位置，这些数据类型的存储不需要一个固定的格式，不需要多元的操作就可以横向扩展。</p>
<a id="more"></a>



<h3 id="1-2-🌀特点"><a href="#1-2-🌀特点" class="headerlink" title="1.2 🌀特点"></a>1.2 🌀特点</h3><ul>
<li><p>方便扩展（数据之间没有关系，很好扩展）</p>
</li>
<li><p>大数据量高性能（细粒度缓存，性能高）</p>
</li>
<li><p>数据类型多样（不需要设计数据库，随取随用）</p>
</li>
<li><p>RDBMS和NoSQL的区别: </p>
<ul>
<li>RDBMS<ul>
<li>结构化组织</li>
<li>SQL</li>
<li>数据和关系都存在单独的表中</li>
<li>严格的一致性</li>
<li>基础的事务</li>
<li>···</li>
</ul>
</li>
<li>NoSQL<ul>
<li>不仅仅是数据</li>
<li>没有固定的查询语言</li>
<li>键值对存储，列存储，文档存储，图形存储</li>
<li>最终一致性</li>
<li>CAP和BASE</li>
<li>三高：高性能、高可用、高可扩展</li>
<li>···</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-🚀3V-3H"><a href="#1-3-🚀3V-3H" class="headerlink" title="1.3 🚀3V+3H"></a>1.3 🚀3V+3H</h3><ul>
<li>大数据时代的3V<ul>
<li>海量 Volume</li>
<li>多样 Variety</li>
<li>实时 Velocity</li>
</ul>
</li>
<li>互联网需求的3H<ul>
<li>高并发 High concurrency</li>
<li>高可拓 High scalable</li>
<li>高性能 High performance</li>
</ul>
</li>
</ul>
<h3 id="1-4-📚分类"><a href="#1-4-📚分类" class="headerlink" title="1.4 📚分类"></a>1.4 📚分类</h3><blockquote>
<p>😭呜呜呜，我好菜，我啥都不会🍼</p>
</blockquote>
<table>
<thead>
<tr>
<th>分类</th>
<th>举例</th>
<th>典型应用场景</th>
<th>数据模型</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>键值对</td>
<td>Tokyo Cabinet/Tyrant，Redis，Voldemort，Oracle BDB</td>
<td>内容UAN，主要用于处理大量数据的高访问负载，也用于一些日志系统等等</td>
<td>Key指向value的键值对，通常用hash table来实现</td>
<td>查找速度快</td>
<td>数据无结构化，通常只被当做字符串或者二进制数据</td>
</tr>
<tr>
<td>列存储数据库</td>
<td>Cassandra，HBase，Riak</td>
<td>分布式的文件系统</td>
<td>以列簇式存储，将同一列数据存在一起</td>
<td>查找速度快，可扩展性强，更容易进行分布式扩展</td>
<td>功能相对局限</td>
</tr>
<tr>
<td>文档型数据库</td>
<td>CouchDB，MongoDB</td>
<td>Web应用</td>
<td>Key-Value对应的键值对，Value为结构化数据</td>
<td>数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构</td>
<td>查询性能不高，而且缺乏统一的查询语言</td>
</tr>
<tr>
<td>图形数据库</td>
<td>Neo4J，InfoGrid，Infinite Graph</td>
<td>社交网络、推荐系统等等，专注于构建关系图谱</td>
<td>图结构</td>
<td>利用图结构相关算法。比如最短路径寻址，N度关系查找等</td>
<td>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</td>
</tr>
</tbody></table>
<h3 id="1-5-📈阿里巴技术演进"><a href="#1-5-📈阿里巴技术演进" class="headerlink" title="1.5 📈阿里巴技术演进"></a>1.5 📈阿里巴技术演进</h3><blockquote>
<p>✡技术并无高低之分，就看你如何使用</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009144812661.png" class="" title="image-20201009144812661.png">

<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009145619674.png" class="" title="image-20201009145619674.png">

<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009153115683.png" class="" title="image-20201009153115683.png">

<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009153346176.png" class="" title="image-20201009153346176.png">





<h2 id="2-📩Redis入门"><a href="#2-📩Redis入门" class="headerlink" title="2. 📩Redis入门"></a>2. 📩Redis入门</h2><blockquote>
<p> 🌐 official website</p>
</blockquote>
<ul>
<li><p>英文官网：<a target="_blank" rel="noopener" href="https://www.redis.io/">redis</a></p>
</li>
<li><p>中文官网：<del><a target="_blank" rel="noopener" href="https://www.redis.cn/">redis</a></del></p>
</li>
<li><p>中文官网：<a target="_blank" rel="noopener" href="https://www.redis.net.cn/">redis</a></p>
</li>
</ul>
<h3 id="2-1-📑简介"><a href="#2-1-📑简介" class="headerlink" title="2.1 📑简介"></a>2.1 📑简介</h3><blockquote>
<p>💡 Redis = Remote Dictionary Server</p>
</blockquote>
<p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 <a target="_blank" rel="noopener" href="http://redis.cn/topics/data-types-intro.html#strings">字符串（strings）</a>， <a target="_blank" rel="noopener" href="http://redis.cn/topics/data-types-intro.html#hashes">散列（hashes）</a>， <a target="_blank" rel="noopener" href="http://redis.cn/topics/data-types-intro.html#lists">列表（lists）</a>， <a target="_blank" rel="noopener" href="http://redis.cn/topics/data-types-intro.html#sets">集合（sets）</a>， <a target="_blank" rel="noopener" href="http://redis.cn/topics/data-types-intro.html#sorted-sets">有序集合（sorted sets）</a> 与范围查询， <a target="_blank" rel="noopener" href="http://redis.cn/topics/data-types-intro.html#bitmaps">bitmaps</a>， <a target="_blank" rel="noopener" href="http://redis.cn/topics/data-types-intro.html#hyperloglogs">hyperloglogs</a> 和 <a target="_blank" rel="noopener" href="http://redis.cn/commands/geoadd.html">地理空间（geospatial）</a> 索引半径查询。 Redis 内置了 <a target="_blank" rel="noopener" href="http://redis.cn/topics/replication.html">复制（replication）</a>，<a target="_blank" rel="noopener" href="http://redis.cn/commands/eval.html">LUA脚本（Lua scripting）</a>， <a target="_blank" rel="noopener" href="http://redis.cn/topics/lru-cache.html">LRU驱动事件（LRU eviction）</a>，<a target="_blank" rel="noopener" href="http://redis.cn/topics/transactions.html">事务（transactions）</a> 和不同级别的 <a target="_blank" rel="noopener" href="http://redis.cn/topics/persistence.html">磁盘持久化（persistence）</a>， 并通过 <a target="_blank" rel="noopener" href="http://redis.cn/topics/sentinel.html">Redis哨兵（Sentinel）</a>和自动 <a target="_blank" rel="noopener" href="http://redis.cn/topics/cluster-tutorial.html">分区（Cluster）</a>提供高可用性（high availability）^(来自官方文档)^。</p>
<h3 id="2-2-🌠特性"><a href="#2-2-🌠特性" class="headerlink" title="2.2 🌠特性"></a>2.2 🌠特性</h3><ul>
<li><input checked="" disabled="" type="checkbox"> 性能优秀，数据在内存中，读写速度非常快，支持10w并发QPS</li>
<li><input checked="" disabled="" type="checkbox"> 单进程单线程，是线程安全的，采用IO多路复用机制</li>
<li><input checked="" disabled="" type="checkbox"> 丰富的数据类型，支持String、Hash、List、Set、Sorted Set</li>
<li><input checked="" disabled="" type="checkbox"> 支持数据持久化，可以将内存中数据保存在磁盘中，重启时加载</li>
<li><input checked="" disabled="" type="checkbox"> 主从复制，哨兵模式，高可用</li>
<li><input checked="" disabled="" type="checkbox"> 可以用作分布式锁</li>
<li><input checked="" disabled="" type="checkbox"> 可以进行地图信息分析</li>
<li><input checked="" disabled="" type="checkbox"> 可以作为消息中间件使用，支持发布订阅</li>
<li><input checked="" disabled="" type="checkbox"> 可以作为计数器使用，记录网页或者小程序等的浏览量</li>
<li><input checked="" disabled="" type="checkbox"> ······</li>
</ul>
<h3 id="2-3-🔰拓展"><a href="#2-3-🔰拓展" class="headerlink" title="2.3 🔰拓展"></a>2.3 🔰拓展</h3><blockquote>
<p>Redis 🆚 Memcache</p>
</blockquote>
<ol>
<li>存储方式上：memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。redis有部分数据存在硬盘上，这样能保证数据的持久性</li>
<li>数据支持类型上：memcache对数据类型的支持简单，只支持简单的key-value，而redis支持五大数据类型和三大特殊数据类型</li>
<li>底层模型上：它们之间底层实现方式以及与客户端之间的应用协议不一样。redis直接构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li>
<li>value的大小：redis可以达到1GB，而memcache只有1MB</li>
</ol>
<h2 id="3-📩Redis安装"><a href="#3-📩Redis安装" class="headerlink" title="3. 📩Redis安装"></a>3. 📩Redis安装</h2><blockquote>
<p>⚠️ notice</p>
</blockquote>
<ul>
<li><p>Github上redis的windows版本已经很久不再更新，对于最新的3.2.100版本，个人使用过，redis-cli.exe使用起来偶尔会出问题，命令写出来那一行会变成黑色，兼容性不太好，由于3.0不支持GEO等操作，我还是选择使用3.2.100版本。</p>
</li>
<li><p>Redis这种高性能服务器本身与CentOS的体质就很般配，个人推荐在Linux上安装，尤其是后期搭建redis集群环境。CentOS7本身自带的yum镜像中带的gcc安装包只有4.8.5版本，不支持高版本redis的编译，所以推荐下载5.0.8版本。</p>
</li>
<li><p>以上，不管是Windows还是Linux，都推荐使用Xshell开启Redis服务器和客户端。</p>
</li>
</ul>
<blockquote>
<p>🔽Xshell</p>
</blockquote>
<ul>
<li>网盘链接：<a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1qWtPzJgF3N24yIlUfTtq9w">https://pan.baidu.com/s/1qWtPzJgF3N24yIlUfTtq9w</a></li>
<li>提取码：kkkk</li>
</ul>
<h3 id="3-1-💻Windows10-安装"><a href="#3-1-💻Windows10-安装" class="headerlink" title="3.1 💻Windows10 安装"></a>3.1 💻Windows10 安装</h3><blockquote>
<p>下载: <a target="_blank" rel="noopener" href="https://github.com/MSOpenTech/redis/releases">redis</a></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008213905860.png" class="" title="image-20201008213905860">

<blockquote>
<p>解压</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008214011620.png" class="" title="image-20201008214011620">

<blockquote>
<p>启动</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008214053586.png" class="" title="image-20201008214053586">



<h3 id="3-2-💻CentOS7-安装"><a href="#3-2-💻CentOS7-安装" class="headerlink" title="3.2 💻CentOS7 安装"></a>3.2 💻CentOS7 安装</h3><blockquote>
<p>安装gcc: <code>yum install gcc-c++ tcl</code></p>
<p>注意安装 version&gt;6 的redis需要 version&gt;5 的gcc: </p>
<p><code>sudo yum install centos-release-scl</code><br><code>sudo yum install devtoolset-7-gcc*</code><br><code>scl enable devtoolset-7 bash</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008224757570.png" class="" title="image-20201008224757570">

<blockquote>
<p>下载压缩包: <code>wget http://download.redis.io/releases/redis-5.0.8.tar.gz</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008223909191.png" class="" title="image-20201008223909191">

<blockquote>
<p>解压压缩包: <code>tar xzf redis-5.0.8.tar.gz</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008224102401.png" class="" title="image-20201008224102401">

<blockquote>
<p>跳转目录: <code>cd redis-5.0.8</code>    </p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008215145306.png" class="" title="image-20201008215145306">

<blockquote>
<p>编译安装: <code>make</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008215335902.png" class="" title="image-20201008215335902">

<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008224230979.png" class="" title="image-20201008224230979">

<blockquote>
<p>再次编译: <code>make</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008224450296.png" class="" title="image-20201008224450296">

<blockquote>
<p>最后安装: </p>
<p><code>cd src/</code></p>
<p><code>make install</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008230537427.png" class="" title="image-20201008230537427">

<blockquote>
<p>查看结果: <code>ll /usr/local/bin/</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201008230723447.png" class="" title="image-20201008230723447">

<blockquote>
<p>更改配置:</p>
<p>新建配置文件目录: <code>mkdir kconfig</code>   </p>
<p>将原生Redis配置文件复制进来: <code>cp /home/parak/Redis/redis-5.0.8/redis.conf </code></p>
<p>修改配置文件: <code>gedit redis.conf</code> </p>
<pre><code>daemonize yes</code></pre>
</blockquote>
<blockquote>
<p>测试启动: <code>redis-server kconfig/redis.conf</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009105138976.png" class="" title="image-20201009105138976">

<blockquote>
<p>查看redis进程: <code>ps -ef | grep redis</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009105424943.png" class="" title="image-20201009105424943">

<blockquote>
<p>关闭redis服务: <code>shutdown</code></p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009105552015.png" class="" title="image-20201009105552015">



<h2 id="4-📩Redis配置"><a href="#4-📩Redis配置" class="headerlink" title="4. 📩Redis配置"></a>4. 📩Redis配置</h2><h3 id="4-1-🚩命令"><a href="#4-1-🚩命令" class="headerlink" title="4.1 🚩命令"></a>4.1 🚩命令</h3><blockquote>
<p>👀查看所有配置项</p>
</blockquote>
<pre><code class="shell">config get *</code></pre>
<blockquote>
<p>✏命令行编辑配置</p>
</blockquote>
<pre><code class="shell">config set &lt;option&gt; &lt;value&gt;</code></pre>
<h3 id="4-2-📝redis-conf-配置项说明"><a href="#4-2-📝redis-conf-配置项说明" class="headerlink" title="4.2 📝redis.conf 配置项说明"></a>4.2 📝redis.conf 配置项说明</h3><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">配置项</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><code>daemonize no</code></td>
<td align="left">Redis 默认不是以守护进程的方式运行，可以通过该配置项修改，使用 yes 启用守护进程（Windows 不支持守护线程的配置为 no ）</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><code>pidfile /var/run/redis.pid</code></td>
<td align="left">当 Redis 以守护进程方式运行时，Redis 默认会把 pid 写入 /var/run/redis.pid 文件，可以通过 pidfile 指定</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><code>port 6379</code></td>
<td align="left">指定 Redis 监听端口，默认端口为 6379</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><code>bind 127.0.0.1</code></td>
<td align="left">绑定的主机地址</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><code>timeout 300</code></td>
<td align="left">当客户端闲置多长秒后关闭连接，如果指定为 0 ，表示关闭该功能</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><code>loglevel notice</code></td>
<td align="left">指定日志记录级别，Redis 总共支持四个级别：debug、verbose、notice、warning，默认为 notice</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><code>logfile stdout</code></td>
<td align="left">日志记录方式，默认为标准输出，如果配置 Redis 为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给 /dev/null</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><code>databases 16</code></td>
<td align="left">设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><code>save  </code>Redis 默认配置文件中提供了三个条件：<strong>save 900 1</strong>、<strong>save 300 10</strong> 、<strong>save 60 10000</strong>分别表示 900 秒（15 分钟）内有 1 个更改，300 秒（5 分钟）内有 10 个更改以及 60 秒内有 10000 个更改。</td>
<td align="left">指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><code>rdbcompression yes</code></td>
<td align="left">指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><code>dbfilename dump.rdb</code></td>
<td align="left">指定本地数据库文件名，默认值为 dump.rdb</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><code>dir ./</code></td>
<td align="left">指定本地数据库存放目录</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><code>slaveof  </code></td>
<td align="left">设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，在 Redis 启动时，它会自动从 master 进行数据同步</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><code>masterauth </code></td>
<td align="left">当 master 服务设置了密码保护时，slav 服务连接 master 的密码</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><code>requirepass foobared</code></td>
<td align="left">设置 Redis 连接密码，如果配置了连接密码，客户端在连接 Redis 时需要通过 AUTH <password> 命令提供密码，默认关闭</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><code> maxclients 128</code></td>
<td align="left">设置同一时间最大客户端连接数，默认无限制，Redis 可以同时打开的客户端连接数为 Redis 进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis 会关闭新的连接并向客户端返回 max number of clients reached 错误信息</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><code>maxmemory </code></td>
<td align="left">指定 Redis 最大内存限制，Redis 在启动时会把数据加载到内存中，达到最大内存后，Redis 会先尝试清除已到期或即将到期的 Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><code>appendonly no</code></td>
<td align="left">指定是否在每次更新操作后进行日志记录，Redis 在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis 本身同步数据文件是按上面 save 条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为 no</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><code>appendfilename appendonly.aof</code></td>
<td align="left">指定更新日志文件名，默认为 appendonly.aof</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><code>appendfsync everysec</code></td>
<td align="left">指定更新日志条件，共有 3 个可选值：<strong>no</strong>：表示等操作系统进行数据缓存同步到磁盘（快）<strong>always</strong>：表示每次更新操作后手动调用 fsync() 将数据写到磁盘（慢，安全）<strong>everysec</strong>：表示每秒同步一次（折中，默认值）</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left"><code>vm-enabled no</code></td>
<td align="left">指定是否启用虚拟内存机制，默认值为 no，简单的介绍一下，VM 机制将数据分页存放，由 Redis 将访问量较少的页即冷数据 swap 到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析 Redis 的 VM 机制）</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left"><code>vm-swap-file /tmp/redis.swap</code></td>
<td align="left">虚拟内存文件路径，默认值为 /tmp/redis.swap，不可多个 Redis 实例共享</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left"><code>vm-max-memory 0</code></td>
<td align="left">将所有大于 vm-max-memory 的数据存入虚拟内存，无论 vm-max-memory 设置多小，所有索引数据都是内存存储的(Redis 的索引数据 就是 keys)，也就是说，当 vm-max-memory 设置为 0 的时候，其实是所有 value 都存在于磁盘。默认值为 0</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left"><code>vm-page-size 32</code></td>
<td align="left">Redis swap 文件分成了很多的 page，一个对象可以保存在多个 page 上面，但一个 page 上不能被多个对象共享，vm-page-size 是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page 大小最好设置为 32 或者 64bytes；如果存储很大大对象，则可以使用更大的 page，如果不确定，就使用默认值</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left"><code>vm-pages 134217728</code></td>
<td align="left">设置 swap 文件中的 page 数量，由于页表（一种表示页面空闲或使用的 bitmap）是在放在内存中的，，在磁盘上每 8 个 pages 将消耗 1byte 的内存。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left"><code>vm-max-threads 4</code></td>
<td align="left">设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left"><code>glueoutputbuf yes</code></td>
<td align="left">设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left"><code>hash-max-zipmap-entries 64 hash-max-zipmap-value 512</code></td>
<td align="left">指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left"><code>activerehashing yes</code></td>
<td align="left">指定是否激活重置哈希，默认为开启（后面在介绍 Redis 的哈希算法时具体介绍）</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left"><code>include /path/to/local.conf</code></td>
<td align="left">指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</td>
</tr>
</tbody></table>
<h3 id="4-3-🔍-重点详解"><a href="#4-3-🔍-重点详解" class="headerlink" title="4.3 🔍 重点详解"></a>4.3 🔍 重点详解</h3><ol>
<li><p>UNIT: redis对大小写不敏感</p>
</li>
<li><p>INCLUEDS[模块]: 可以包含多个配置文件</p>
</li>
<li><p>MOUDLES[模块]: 启动时加载模块</p>
</li>
<li><p>NETWORK[网络]: </p>
<ul>
<li>bind: 绑定IP</li>
<li>protected-mode: 保护模式</li>
<li>post: 端口设置</li>
</ul>
</li>
<li><p>GENERAL[通用]: </p>
<ul>
<li>daemonize: 是否以守护进程的方式运行<a href="%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B">^1</a></li>
<li>pidfile /var/run/redis_6379.pid: 如果以后台的方式运行，就需要指定一个pid的配置文件</li>
<li>loglevel: 日志级别</li>
<li>logfile: 日志的文件位置</li>
<li>database: 数据库的数量</li>
<li>always-show-logo: 是否开启服务的时候显示logo</li>
</ul>
</li>
<li><p>SNAPSHOTTING[快照]:</p>
<ul>
<li>save 900 1: 如果在900s内，至少有1个key进行了修改，就进行持久化操作</li>
<li>save 300 10: 如果在300s内，至少有10个key进行了修改，就进行持久化操作</li>
<li>save 60 10000: 如果在60s内，至少有10000个key进行了修改，就进行持久化操作</li>
<li>stop-writes-on-bgsave-error: 持久化出现错误，是否让redis继续工作</li>
<li>rdbcompression: 是否压缩rdb文件，需要消耗一些CPU资源</li>
<li>rdbchecksum: 保存rdb的文件的时候，是否进行错误校验</li>
<li>dir: 文件保存的目录</li>
</ul>
</li>
<li><p>REPLICATION[复制]:</p>
<ul>
<li>见主从复制</li>
</ul>
</li>
<li><p>SECURITY[安全]:</p>
<ul>
<li><p>requirepass: 设置密码</p>
</li>
<li><pre><code class="shell"># 设置密码
&gt; config set requirepass &lt;password&gt;
# 登录输入
&gt; auth &lt;password&gt;
# 获取密码
&gt; config get requirepass
# 取消设置
&gt; config set requirepass &#39;&#39;</code></pre>
</li>
</ul>
</li>
<li><p>CLIENTS[客户端]:</p>
<ul>
<li>maxclients: 设置可连接redis的最大客户端数量</li>
<li>maxmemory: 配置redis的最大内存容量</li>
<li>maxmemory-policy: 内存到达上限的处理策略<ul>
<li>volatile-lru：只对设置了过期时间的key进行LRU（默认值） </li>
<li>allkeys-lru ： 删除lru算法的key  </li>
<li>volatile-random：随机删除即将过期key  </li>
<li>allkeys-random：随机删除  </li>
<li>volatile-ttl ： 删除即将过期的  </li>
<li>noeviction ： 永不过期，返回错误</li>
</ul>
</li>
</ul>
</li>
<li><p>APPEND ONLY MODE[AOF]:</p>
<ul>
<li>appendonly: 默认不开启AOF模式</li>
<li>appendfilename: AOF持久化的文件名称</li>
<li>appendfsync always: 每次修改都会同步，消耗性能</li>
<li>appendfsync everysec: 每秒执行一次同步，可能会丢失这1s的数据</li>
<li>appendfsync no: 不执行同步，操作系统自己同步数据，速度最快</li>
</ul>
</li>
</ol>
<h2 id="5-📩Redis测试"><a href="#5-📩Redis测试" class="headerlink" title="5. 📩Redis测试"></a>5. 📩Redis测试</h2><h3 id="5-1🔬测试方法"><a href="#5-1🔬测试方法" class="headerlink" title="5.1🔬测试方法"></a>5.1🔬测试方法</h3><blockquote>
<p>redis的性能测试命令</p>
</blockquote>
<pre><code class="shell">redis-benchmark [option] [option value]</code></pre>
<p>🔔<strong>注意: 这个命令是在redis目录下执行，而非redis客户端的内部命令</strong></p>
<h3 id="5-2-📝redis性能测试工具可选参数"><a href="#5-2-📝redis性能测试工具可选参数" class="headerlink" title="5.2 📝redis性能测试工具可选参数"></a>5.2 📝redis性能测试工具可选参数</h3><table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">选项</th>
<th align="left">描述</th>
<th align="left">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>-h</strong></td>
<td align="left">指定服务器主机名</td>
<td align="left">127.0.0.1</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>-p</strong></td>
<td align="left">指定服务器端口</td>
<td align="left">6379</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>-s</strong></td>
<td align="left">指定服务器 socket</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>-c</strong></td>
<td align="left">指定并发连接数</td>
<td align="left">50</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>-n</strong></td>
<td align="left">指定请求数</td>
<td align="left">10000</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>-d</strong></td>
<td align="left">以字节的形式指定 SET/GET 值的数据大小</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>-k</strong></td>
<td align="left">1=keep alive 0=reconnect</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>-r</strong></td>
<td align="left">SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>-P</strong></td>
<td align="left">通过管道传输 <numreq> 请求</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>-q</strong></td>
<td align="left">强制退出 redis。仅显示 query/sec 值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>–csv</strong></td>
<td align="left">以 CSV 格式输出</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>-l</strong></td>
<td align="left">生成循环，永久执行测试</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>-t</strong></td>
<td align="left">仅运行以逗号分隔的测试命令列表。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>-I</strong></td>
<td align="left">Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="5-3-📊测试结果分析"><a href="#5-3-📊测试结果分析" class="headerlink" title="5.3 📊测试结果分析"></a>5.3 📊测试结果分析</h3><pre><code class="shell">redis-benchmark -h 127.0.0.1 -p 6379 -c 100 -n 100000 </code></pre>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009193727448.png" class="" title="image-20201009193727448">

<pre><code class="shell">redis-benchmark -h 127.0.0.1 -p 6379 -c 1 -n 100000 -q</code></pre>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201009194004617.png" class="" title="image-20201009194004617">

<p>这个是对所有操作测试性能，每秒处理的请求数量。</p>
<h2 id="6-📩Redis基础"><a href="#6-📩Redis基础" class="headerlink" title="6. 📩Redis基础"></a>6. 📩Redis基础</h2><h3 id="6-1-💠Redis数据库"><a href="#6-1-💠Redis数据库" class="headerlink" title="6.1 💠Redis数据库"></a>6.1 💠Redis数据库</h3><p><strong>redis有16个数据库，默认使用第0个</strong></p>
<blockquote>
<p>测试连接</p>
</blockquote>
<pre><code class="shell">ping</code></pre>
<blockquote>
<p>关闭连接</p>
</blockquote>
<pre><code class="shell">quit</code></pre>
<blockquote>
<p>返回消息</p>
</blockquote>
<pre><code class="shell">echo &lt;str&gt;</code></pre>
<blockquote>
<p>切换数据库</p>
</blockquote>
<pre><code class="bash">select &lt;num of database&gt;</code></pre>
<blockquote>
<p>获取当前数据库的大小</p>
</blockquote>
<pre><code class="shell">dbsize</code></pre>
<blockquote>
<p>清空当前数据库</p>
</blockquote>
<pre><code class="shell">flushdb</code></pre>
<blockquote>
<p>清空所有数据库</p>
</blockquote>
<pre><code class="shell">flushall</code></pre>
<blockquote>
<p>交换数据库</p>
</blockquote>
<pre><code class="shell">swap &lt;n1&gt; &lt;n2&gt;</code></pre>
<h3 id="6-2-🌏6379的故事"><a href="#6-2-🌏6379的故事" class="headerlink" title="6.2 🌏6379的故事"></a>6.2 🌏6379的故事</h3><p><strong>redis默认端口号为6379</strong></p>
<blockquote>
<p>作者在自己的一篇博文中解释了为什么选用 6379 作为默认端口，因为 6379 在手机按键上 MERZ 对应的号码，而 MERZ 取自意大利歌女 Alessia Merz 的名字。MERZ长期以来被Redis作者antirez及其朋友当作愚蠢的代名词，后来作者在开发Redis就选用了这个端口。</p>
</blockquote>
<h3 id="6-3-⚡Redis蜜汁速度"><a href="#6-3-⚡Redis蜜汁速度" class="headerlink" title="6.3 ⚡Redis蜜汁速度"></a>6.3 ⚡Redis蜜汁速度</h3><p><strong>redis是单线程的。</strong></p>
<p>redis基于内存操作，CPU不是redis的性能瓶颈，Redis的瓶颈很可能是机器内存或者网路带宽。</p>
<p>既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程实现。</p>
<blockquote>
<p>💉理解Redis蜜汁速度需要跨过两个误区</p>
</blockquote>
<ul>
<li><p>误区1：高性能的服务器一定是多线程的？</p>
</li>
<li><p>误区2：多线程的效率一定比单线程高？</p>
</li>
</ul>
<blockquote>
<p>💊Redis采用单线程依然快的原因</p>
</blockquote>
<ol>
<li>Redis完全基于内存，读写全部在一个CPU上，绝大部分请求是纯粹的内存操作，非常迅速，数据存在于内存中，类似于HashMap，HashMap的优势就是查询和操作的时间复杂度时O(1)</li>
<li>数据结构简单，对数据操作也简单</li>
<li>采用单线程，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用取考虑各种锁的问题，不存在加锁放锁操作，没有死锁问题导致的性能消耗</li>
<li>使用多路复用IO模型，非阻塞IO</li>
</ol>
<h2 id="7-📩Redis数据类型"><a href="#7-📩Redis数据类型" class="headerlink" title="7. 📩Redis数据类型"></a>7. 📩Redis数据类型</h2><blockquote>
<p>🌞说明</p>
</blockquote>
<p>所有命令可查看中文官方文档: <a target="_blank" rel="noopener" href="http://redis.cn/commands.html#">http://redis.cn/commands.html#</a></p>
<h3 id="7-1-🏆五大数据类型"><a href="#7-1-🏆五大数据类型" class="headerlink" title="7.1 🏆五大数据类型"></a>7.1 🏆五大数据类型</h3><table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">简介</th>
<th align="center">特性</th>
<th align="center">场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String(字符串)</td>
<td align="center">二进制安全</td>
<td align="center">可以包含任何数据，比如jpg图片或者序列化对象</td>
<td align="center">—</td>
</tr>
<tr>
<td align="center">Hash(字典)</td>
<td align="center">键值对集合</td>
<td align="center">适合存储对象，并且可以像数据库中的update一个属性一样值修改某一项属性值</td>
<td align="center">存储、读取、修改用户属性</td>
</tr>
<tr>
<td align="center">List(列表)</td>
<td align="center">双向链表</td>
<td align="center">增删快，提供了操作某一元素的api</td>
<td align="center">最新消息排行；消息队列</td>
</tr>
<tr>
<td align="center">Set(集合)</td>
<td align="center">hash表实现，元素不重复</td>
<td align="center">增删查快，提供了求交集、并集和差集的操作</td>
<td align="center">共同好友:  利用唯一性，统计网站UV</td>
</tr>
<tr>
<td align="center">Sorted Set(有序集合)</td>
<td align="center">将set中的元素增加一个权重score，元素按照score有序排列</td>
<td align="center">数据插入集合时，已经进行了天然排序</td>
<td align="center">排行榜；带权重的消息队列</td>
</tr>
</tbody></table>
<p><strong>🎲Key</strong></p>
<blockquote>
<p>查看所有的key</p>
</blockquote>
<pre><code class="shell">keys *</code></pre>
<blockquote>
<p>创建键值对</p>
</blockquote>
<pre><code class="shell">set &lt;key&gt; &lt;value&gt;</code></pre>
<blockquote>
<p>获取key的值</p>
</blockquote>
<pre><code class="shell">get &lt;key&gt;</code></pre>
<blockquote>
<p>移除键值对</p>
</blockquote>
<pre><code class="shell">move &lt;key&gt; &lt;value&gt;</code></pre>
<blockquote>
<p>判断key是否存在</p>
</blockquote>
<pre><code class="shell">exists &lt;key&gt;</code></pre>
<blockquote>
<p>查看key的类型</p>
</blockquote>
<pre><code class="shell">type &lt;key&gt;</code></pre>
<blockquote>
<p>设置key的过期时间/秒</p>
</blockquote>
<pre><code class="shell">expire &lt;key&gt; &lt;seconds&gt; </code></pre>
<blockquote>
<p>获取key的有效时间/秒</p>
</blockquote>
<pre><code class="shell">ttl &lt;key&gt;</code></pre>
<blockquote>
<p>获取key的有效时间/毫秒</p>
</blockquote>
<pre><code class="shell">pttl &lt;key&gt;</code></pre>
<h4 id="7-1-1-⚽String"><a href="#7-1-1-⚽String" class="headerlink" title="7.1.1 ⚽String"></a>7.1.1 ⚽String</h4><blockquote>
<p>向key上追加字符串</p>
</blockquote>
<pre><code class="shell">append &lt;key&gt; &lt;value&gt;</code></pre>
<blockquote>
<p>获取key的长度</p>
</blockquote>
<pre><code class="shell">strlen &lt;key&gt;</code></pre>
<blockquote>
<p>Integer操作</p>
</blockquote>
<pre><code class="shell"># 加1
incr &lt;key&gt;
# 加n
incrby &lt;key&gt; n
# 减1
decr &lt;key&gt;
# 减n
decrby &lt;key&gt; n</code></pre>
<blockquote>
<p>subString(start, end)操作</p>
</blockquote>
<pre><code class="shell"># 截取整个字符串
getrange &lt;key&gt; 0 -1
# 截取部分字符串
getrange &lt;key&gt; start end
# 例如
&gt; set s &quot;Khighness&quot;
&gt; getrange s 0 -1 # &quot;Khighness&quot;
&gt; getrange s 1 4  # &quot;high&quot;</code></pre>
<blockquote>
<p>replace(start, end)操作</p>
</blockquote>
<pre><code class="shell"># 把字符串从n位开始之后的字符替换为新的字符串newStr
setrange &lt;key&gt; n newStr
# 例如
&gt; set s &quot;Khighness&quot;
&gt; setrange s 0 X 
&gt; get s # &quot;Xhighness&quot;
&gt; setrange s 5 &quot;XXXXX&quot;
&gt; get s # &quot;XhighXXXXX&quot;</code></pre>
<blockquote>
<p>setex (set with expire) 创建键值对的同时设置过期时间</p>
<p>setnx (set if not exist)  如果key不存在则创建键值对，防止覆盖原有键值对 (分布式锁中经常使用)</p>
</blockquote>
<pre><code class="shell"># 设置键值对，设置过期时间
setex &lt;key&gt; &lt;seconds&gt; &lt;value&gt;
# key不存在，则创建键值对
setnx &lt;key&gt; &lt;value&gt;

# 例如
127.0.0.1:6379&gt; setex k1 10 parak
OK
127.0.0.1:6379&gt; ttl k1
(integer) 5
127.0.0.1:6379&gt; ttl k1
(integer) 3
127.0.0.1:6379&gt; ttl k1
(integer) 2
127.0.0.1:6379&gt; ttl k1
(integer) 2
127.0.0.1:6379&gt; ttl k1
(integer) 1
127.0.0.1:6379&gt; ttl k1
(integer) -2
127.0.0.1:6379&gt; get k1
(nil)

127.0.0.1:6379&gt; setnx k2 parak
(integer) 1 # 1代表设置成功
127.0.0.1:6379&gt; setnx k2 flowerk
(integer) 0 # 0代表设置失败
127.0.0.1:6379&gt; get k2
&quot;parak&quot;     
127.0.0.1:6379&gt; setnx k2 FlowerK
(integer) 0 
127.0.0.1:6379&gt; set k2 FlowerK
OK          # 强制设置value
127.0.0.1:6379&gt; get k2
&quot;FlowerK&quot;</code></pre>
<blockquote>
<p>多个键值对操作</p>
</blockquote>
<pre><code class="shell"># 一次性创建多个键值对
mset &lt;key&gt; &lt;value&gt; [key value ...]
# 获取多个key的值
meget &lt;key&gt; [key ...]
# 不存在则创建多个键值对
# 原子性操作，只要其中有一个key已存在，就会全部创建失败
msetnx &lt;key&gt; &lt;value&gt; [key value ...]

# 例如
127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3
OK
127.0.0.1:6379&gt; mget k1 k2 k3
1) &quot;v1&quot;
2) &quot;v2&quot;
3) &quot;v3&quot;
127.0.0.1:6379&gt; msetnx k2 v2 k4 v4 k5 v5
(integer) 0
127.0.0.1:6379&gt; keys *
1) &quot;k2&quot;
2) &quot;k3&quot;
3) &quot;k1&quot;

# 巧妙设计key  object:&#123;id&#125;:&#123;field&#125;
127.0.0.1:6379&gt; mset user:1:name Khighness user:1:age 18
OK
127.0.0.1:6379&gt; mget user:1:name user:1:age
1) &quot;Khighness&quot;
2) &quot;18&quot;
</code></pre>
<blockquote>
<p>组合操作</p>
</blockquote>
<pre><code class="shell"># 先获取值，再设置新的值
getset k v</code></pre>
<h4 id="7-1-2-⚾List"><a href="#7-1-2-⚾List" class="headerlink" title="7.1.2 ⚾List"></a>7.1.2 ⚾List</h4><p>redis里面，list可以当成栈、队列、队列。</p>
<blockquote>
<p>向list的头部添加值</p>
</blockquote>
<pre><code class="shell">lpush &lt;key&gt; value [value ...]</code></pre>
<blockquote>
<p>向list的尾部添加值</p>
</blockquote>
<pre><code class="shell">rpush &lt;key&gt; value [value ...]</code></pre>
<blockquote>
<p>判断list是否存在</p>
</blockquote>
<pre><code class="shell">exists &lt;key&gt;</code></pre>
<blockquote>
<p>移除列表的第一个元素</p>
</blockquote>
<pre><code class="shell">lpop &lt;key&gt; </code></pre>
<blockquote>
<p>移除列表的最后一个元素</p>
</blockquote>
<pre><code class="shell">rpop &lt;key&gt; </code></pre>
<blockquote>
<p>移除指定的值</p>
</blockquote>
<pre><code class="shell">lrem &lt;key&gt; &lt;count&gt; &lt;value&gt;</code></pre>
<blockquote>
<p>更新list</p>
</blockquote>
<pre><code class="shell"># 根据index更新值
lset &lt;key&gt; &lt;index&gt; &lt;value&gt;</code></pre>
<blockquote>
<p>根据下标获取值</p>
</blockquote>
<pre><code class="shell">lindex &lt;key&gt; &lt;index&gt;</code></pre>
<blockquote>
<p>获取list的长度</p>
</blockquote>
<pre><code class="shell">llen &lt;key&gt;</code></pre>
<blockquote>
<p>获取list指定范围的值</p>
</blockquote>
<pre><code class="shell"># 获取整个list的值
lrange &lt;key&gt; 0 -1
# 获取指定范围的值
lrange &lt;key&gt; start end

# 例如
127.0.0.1:6379&gt; lpush list1 1 2 3 4 5 
(integer) 5
127.0.0.1:6379&gt; lrange list1 0 -1
1) &quot;5&quot;
2) &quot;4&quot;
3) &quot;3&quot;
4) &quot;2&quot;
5) &quot;1&quot;
127.0.0.1:6379&gt; lrange list1 0 1
1) &quot;5&quot;
2) &quot;4&quot;
127.0.0.1:6379&gt; rpush list2 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; lrange list2 0 -1
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;3&quot;
4) &quot;4&quot;
5) &quot;5&quot;
127.0.0.1:6379&gt; lrange list2 0 1
1) &quot;1&quot;
2) &quot;2&quot;</code></pre>
<blockquote>
<p>截取list中指定范围的值</p>
</blockquote>
<pre><code class="shell"># 保留下标[start, end]的值
ltrim &lt;key&gt; start end

# 例如
127.0.0.1:6379&gt; rpush list parak1 parak2 parak3 parak4 parak5
(integer) 5
127.0.0.1:6379&gt; ltrim list 0 2
OK
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;parak1&quot;
2) &quot;parak2&quot;
3) &quot;parak3&quot;</code></pre>
<blockquote>
<p>组合操作</p>
</blockquote>
<pre><code class="shell"># 移除source的尾部的值插入到destination的头部
rpoplpush &lt;source&gt; &lt;destination&gt;

# 例如
127.0.0.1:6379&gt; rpush list 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; rpoplpush list newlist
&quot;5&quot;
127.0.0.1:6379&gt; lrange newlist 0 -1
1) &quot;5&quot;</code></pre>
<blockquote>
<p>在list中插入值</p>
</blockquote>
<pre><code class="shell"># 在list中的某个值之前插入
linsert &lt;key&gt; before &lt;priot&gt; &lt;value&gt;
# 在list中的某个值之后插入
linsert &lt;key&gt; after &lt;priot&gt; &lt;value&gt;

# 例如
127.0.0.1:6379&gt; rpush list 1 2 3 4 5
(integer) 5
127.0.0.1:6379&gt; linsert list before 3 6
(integer) 6
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;6&quot;
4) &quot;3&quot;
5) &quot;4&quot;
6) &quot;5&quot;
127.0.0.1:6379&gt; linsert list after 5 7
(integer) 7
127.0.0.1:6379&gt; lrange list 0 -1
1) &quot;1&quot;
2) &quot;2&quot;
3) &quot;6&quot;
4) &quot;3&quot;
5) &quot;4&quot;
6) &quot;5&quot;
7) &quot;7&quot;</code></pre>
<h4 id="7-1-3-🏀Set"><a href="#7-1-3-🏀Set" class="headerlink" title="7.1.3 🏀Set"></a>7.1.3 🏀Set</h4><p>set 无序不重复集合</p>
<ul>
<li>set通过哈希表实现，所有增删查的时间复杂度是O(1)</li>
</ul>
<blockquote>
<p>向set中国添加值</p>
</blockquote>
<pre><code class="shell">sadd &lt;key&gt; &lt;value&gt; [value ...]</code></pre>
<blockquote>
<p>查看set中的所有值</p>
</blockquote>
<pre><code class="shell">smembers &lt;key&gt;</code></pre>
<blockquote>
<p>查看set中是否包含值value</p>
</blockquote>
<pre><code class="shell">sismember &lt;key&gt; &lt;value&gt;</code></pre>
<blockquote>
<p>获取set中的元素个数</p>
</blockquote>
<pre><code class="shell">scard &lt;key&gt;</code></pre>
<blockquote>
<p>移除set中的值value</p>
</blockquote>
<pre><code class="shell">srem &lt;key&gt; &lt;value&gt;</code></pre>
<blockquote>
<p>获取set中的随机值(可以做抽奖功能)</p>
</blockquote>
<pre><code class="shell">srandmember &lt;key&gt;</code></pre>
<blockquote>
<p>随机移除set中的元素</p>
</blockquote>
<pre><code class="shell">spop &lt;key&gt;</code></pre>
<blockquote>
<p>将一个set集合中指定的值移动到另一个set集合</p>
</blockquote>
<pre><code class="shell"># 将source中的value移动到destination
smove &lt;source&gt; &lt;destination&gt; &lt;value&gt;

# 例如
127.0.0.1:6379&gt; sadd set k1 k2 k3 k4 k5 k6 k7
(integer) 7
127.0.0.1:6379&gt; sadd newset k1
(integer) 1
127.0.0.1:6379&gt; smove set newset k3
(integer) 1
127.0.0.1:6379&gt; smembers newset
1) &quot;k3&quot;
2) &quot;k1&quot;</code></pre>
<blockquote>
<p>集合运算</p>
</blockquote>
<pre><code class="shell"># 集合s1和s2的并集
sunion &lt;s1&gt; &lt;s&gt;
# 集合s1和s2的交集 (实现共同好友、共同关注)
sinter &lt;s1&gt; &lt;s2&gt;
# 集合s1中独有的元素
sdiff &lt;s1&gt; &lt;s2&gt;

# 例如
127.0.0.1:6379&gt; sadd s1 k1 k2 k3 k4 k5 k6
(integer) 6
127.0.0.1:6379&gt; sadd s2 k5 k6 k7 k8 k9 k10
(integer) 6
127.0.0.1:6379&gt; sunion s1 s2
 1) &quot;k5&quot;
 2) &quot;k6&quot;
 3) &quot;k8&quot;
 4) &quot;k2&quot;
 5) &quot;k3&quot;
 6) &quot;k1&quot;
 7) &quot;k4&quot;
 8) &quot;k7&quot;
 9) &quot;k10&quot;
10) &quot;k9&quot;
127.0.0.1:6379&gt; sinter s1 s2
1) &quot;k5&quot;
2) &quot;k6&quot;
127.0.0.1:6379&gt; sdiff s1 s2
1) &quot;k2&quot;
2) &quot;k1&quot;
3) &quot;k3&quot;
4) &quot;k4&quot;</code></pre>
<h4 id="7-1-4-🏈Hash"><a href="#7-1-4-🏈Hash" class="headerlink" title="7.1.4 🏈Hash"></a>7.1.4 🏈Hash</h4><p>相当于key-HashMap，value为一个map集合，更适合于对象的存储，多用于存储变更数据、</p>
<blockquote>
<p>设置key指定的哈希集中指定字段的值</p>
</blockquote>
<pre><code class="shell">hset &lt;key&gt; &lt;field&gt; &lt;value&gt; </code></pre>
<blockquote>
<p>key指定的哈希集中不存在指定字段时，设置字段的值</p>
</blockquote>
<pre><code class="shell">hsetnx &lt;key&gt; &lt;field&gt; &lt;value&gt;</code></pre>
<blockquote>
<p>删除key指定的哈希集中指定字段</p>
</blockquote>
<pre><code class="shell">hdel &lt;key&gt; &lt;field&gt; [field ...]</code></pre>
<blockquote>
<p>判断key指定哈希集中指定字段是否存在</p>
</blockquote>
<pre><code class="shell">hexists &lt;key&gt; &lt;field&gt;</code></pre>
<blockquote>
<p>对key指定的哈希集中指定字段的值加上增量(Integer型，可正可负，字段不存在则在操作执行前把该字段的值设置为0)</p>
</blockquote>
<pre><code class="shell">hincrby &lt;key&gt; &lt;field&gt; &lt;integer&gt;</code></pre>
<blockquote>
<p>对key指定的哈希集中指定字段的值加上增量(float型，可正可负，字段不存在则在操作执行前把该字段的值设置为0)</p>
</blockquote>
<pre><code class="shell">hincrbyfloat &lt;key&gt; &lt;field&gt; &lt;float&gt;</code></pre>
<blockquote>
<p>获取key指定的哈希集中字段数量</p>
</blockquote>
<pre><code class="shell">hlen &lt;key&gt; </code></pre>
<blockquote>
<p>获取key指定的哈希集中指定字段的值的字符串长度</p>
</blockquote>
<pre><code class="shell">hstrlen hash &lt;key&gt; &lt;value&gt; </code></pre>
<blockquote>
<p>key指定的哈希集操作</p>
</blockquote>
<pre><code class="shell"># 设置key指定的哈希集中指定字段的值
hmset &lt;key&gt; &lt;field&gt; &lt;value&gt; [field value ...]
# 获取key指定的哈希集中指定字段所关联的值
hmget &lt;key&gt; &lt;field&gt; [field ...]
# 获取key指定的哈希集中所有字段的名字
hkeys
# 获取key指定哈希集中所有字段的值
hvals
# 获取key指定的哈希集中所有的字段和值
hgetall

# 例如
127.0.0.1:6379&gt; hmset hash field1 hello field2 world
OK
127.0.0.1:6379&gt; hmget hash field1 field2
1) &quot;hello&quot;
2) &quot;world&quot;
127.0.0.1:6379&gt; hkeys hash
1) &quot;field1&quot;
2) &quot;field2&quot;
127.0.0.1:6379&gt; hvals hash
1) &quot;hello&quot;
2) &quot;world&quot;
127.0.0.1:6379&gt; hgetall hash
1) &quot;field1&quot;
2) &quot;hello&quot;
3) &quot;field2&quot;
4) &quot;world&quot;</code></pre>
<h4 id="7-1-5-🏉Sorted-Set"><a href="#7-1-5-🏉Sorted-Set" class="headerlink" title="7.1.5 🏉Sorted Set"></a>7.1.5 🏉Sorted Set</h4><p>有序集合sorted set，集合中每个元素都会关联一个double类型的分数。</p>
<ul>
<li><p>redis通过分数对集合中的成员进行排序。</p>
</li>
<li><p>有序集合中成员是唯一的，分数可以重复。</p>
</li>
<li><p>集合是通过哈希表实现的，所以增删查的事件复杂度都是O(1)。</p>
</li>
<li><p>集合中最大的成员数量为2^32^-1(4294967295)， 每个集合可存储40多亿个成员。</p>
</li>
</ul>
<blockquote>
<p>向key的有序集合中添加序号为number的value</p>
</blockquote>
<pre><code class="she">zadd &lt;key&gt; &lt;number&gt; &lt;value&gt; [number value ...]</code></pre>
<blockquote>
<p>获取key的有序集合中的所有值</p>
</blockquote>
<pre><code class="shell">zrange &lt;key&gt; 0 -1</code></pre>
<blockquote>
<p>获取key的有序集合中的成员数量</p>
</blockquote>
<pre><code class="shell">zcard &lt;key&gt; </code></pre>
<blockquote>
<p>获取key的有序集合中指定下标区间的成员</p>
</blockquote>
<pre><code class="shell">zrange &lt;key&gt; start end</code></pre>
<blockquote>
<p>获取key的有序集合中指定成员member的索引</p>
</blockquote>
<pre><code class="shell">zrank &lt;key&gt; member</code></pre>
<blockquote>
<p>对key的有序集合中指定成员member的分数加上增量</p>
</blockquote>
<pre><code class="shell">zincrby &lt;key&gt; &lt;Integer&gt; member</code></pre>
<blockquote>
<p>获取key的有序集合中指定成员member的分数值</p>
</blockquote>
<pre><code class="shell">zscore &lt;key&gt; member</code></pre>
<blockquote>
<p>获取key的有序集合中指定成员member的排名(从小到大)</p>
</blockquote>
<pre><code class="shell">zrank &lt;key&gt; member</code></pre>
<blockquote>
<p>获取key的有序集合中指定成员member的排名(从大到小)</p>
</blockquote>
<pre><code class="shell">zrevrank &lt;key&gt; member</code></pre>
<blockquote>
<p>获取key的有序集合中分数在指定区间[min,max]的成员数量</p>
</blockquote>
<pre><code class="shell">zcount &lt;key&gt; min max</code></pre>
<blockquote>
<p>通过字典区间获取key的有序集合中的成员数量</p>
</blockquote>
<pre><code class="shell">zlexcount &lt;key&gt; min max</code></pre>
<blockquote>
<p>通过字典区间获取key的有序集合中的成员</p>
</blockquote>
<pre><code class="shell">zrangebylex &lt;key&gt; min max [limit offset count]</code></pre>
<blockquote>
<p>获取key的有序集合中分数在指定区间[min,max]的成员</p>
<blockquote>
<p>参数说明</p>
<ul>
<li>min max<ul>
<li>默认情况下为闭区间，即[min ,max]</li>
<li>也可以是使用开区间，即(min, max)，写法为<code> (min  (max</code></li>
</ul>
</li>
<li>withscores<ul>
<li>返回成员的同时会返回分数</li>
</ul>
</li>
<li>limit offset count<ul>
<li>offset：起始位置，count：从起始位置开始的记录数量</li>
<li>实现分页查询</li>
<li>参数: 页数pagenum，页面大小pagesize</li>
<li>那么实际的offset = (pagenum - 1) * pagesize，count = pagesize</li>
<li>即查询语句为<code>zrangebyscore salary min max withscores limit (pagenum - 1) * pagesize pagesize  </code></li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
<pre><code class="shell">zrangebyscore &lt;key&gt; min max [withscores] [limit offset count]</code></pre>
<blockquote>
<p>例如</p>
</blockquote>
<pre><code class="shell">127.0.0.1:6379&gt; zadd salary -10000 W -20000 F -30000 S
(integer) 3
127.0.0.1:6379&gt; zadd salary 10000 K 20000 A 30000 G
(integer) 3
127.0.0.1:6379&gt; zrangebyscore salary -20000 20000
1) &quot;F&quot;
2) &quot;W&quot;
3) &quot;K&quot;
4) &quot;A&quot;
127.0.0.1:6379&gt; zrangebyscore salary -inf inf 
1) &quot;S&quot;
2) &quot;F&quot;
3) &quot;W&quot;
4) &quot;K&quot;
5) &quot;A&quot;
6) &quot;G&quot;
127.0.0.1:6379&gt; zrangebyscore salary -inf inf withscores
 1) &quot;S&quot;
 2) &quot;-30000&quot;
 3) &quot;F&quot;
 4) &quot;-20000&quot;
 5) &quot;W&quot;
 6) &quot;-10000&quot;
 7) &quot;K&quot;
 8) &quot;10000&quot;
 9) &quot;A&quot;
10) &quot;20000&quot;
11) &quot;G&quot;
12) &quot;30000&quot;
127.0.0.1:6379&gt; zrangebyscore salary -inf inf withscores limit 4 2
1) &quot;G&quot;
2) &quot;30000&quot;
3) &quot;K&quot;
4) &quot;60000&quot;</code></pre>
<blockquote>
<p>删除key的有序集合中的一个或多个成员</p>
</blockquote>
<pre><code class="shell">zrem &lt;key&gt; member [member ...]</code></pre>
<h3 id="7-2-🌌三种特殊类型"><a href="#7-2-🌌三种特殊类型" class="headerlink" title="7.2 🌌三种特殊类型"></a>7.2 🌌三种特殊类型</h3><h4 id="7-2-1-🔮Geospatial"><a href="#7-2-1-🔮Geospatial" class="headerlink" title="7.2.1 🔮Geospatial"></a>7.2.1 🔮Geospatial</h4><p>Geospatial，地理空间，简称GEO，主要用于存储地理位置信息，并对存储的信息进行操作。</p>
<blockquote>
<p>操作方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">geoadd</td>
<td align="center">添加地理位置的坐标</td>
</tr>
<tr>
<td align="center">geopos</td>
<td align="center">获取地理位置的坐标</td>
</tr>
<tr>
<td align="center">geodist</td>
<td align="center">计算两个位置之间的距离</td>
</tr>
<tr>
<td align="center">georadius</td>
<td align="center">根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</td>
</tr>
<tr>
<td align="center">georadiusbymember</td>
<td align="center">根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合</td>
</tr>
<tr>
<td align="center">geohash</td>
<td align="center">返回一个或者多个位置对象的geohash值</td>
</tr>
</tbody></table>
<p>查询地理数据：<a target="_blank" rel="noopener" href="http://www.jsons.cn/lngcode/">城市经纬度查询</a></p>
<blockquote>
<p>测试数据</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">地方</th>
<th align="center">经度</th>
<th align="center">纬度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">黄冈市黄梅县</td>
<td align="center">115.94427</td>
<td align="center">30.07033</td>
</tr>
<tr>
<td align="center">武汉市武昌区</td>
<td align="center">114.31589</td>
<td align="center">30.55389</td>
</tr>
<tr>
<td align="center">北京市丰台区</td>
<td align="center">116.28625</td>
<td align="center">39.8585</td>
</tr>
<tr>
<td align="center">上海市黄浦区</td>
<td align="center">121.49295</td>
<td align="center">31.22337</td>
</tr>
<tr>
<td align="center">合肥市蜀山区</td>
<td align="center">117.26104</td>
<td align="center">31.85117</td>
</tr>
<tr>
<td align="center">深圳市南山区</td>
<td align="center">113.93029</td>
<td align="center">22.53291</td>
</tr>
<tr>
<td align="center">大连市中山区</td>
<td align="center">121.64465</td>
<td align="center">38.91859</td>
</tr>
<tr>
<td align="center">广州市天河区</td>
<td align="center">113.36112</td>
<td align="center">23.12467</td>
</tr>
</tbody></table>
<p>1️⃣<strong>geoadd</strong></p>
<blockquote>
<p>描述</p>
</blockquote>
<p>geoadd用于存储指定的地理位置空间，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的key中。</p>
<blockquote>
<p>语法</p>
</blockquote>
<pre><code class="shell">geoadd &lt;key&gt; longitude latitude member [longtitude latitude member ...]</code></pre>
<blockquote>
<p>规则</p>
</blockquote>
<ul>
<li>两级无法直接添加</li>
<li>有效经度：-180 - 180</li>
<li>有效纬度：-85.05112878 - 85.05112878</li>
</ul>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell">127.0.0.1:6379&gt; geoadd china:city 115.94427 30.07033 huanggang
(integer) 1
127.0.0.1:6379&gt; geoadd china:city 114.31589 30.55389 wuhan
(integer) 1
127.0.0.1:6379&gt; geoadd china:city 116.28625 39.8585 beijing
(integer) 1
127.0.0.1:6379&gt; geoadd china:city 121.49295 31.22337 shanghai
(integer) 1
127.0.0.1:6379&gt; geoadd china:city 117.26104 31.85117 hefei
(integer) 1
127.0.0.1:6379&gt; geoadd china:city 113.93029 22.53291 shenzhen
(integer) 1
127.0.0.1:6379&gt; geoadd china:city 121.64465 38.91859 dalian
(integer) 1
127.0.0.1:6379&gt; geoadd china:city 113.36112 23.12467 guangzhou
(integer) 1</code></pre>
<p>实际应用中，一般会把城市地理数据写在文件中，直接通过java程序一次性导入。</p>
<p>2️⃣<strong>geopos</strong></p>
<blockquote>
<p>描述</p>
</blockquote>
<p>geopos用于从给定的key里返回所有指定名称(member)的位置(经度和纬度)，不存在的返回nil。</p>
<blockquote>
<p>语法</p>
</blockquote>
<pre><code class="shell">geopos &lt;key&gt; member [member ...]</code></pre>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell">127.0.0.1:6379&gt; geopos china:city huanggang shenzhen shanghai 
1) 1) &quot;115.94427019357681274&quot;
   2) &quot;30.07033115798519418&quot;
2) 1) &quot;113.93029063940048218&quot;
   2) &quot;22.53290942281488896&quot;
3) 1) &quot;121.49295061826705933&quot;
   2) &quot;31.22337074392616074&quot;</code></pre>
<p>3️⃣<strong>geodist</strong></p>
<blockquote>
<p>描述</p>
</blockquote>
<p>geodist用于计算两个给定位置之间的距离。</p>
<blockquote>
<p>语法</p>
</blockquote>
<pre><code class="shell">geodist &lt;key&gt; member1 member2 [m|km|ft|mi]</code></pre>
<p>参数说明：</p>
<ul>
<li>member1和member2为两个地理位置</li>
<li>m：米，默认位置</li>
<li>km：千米</li>
<li>mi：英里</li>
<li>ft：英尺</li>
</ul>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell">127.0.0.1:6379&gt; geodist china:city huanggang shenzhen
&quot;862016.4959&quot;
127.0.0.1:6379&gt; geodist china:city huanggang hefei km
&quot;234.5308&quot;
127.0.0.1:6379&gt; geodist china:city shanghai dalian mi
&quot;531.9085&quot;</code></pre>
<p>4️⃣<strong>georadius</strong></p>
<blockquote>
<p>描述</p>
</blockquote>
<p>给定一个中心的地理位置(经度和纬度)，给定一个最大距离，返回给定的key包含的位置元素中，与中心的距离不超过最大距离的所有位置元素。</p>
<blockquote>
<p>语法</p>
</blockquote>
<pre><code class="shell">georadius &lt;key&gt; longitude latitude radius m|km|ft|mi [withcoord] [withdist] [withhash] [count] [asc|desc] [store key] [storedist key]</code></pre>
<p>参数说明：</p>
<ul>
<li><p>longitude：给定中心的经度</p>
</li>
<li><p>latitude：给定中心的纬度</p>
</li>
<li><p>radius：给定的最大距离</p>
</li>
<li><p>withcoord：返回+(位置元素的经度和纬度)</p>
</li>
<li><p>withdist：返回+(位置元素与中心之间的距离)</p>
</li>
<li><p>withhash：以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</p>
</li>
<li><p>count：限定返回的记录数量</p>
</li>
<li><p>asc：查找结果根据距离从小到大排序</p>
</li>
<li><p>desc：查找结果根据距离从大到小排序</p>
</li>
</ul>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell"># 查看距离广州不大于1000km的城市
127.0.0.1:6379&gt; georadius china:city 113.36112 23.12467 1000 km asc
1) &quot;guangzhou&quot;
2) &quot;shenzhen&quot;
3) &quot;huanggang&quot;
4) &quot;wuhan&quot;
# 查看距离武汉不大于1000km的城市，从大到小，限制5个，并且显示距离和城市经纬度
127.0.0.1:6379&gt; georadius china:city 114.31589 30.55389 1000 km withcoord withdist count 5 desc 
1) 1) &quot;shenzhen&quot;
   2) &quot;892.9663&quot;
   3) 1) &quot;113.93029063940048218&quot;
      2) &quot;22.53290942281488896&quot;
2) 1) &quot;guangzhou&quot;
   2) &quot;831.7263&quot;
   3) 1) &quot;113.36112052202224731&quot;
      2) &quot;23.12467049411647935&quot;
3) 1) &quot;shanghai&quot;
   2) &quot;688.9652&quot;
   3) 1) &quot;121.49295061826705933&quot;
      2) &quot;31.22337074392616074&quot;
4) 1) &quot;hefei&quot;
   2) &quot;315.1437&quot;
   3) 1) &quot;117.26104170083999634&quot;
      2) &quot;31.85117048067123591&quot;
5) 1) &quot;huanggang&quot;
   2) &quot;165.3475&quot;
   3) 1) &quot;115.94427019357681274&quot;
      2) &quot;30.07033115798519418&quot;
# 查看距离北京不大于1500km的城市
127.0.0.1:6379&gt; georadius china:city 116.28625 39.8585 1500 km withdist asc
1) 1) &quot;beijing&quot;
   2) &quot;0.0002&quot;
2) 1) &quot;dalian&quot;
   2) &quot;472.2545&quot;
3) 1) &quot;hefei&quot;
   2) &quot;894.9324&quot;
4) 1) &quot;wuhan&quot;
   2) &quot;1050.2106&quot;
5) 1) &quot;shanghai&quot;
   2) &quot;1069.3051&quot;
6) 1) &quot;huanggang&quot;
   2) &quot;1089.1453&quot;</code></pre>
<p>5️⃣<strong>georadiusbymember</strong></p>
<blockquote>
<p>描述</p>
</blockquote>
<p>georadiusbymember 和 georadius命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是只能从key中的位置元素选。</p>
<blockquote>
<p>语法</p>
</blockquote>
<pre><code class="shell">georadiusbymember &lt;key&gt; member radius m|km|ft|mi [withcoord] [withdist] [withhash] [count] [asc|desc] [store key] [storedist key]</code></pre>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell"># 查看距离黄冈不大于900km的城市
127.0.0.1:6379&gt; georadiusbymember china:city huanggang 900 km withdist asc
1) 1) &quot;huanggang&quot;
   2) &quot;0.0000&quot;
2) 1) &quot;wuhan&quot;
   2) &quot;165.3475&quot;
3) 1) &quot;hefei&quot;
   2) &quot;234.5308&quot;
4) 1) &quot;shanghai&quot;
   2) &quot;546.1566&quot;
5) 1) &quot;guangzhou&quot;
   2) &quot;814.0494&quot;
6) 1) &quot;shenzhen&quot;
   2) &quot;862.0165&quot;
# 查看距离深圳不大于2000km的城市
127.0.0.1:6379&gt; georadiusbymember china:city shenzhen 2000 km withdist desc
1) 1) &quot;dalian&quot;
   2) &quot;1964.1097&quot;
2) 1) &quot;beijing&quot;
   2) &quot;1939.8454&quot;
3) 1) &quot;shanghai&quot;
   2) &quot;1222.7809&quot;
4) 1) &quot;hefei&quot;
   2) &quot;1087.3585&quot;
5) 1) &quot;wuhan&quot;
   2) &quot;892.9663&quot;
6) 1) &quot;huanggang&quot;
   2) &quot;862.0165&quot;
7) 1) &quot;guangzhou&quot;
   2) &quot;87.9580&quot;
8) 1) &quot;shenzhen&quot;
   2) &quot;0.0000&quot;</code></pre>
<p>6️⃣<strong>geohash</strong></p>
<blockquote>
<p>描述</p>
</blockquote>
<p>geohash用于获取一个或多个位置元素的geohash值。</p>
<blockquote>
<p>实质</p>
</blockquote>
<p><strong>降维打击</strong>：将二维的经纬度转换为一维的字符串</p>
<p>如果两个字符串越接近，那么距离越近。</p>
<blockquote>
<p>语法</p>
</blockquote>
<pre><code class="shell">geohash &lt;key&gt; member [member ...]</code></pre>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell">127.0.0.1:6379&gt; geohash china:city huanggang beijing hefei
1) &quot;wt67n6hh3k0&quot;
2) &quot;wx4dy0j0d40&quot;
3) &quot;wtemhq6fs20&quot;</code></pre>
<p>7️⃣<strong>Other</strong></p>
<blockquote>
<p>GEO</p>
</blockquote>
<p>GEO的底层原理就是Sorted Set，因此我们可以使用Sorted Set命令来操作GEO。</p>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell"># 查看地图中全部元素
127.0.0.1:6379&gt; zrange china:city 0 -1
1) &quot;shenzhen&quot;
2) &quot;guangzhou&quot;
3) &quot;wuhan&quot;
4) &quot;huanggang&quot;
5) &quot;hefei&quot;
6) &quot;shanghai&quot;
7) &quot;beijing&quot;
8) &quot;dalian&quot;
# 移除大连这个城市
127.0.0.1:6379&gt; zrem china:city dalian
(integer) 1
# 按照分数给城市排名
127.0.0.1:6379&gt; zrangebyscore china:city -inf inf withscores
 1) &quot;shenzhen&quot;
 2) &quot;4046431599170567&quot;
 3) &quot;guangzhou&quot;
 4) &quot;4046534293000673&quot;
 5) &quot;wuhan&quot;
 6) &quot;4051938129491420&quot;
 7) &quot;huanggang&quot;
 8) &quot;4052334404505800&quot;
 9) &quot;hefei&quot;
10) &quot;4052764524670284&quot;
11) &quot;shanghai&quot;
12) &quot;4054757680623470&quot;
13) &quot;beijing&quot;
14) &quot;4069146323276357&quot;</code></pre>
<h4 id="7-2-2-📄HyperLogLog"><a href="#7-2-2-📄HyperLogLog" class="headerlink" title="7.2.2 📄HyperLogLog"></a>7.2.2 📄HyperLogLog</h4><p>HyperLogLog，Redis中基数统计的算法。</p>
<blockquote>
<p>优点</p>
</blockquote>
<p>占用内存固定且较小。每个HyperLogLog键占用12KB内存，可以计算2^64^个不同元素的基数。</p>
<blockquote>
<p>基数</p>
</blockquote>
<p>一个数据集中不重复元素的数量</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>统计网站UV</p>
<p>传统方式：使用set保存用户id，set的元素数量可作为标准判断。</p>
<p>这个方式如果保存大量的用户id，就会比较麻烦，目的是计数，而非保存用户id。</p>
<p>使用HyperLogLog会有**0.81%**的错误率，这个在统计UV任务中是可以接受的。</p>
<blockquote>
<p>操作方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">pfadd &lt;key&gt; element [element …]</td>
<td align="center">添加指定元素到HyperLogLog中</td>
</tr>
<tr>
<td align="center">pfcount &lt;key&gt;</td>
<td align="center">返回给定HyperLogLog的基数估算值</td>
</tr>
<tr>
<td align="center">pfmerge &lt;destkey&gt; &lt;key&gt; [key…]</td>
<td align="center">将多个HyperLogLog合并为一个HyperLogLog</td>
</tr>
</tbody></table>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell"># 创建第一组元素
127.0.0.1:6379&gt; pfadd hyper K H I G H N E S S 
(integer) 1
# 统计第一组元素基数
127.0.0.1:6379&gt; pfcount hyper
(integer) 7
# 创建第二组元素
127.0.0.1:6379&gt; pfadd hyper2 P A R A K
(integer) 1
# 统计第二组元素基数
127.0.0.1:6379&gt; pfcount hyper2
(integer) 4
# 合并两组元素
127.0.0.1:6379&gt; pfmerge hyper hyper hyper2
OK
# 统计所有元素基数
127.0.0.1:6379&gt; pfcount hyper
(integer) 10</code></pre>
<h4 id="7-1-3-🔳Bitmaps"><a href="#7-1-3-🔳Bitmaps" class="headerlink" title="7.1.3 🔳Bitmaps"></a>7.1.3 🔳Bitmaps</h4><p>Bitmaps，位图，操作二进制位来进行记录，只有0和1两个状态。</p>
<blockquote>
<p>应用场景</p>
</blockquote>
<p>统计用户活跃度，打卡，两个状态的都可以使用Bitmaps。</p>
<blockquote>
<p>操作方法</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">setbit &lt;key&gt; offset value</td>
<td align="center">设置值</td>
</tr>
<tr>
<td align="center">getbit &lt;key&gt;  offset</td>
<td align="center">获取值</td>
</tr>
<tr>
<td align="center">bitcount &lt;key&gt; start end</td>
<td align="center">获取Bitmaps指定范围值为1的个数</td>
</tr>
<tr>
<td align="center">bitop and|or|not|xor &lt;destkey&gt; key [key …]</td>
<td align="center">Bitmaps的集合运算</td>
</tr>
</tbody></table>
<blockquote>
<p>实例</p>
</blockquote>
<pre><code class="shell"># 打卡 0-6:周一-周日
# 2020年第一周打卡
127.0.0.1:6379&gt; setbit 2020:week:1 0 1
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:1 1 1
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:1 2 1
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:1 3 1
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:1 4 1
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:1 5 0
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:1 6 0
(integer) 0
# 2020年第二周打卡
127.0.0.1:6379&gt; setbit 2020:week:2 0 0
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:2 1 0
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:2 2 0
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:2 3 1
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:2 4 0
(integer) 1
127.0.0.1:6379&gt; setbit 2020:week:2 5 1
(integer) 0
127.0.0.1:6379&gt; setbit 2020:week:2 6 1
(integer) 0
# 检查打卡
127.0.0.1:6379&gt; getbit 2020:week:1 3
(integer) 1
127.0.0.1:6379&gt; getbit 2020:week:2 1
(integer) 0
# 统计打卡
127.0.0.1:6379&gt; bitcount 2020:week:1
(integer) 5
127.0.0.1:6379&gt; bitcount 2020:week:2
(integer) 3
# 对两周打卡结果取并集
127.0.0.1:6379&gt; bitop and andres 2020:week:1 2020:week:2
(integer) 1
127.0.0.1:6379&gt; bitcount andres
(integer) 1
# 对两周打卡结果取交集
127.0.0.1:6379&gt; bitop or orres 2020:week:1 2020:week:2
(integer) 1
127.0.0.1:6379&gt; bitcount orres
(integer) 7</code></pre>
<h2 id="8-📩Redis事务"><a href="#8-📩Redis事务" class="headerlink" title="8. 📩Redis事务"></a>8. 📩Redis事务</h2><blockquote>
<p> 💡 说明</p>
</blockquote>
<p>Redis单条命令执行具有原子性，但是事务不保证原子性。</p>
<h3 id="8-1📖定义"><a href="#8-1📖定义" class="headerlink" title="8. 1📖定义"></a>8. 1📖定义</h3><p>一组命令的队列</p>
<h3 id="8-2-🌠特征"><a href="#8-2-🌠特征" class="headerlink" title="8.2 🌠特征"></a>8.2 🌠特征</h3><ul>
<li>一次性</li>
<li>顺序性</li>
<li>排他性</li>
</ul>
<h3 id="8-3-⏳三个阶段"><a href="#8-3-⏳三个阶段" class="headerlink" title="8.3 ⏳三个阶段"></a>8.3 ⏳三个阶段</h3><ul>
<li>开始事务 (multi)</li>
<li>命令入队 (…)</li>
<li>执行事务 (exec)</li>
</ul>
<h3 id="8-4-📝操作方法"><a href="#8-4-📝操作方法" class="headerlink" title="8.4 📝操作方法"></a>8.4 📝操作方法</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">discard</td>
<td align="center">取消事务，放弃执行事务块内的所有命令</td>
</tr>
<tr>
<td align="center">exec</td>
<td align="center">执行事务块内的所有命令</td>
</tr>
<tr>
<td align="center">multi</td>
<td align="center">标记一个事务的开始</td>
</tr>
<tr>
<td align="center">unwatch</td>
<td align="center">取消watch命令对所有key的监视</td>
</tr>
<tr>
<td align="center">watch</td>
<td align="center">监视一个或多个key，如果在事务执行之前这个或这些key被其他命令锁改动，那么事务将被打断</td>
</tr>
</tbody></table>
<h3 id="8-5-🕵️实例"><a href="#8-5-🕵️实例" class="headerlink" title="8.5 🕵️实例"></a>8.5 🕵️实例</h3><pre><code class="shell"># 开启事务
127.0.0.1:6379&gt; multi
OK
# 命令入队
127.0.0.1:6379&gt; set k1 v1
QUEUED
127.0.0.1:6379&gt; set k2 v2 
QUEUED
127.0.0.1:6379&gt; mget k1 k2
QUEUED
127.0.0.1:6379&gt; getset k3 v3
QUEUED
127.0.0.1:6379&gt; get k3
QUEUED
# 执行事务
127.0.0.1:6379&gt; exec
1) OK
2) OK
3) 1) &quot;v1&quot;
   2) &quot;v2&quot;
4) &quot;v3&quot;
5) &quot;v3&quot;</code></pre>
<h3 id="8-6-⭕异常"><a href="#8-6-⭕异常" class="headerlink" title="8.6 ⭕异常"></a>8.6 ⭕异常</h3><ul>
<li>命令异常：命令存在错误，所有命令都不会被执行</li>
</ul>
<pre><code class="shell">127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; set k1 v1
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; getset k3 # 错误命令
(error) ERR wrong number of arguments for &#39;getset&#39; command
127.0.0.1:6379&gt; set k4 v4
QUEUED
127.0.0.1:6379&gt; exec # 执行事务报错
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379&gt; get k1 # 所有命令都未被执行
(nil)</code></pre>
<ul>
<li>运行异常：错误操作的命令抛出异常，其他命令正常执行</li>
</ul>
<pre><code class="shell">127.0.0.1:6379&gt; multi 
OK
127.0.0.1:6379&gt; set k1 v1
QUEUED
127.0.0.1:6379&gt; incr k1 # 错误操作
QUEUED
127.0.0.1:6379&gt; set k2 v2
QUEUED
127.0.0.1:6379&gt; exec # 执行事务仅错误操作执行失败，其他命令执行成功
1) OK
2) (error) ERR value is not an integer or out of range
3) OK
127.0.0.1:6379&gt; mget k1 k2
1) &quot;v1&quot;
2) &quot;v2&quot;</code></pre>
<h3 id="9-7-🔭监控"><a href="#9-7-🔭监控" class="headerlink" title="9.7 🔭监控"></a>9.7 🔭监控</h3><ul>
<li>悲观锁：很悲观，认为什么时候都会出问题，无论做什么都会加锁。</li>
<li>乐观锁：很乐观，认为什么时候都不会出问题，所以不会上锁。更新数据的时候会比较version，判断数据是否更新过。</li>
<li>watch的本质：select version，一旦发现监视的数据version改变，事务将被打断。</li>
</ul>
<blockquote>
<p>实例1-watch的监控测试</p>
</blockquote>
<pre><code class="shell"># 个人财务
127.0.0.1:6379&gt; set money 100
OK
# 个人支出
127.0.0.1:6379&gt; set out 0
OK
# 监控财务
127.0.0.1:6379&gt; watch money 
OK
# 开启事务
127.0.0.1:6379&gt; multi
OK
# 消费10元
127.0.0.1:6379&gt; decrby money 30
QUEUED
# 支出增加
127.0.0.1:6379&gt; incrby out 30
QUEUED
# 执行事务
127.0.0.1:6379&gt; exec
1) (integer) 70
2) (integer) 30</code></pre>
<blockquote>
<p>实例2-watch的多线程测试，watch可以当做redis的乐观锁操作</p>
</blockquote>
<pre><code class="shell"># 线程1
# 监控财务
127.0.0.1:6379&gt; watch money
OK
127.0.0.1:6379&gt; multi
OK
# 消费10元
127.0.0.1:6379&gt; decrby money 10
QUEUED
# 支出增加
127.0.0.1:6379&gt; incrby out 10
QUEUED
# 执行之前线程2修改了财务，这个时候就会导致事务执行失败
127.0.0.1:6379&gt; exec
(nil)

# 线程2 
# 执行在线程1的事务exec之前
# 查询财务
127.0.0.1:6379&gt; get money
&quot;70&quot;
# 充值1000
127.0.0.1:6379&gt; incrby money 1000
(integer) 1070

# 线程1
# 执行在线程1的事务exec之后
# 1、如果发现事务执行失败，就先解锁
127.0.0.1:6379&gt; unwatch 
OK
# 2、获取最新的值，再次监视
127.0.0.1:6379&gt; watch money
OK
127.0.0.1:6379&gt; multi
OK
127.0.0.1:6379&gt; decrby money 50
QUEUED
127.0.0.1:6379&gt; incrby out 50
QUEUED
# 3、对比监视的值是否发生了变化
# 如果没有变化，那么可以执行成功，否则执行失败
127.0.0.1:6379&gt; exec
1) (integer) 1020
2) (integer) 80</code></pre>
<h2 id="9-📩Jedis"><a href="#9-📩Jedis" class="headerlink" title="9. 📩Jedis"></a>9. 📩Jedis</h2><blockquote>
<p>📢 说明</p>
</blockquote>
<p>Jedis是Redis官方推荐的Java连接开发工具。</p>
<p>Jedis中的所有api就对应Redis中的所有命令。</p>
<h3 id="9-1-➕导入依赖"><a href="#9-1-➕导入依赖" class="headerlink" title="9.1 ➕导入依赖"></a>9.1 ➕导入依赖</h3><blockquote>
<p>pom.xml</p>
</blockquote>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;top.parak&lt;/groupId&gt;
    &lt;artifactId&gt;springboot-redis&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;developers&gt;
        &lt;developer&gt;
            &lt;name&gt;KHighness&lt;/name&gt;
            &lt;email&gt;parakovo@gmail.com&lt;/email&gt;
        &lt;/developer&gt;
    &lt;/developers&gt;

    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;relativePath/&gt;
    &lt;/parent&gt;

    &lt;properties&gt;
        &lt;fastjson.version&gt;1.2.68&lt;/fastjson.version&gt;
        &lt;jackson.version&gt;2.11.0&lt;/jackson.version&gt;
        &lt;jedis.version&gt;3.3.0&lt;/jedis.version&gt;
    &lt;/properties&gt;

    &lt;dependencies&gt;

        &lt;!-- Springboot-Web  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Spring Test --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
                    &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;

        &lt;!-- Springboot-Aop  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- Springboot-Redis  --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- SpringCloud-Context --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;
            &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- Fastjson --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
            &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
            &lt;version&gt;$&#123;fastjson.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- Jackson --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
            &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
            &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- Lombok --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;!-- Jedis --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
            &lt;version&gt;$&#123;jedis.version&#125;&lt;/version&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;

&lt;/project&gt;</code></pre>
<h3 id="9-2-⌨️编码测试"><a href="#9-2-⌨️编码测试" class="headerlink" title="9.2 ⌨️编码测试"></a>9.2 ⌨️编码测试</h3><h4 id="9-2-1-🅿Ping测试"><a href="#9-2-1-🅿Ping测试" class="headerlink" title="9.2.1 🅿Ping测试"></a>9.2.1 🅿Ping测试</h4><blockquote>
<p>Ping.java</p>
</blockquote>
<pre><code class="java">package top.parak.jedis;

import lombok.extern.log4j.Log4j2;
import redis.clients.jedis.Jedis;

/**
 * @author: KHighness
 * @date: 2020/10/11 17:47
 * @apiNote: 测试链接
 */

@Log4j2
public class Ping &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);
        log.info(jedis.ping());
        jedis.close();
    &#125;
&#125;</code></pre>
<blockquote>
<p>运行结果</p>
</blockquote>
<pre><code class="shell">17:52:31.303 [main] INFO top.parak.jedis.Ping - PONG</code></pre>
<h4 id="9-2-1-⚪GEO-api测试"><a href="#9-2-1-⚪GEO-api测试" class="headerlink" title="9.2.1 ⚪GEO-api测试"></a>9.2.1 ⚪GEO-api测试</h4><blockquote>
<p>city.txt</p>
</blockquote>
<pre><code class="txt">huanggang    115.94427    30.07033
wuhan        114.31589    30.55389
beijing      116.28625    39.8585
shanghai     121.49295    31.22337
hefei        117.26104    31.85117
shenzhen     113.93029    22.53291
dalian       121.64465    38.91859
guangzhou    113.36112    23.12467</code></pre>
<blockquote>
<p>Geo.java</p>
</blockquote>
<pre><code class="java">package top.parak.jedis;

import lombok.extern.log4j.Log4j2;
import org.springframework.util.ResourceUtils;
import redis.clients.jedis.GeoCoordinate;
import redis.clients.jedis.GeoUnit;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.params.GeoRadiusParam;

import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;


/**
 * @author: KHighness
 * @date: 2020/10/11 17:59
 * @apiNote: 测试Geospatial
 */

@Log4j2
public class Geo &#123;

    /**
     * 读取文件将地理数据写进redis
     * @param path
     * @throws IOException
     */
    public static void readAndWriteIntoRedis(String path, Jedis jedis) throws IOException &#123;
        FileInputStream fileInputStream = new FileInputStream(path);
        FileChannel channel = fileInputStream.getChannel();
        ByteBuffer byteBuffer = ByteBuffer.allocate(512);
        channel.read(byteBuffer);
        String[] res = new String(byteBuffer.array()).split(&quot;\n&quot;);
        Map&lt;String, GeoCoordinate&gt; map = new HashMap&lt;&gt;();
        Arrays.stream(res).forEach(s -&gt; &#123;
            // 使用正则\s+匹配多个空格，分割字符串
            String[] ss = s.split(&quot;\\s+&quot;);
            map.put(ss[0], new GeoCoordinate(Double.valueOf(ss[1]), Double.valueOf(ss[2])));
        &#125;);
        jedis.geoadd(&quot;china:city&quot;, map);
    &#125;

    public static void main(String[] args) throws IOException &#123;
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);
        readAndWriteIntoRedis(ResourceUtils.getFile(&quot;src/main/resources/city.txt&quot;).getAbsolutePath(), jedis);
        log.info(&quot;==========地图中的所有城市==========&quot;);
        jedis.zrange(&quot;china:city&quot;, 0, -1).stream().forEach(s -&gt; &#123; log.info(s + &quot; &quot;); &#125;);
        log.info(&quot;==========查询黄冈的经纬度==========&quot;);
        log.info(jedis.geopos(&quot;china:city&quot;, &quot;huanggang&quot;));
        log.info(&quot;==========查询距离杭州不超过1000km的城市==========&quot;);
        GeoRadiusParam geoRadiusParam = new GeoRadiusParam();
        geoRadiusParam.withCoord().withDist().sortAscending();
        jedis.georadius(&quot;china:city&quot;, 120.153576, 30.287459, 1000, GeoUnit.KM, geoRadiusParam).forEach( c -&gt; &#123;
            log.info(&quot;城市名称：&#123;&#125;, 经纬度：&#123;&#125;，距离：&#123;&#125;KM&quot;, c.getMemberByString(), c.getCoordinate(), c.getDistance());
        &#125;);
        log.info(&quot;==========查询距离武汉不超过1000KM的城市==========&quot;);
        jedis.georadiusByMember(&quot;china:city&quot;, &quot;wuhan&quot;, 1000, GeoUnit.KM, geoRadiusParam).forEach( c -&gt; &#123;
            log.info(&quot;城市名称：&#123;&#125;, 经纬度：&#123;&#125;，距离：&#123;&#125;KM&quot;, c.getMemberByString(), c.getCoordinate(), c.getDistance());
        &#125;);
    &#125;
&#125;</code></pre>
<blockquote>
<p>运行结果</p>
</blockquote>
<pre><code class="shell">20:21:02.671 [main] INFO top.parak.jedis.Geo - ==========地图中的所有城市==========
20:21:02.718 [main] INFO top.parak.jedis.Geo - shenzhen 
20:21:02.718 [main] INFO top.parak.jedis.Geo - guangzhou 
20:21:02.718 [main] INFO top.parak.jedis.Geo - wuhan 
20:21:02.718 [main] INFO top.parak.jedis.Geo - huanggang 
20:21:02.718 [main] INFO top.parak.jedis.Geo - hefei 
20:21:02.718 [main] INFO top.parak.jedis.Geo - shanghai 
20:21:02.718 [main] INFO top.parak.jedis.Geo - beijing 
20:21:02.718 [main] INFO top.parak.jedis.Geo - dalian 
20:21:02.718 [main] INFO top.parak.jedis.Geo - ==========查询黄冈的经纬度==========
20:21:02.720 [main] INFO top.parak.jedis.Geo - [(115.94427019357681,30.070331157985194)]
20:21:02.721 [main] INFO top.parak.jedis.Geo - ==========查询距离杭州不超过1000km的城市==========
20:21:02.724 [main] INFO top.parak.jedis.Geo - 城市名称：shanghai, 经纬度：(121.49295061826706,31.22337074392616)，距离：165.0KM
20:21:02.724 [main] INFO top.parak.jedis.Geo - 城市名称：hefei, 经纬度：(117.26104170084,31.851170480671236)，距离：325.8468KM
20:21:02.725 [main] INFO top.parak.jedis.Geo - 城市名称：huanggang, 经纬度：(115.94427019357681,30.070331157985194)，距离：405.4241KM
20:21:02.725 [main] INFO top.parak.jedis.Geo - 城市名称：wuhan, 经纬度：(114.31589037179947,30.55389005243692)，距离：560.6357KM
20:21:02.725 [main] INFO top.parak.jedis.Geo - 城市名称：dalian, 经纬度：(121.64465099573135,38.91858901014995)，距离：969.6213KM
20:21:02.725 [main] INFO top.parak.jedis.Geo - ==========查询距离武汉不超过1000KM的城市==========
20:21:02.725 [main] INFO top.parak.jedis.Geo - 城市名称：wuhan, 经纬度：(114.31589037179947,30.55389005243692)，距离：0.0KM
20:21:02.725 [main] INFO top.parak.jedis.Geo - 城市名称：huanggang, 经纬度：(115.94427019357681,30.070331157985194)，距离：165.3475KM
20:21:02.726 [main] INFO top.parak.jedis.Geo - 城市名称：hefei, 经纬度：(117.26104170084,31.851170480671236)，距离：315.1437KM
20:21:02.726 [main] INFO top.parak.jedis.Geo - 城市名称：shanghai, 经纬度：(121.49295061826706,31.22337074392616)，距离：688.9652KM
20:21:02.726 [main] INFO top.parak.jedis.Geo - 城市名称：guangzhou, 经纬度：(113.36112052202225,23.12467049411648)，距离：831.7263KM
20:21:02.726 [main] INFO top.parak.jedis.Geo - 城市名称：shenzhen, 经纬度：(113.93029063940048,22.53290942281489)，距离：892.9663KM</code></pre>
<h4 id="9-2-2-⚫Hyper-api测试"><a href="#9-2-2-⚫Hyper-api测试" class="headerlink" title="9.2.2 ⚫Hyper-api测试"></a>9.2.2 ⚫Hyper-api测试</h4><blockquote>
<p>Hyper.java</p>
</blockquote>
<pre><code class="java">package top.parak.jedis;

import lombok.extern.log4j.Log4j2;
import redis.clients.jedis.Jedis;

/**
 * @author: KHighness
 * @date: 2020/10/11 20:26
 * @apiNote: 测试hyper
 */

@Log4j2
public class Hyper &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);
        jedis.pfadd(&quot;hyper1&quot;, &quot;K&quot;, &quot;H&quot;, &quot;I&quot;, &quot;G&quot;, &quot;H&quot;, &quot;N&quot;, &quot;E&quot;, &quot;S&quot;, &quot;S&quot;);
        log.info(&quot;hyper1中的元素基数：&#123;&#125;&quot;, jedis.pfcount(&quot;hyper1&quot;));
        jedis.pfadd(&quot;hyper2&quot;, &quot;P&quot;, &quot;A&quot;, &quot;R&quot;, &quot;A&quot;, &quot;K&quot;);
        log.info(&quot;hyper2中的元素基数：&#123;&#125;&quot;, jedis.pfcount(&quot;hyper2&quot;));
        jedis.pfmerge(&quot;hyper&quot;, &quot;hyper1&quot;, &quot;hyper2&quot;);
        log.info(&quot;hyper1和hyper2合并后的元素基数：&#123;&#125;&quot;, jedis.pfcount(&quot;hyper&quot;));
    &#125;
&#125;</code></pre>
<blockquote>
<p>运行结果</p>
</blockquote>
<pre><code class="shell">20:36:20.386 [main] INFO top.parak.jedis.Hyper - hyper1中的元素基数：7
20:36:20.390 [main] INFO top.parak.jedis.Hyper - hyper2中的元素基数：4
20:36:20.390 [main] INFO top.parak.jedis.Hyper - hyper1和hyper2合并后的元素基数：10</code></pre>
<h4 id="9-2-3-🔴Bitmaps-api测试"><a href="#9-2-3-🔴Bitmaps-api测试" class="headerlink" title="9.2.3 🔴Bitmaps-api测试"></a>9.2.3 🔴Bitmaps-api测试</h4><blockquote>
<p>Bit.java</p>
</blockquote>
<pre><code class="java">package top.parak.jedis;

import lombok.extern.log4j.Log4j2;
import redis.clients.jedis.BitOP;
import redis.clients.jedis.Jedis;

/**
 * @author: KHighness
 * @date: 2020/10/11 20:38
 * @apiNote: 测试Bitmaps
 */

@Log4j2
public class Bit &#123;
    public static String getChineseExpression(int i) &#123;
        switch (i) &#123;
            case 0: return &quot;星期一&quot;;
            case 1: return &quot;星期二&quot;;
            case 2: return &quot;星期三&quot;;
            case 3: return &quot;星期四&quot;;
            case 4: return &quot;星期五&quot;;
            case 5: return &quot;星期六&quot;;
            case 6: return &quot;星期日&quot;;
            default: return &quot;Error&quot;;
        &#125;
    &#125;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);
        // 模拟两周的打卡情况
        boolean[] bool1 = new boolean[]&#123;true, true, true, true, true, false, false&#125;;
        boolean[] bool2 = new boolean[]&#123;false, false, false, true, true, true, false&#125;;
        for (int i = 0; i &lt; bool1.length; i++) &#123; jedis.setbit(&quot;2020:week:1&quot;, i, bool1[i]); &#125;
        for (int i = 0; i &lt; bool2.length; i++) &#123; jedis.setbit(&quot;2020:week:2&quot;, i, bool2[i]); &#125;
        log.info(&quot;2020年第一周的打卡天数：&#123;&#125;&quot;, jedis.bitcount(&quot;2020:week:1&quot;));
        log.info(&quot;2020年第一周具体打卡情况&quot;);
        for (int i = 0; i &lt; bool1.length; i++) &#123; log.info(getChineseExpression(i) + &quot;: &quot; + (jedis.getbit(&quot;2020:week:1&quot;, i) ? &quot;已打卡&quot; : &quot;未打卡&quot;)); &#125;
        log.info(&quot;2020年第二周的打卡天数：&#123;&#125;&quot;, jedis.bitcount(&quot;2020:week:2&quot;));
        log.info(&quot;2020年第二周具体打卡情况&quot;);
        for (int i = 0; i &lt; bool2.length; i++) &#123; log.info(getChineseExpression(i) + &quot;: &quot; + (jedis.getbit(&quot;2020:week:2&quot;, i) ? &quot;已打卡&quot; : &quot;未打卡&quot;)); &#125;
        jedis.bitop(BitOP.AND, &quot;2020:week:1and2&quot;, &quot;2020:week:1&quot;, &quot;2020:week:2&quot;);
        log.info(&quot;2020年第一周和第二周两天都打卡的天数：&#123;&#125;&quot;, jedis.bitcount(&quot;2020:week:1and2&quot;));
        jedis.bitop(BitOP.OR, &quot;2020:week:1or2&quot;, &quot;2020:week:1&quot;, &quot;2020:week:2&quot;);
        log.info(&quot;2020年第一周和第二周至少有一天打卡的天数：&#123;&#125;&quot;, jedis.bitcount(&quot;2020:week:1or2&quot;));
        jedis.bitop(BitOP.XOR,&quot;2020:week:1xor2&quot;, &quot;2020:week:1&quot;, &quot;2020:week:2&quot;);
        log.info(&quot;2020年第一周和第二周仅有一天打卡的天数：&#123;&#125;&quot;, jedis.bitcount(&quot;2020:week:1xor2&quot;));
    &#125;
&#125;</code></pre>
<blockquote>
<p>运行结果</p>
</blockquote>
<pre><code class="shell">21:07:40.042 [main] INFO top.parak.jedis.Bit - 2020年第一周的打卡天数：5
21:07:40.046 [main] INFO top.parak.jedis.Bit - 2020年第一周具体打卡情况
21:07:40.046 [main] INFO top.parak.jedis.Bit - 星期一: 已打卡
21:07:40.046 [main] INFO top.parak.jedis.Bit - 星期二: 已打卡
21:07:40.046 [main] INFO top.parak.jedis.Bit - 星期三: 已打卡
21:07:40.046 [main] INFO top.parak.jedis.Bit - 星期四: 已打卡
21:07:40.046 [main] INFO top.parak.jedis.Bit - 星期五: 已打卡
21:07:40.046 [main] INFO top.parak.jedis.Bit - 星期六: 未打卡
21:07:40.047 [main] INFO top.parak.jedis.Bit - 星期日: 未打卡
21:07:40.047 [main] INFO top.parak.jedis.Bit - 2020年第二周的打卡天数：3
21:07:40.047 [main] INFO top.parak.jedis.Bit - 2020年第二周具体打卡情况
21:07:40.047 [main] INFO top.parak.jedis.Bit - 星期一: 未打卡
21:07:40.047 [main] INFO top.parak.jedis.Bit - 星期二: 未打卡
21:07:40.047 [main] INFO top.parak.jedis.Bit - 星期三: 未打卡
21:07:40.047 [main] INFO top.parak.jedis.Bit - 星期四: 已打卡
21:07:40.047 [main] INFO top.parak.jedis.Bit - 星期五: 已打卡
21:07:40.047 [main] INFO top.parak.jedis.Bit - 星期六: 已打卡
21:07:40.047 [main] INFO top.parak.jedis.Bit - 星期日: 未打卡
21:07:40.048 [main] INFO top.parak.jedis.Bit - 2020年第一周和第二周两天都打卡的天数：2
21:07:40.048 [main] INFO top.parak.jedis.Bit - 2020年第一周和第二周至少有一天打卡的天数：6
21:07:40.048 [main] INFO top.parak.jedis.Bit - 2020年第一周和第二周仅有一天打卡的天数：4</code></pre>
<h4 id="9-2-4-🔵事务测试"><a href="#9-2-4-🔵事务测试" class="headerlink" title="9.2.4 🔵事务测试"></a>9.2.4 🔵事务测试</h4><blockquote>
<p>Affair.java</p>
</blockquote>
<pre><code class="java">package top.parak.jedis;

import com.alibaba.fastjson.JSONObject;
import lombok.extern.log4j.Log4j2;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.Transaction;

import java.util.concurrent.TimeUnit;

/**
 * @author: KHighness
 * @date: 2020/10/11 21:33
 * @apiNote: 测试事务
 */

@Log4j2
public class Affair &#123;
    public static void main(String[] args) &#123;
        Jedis jedis = new Jedis(&quot;127.0.0.1&quot;, 6379);

        // 创建json数据
        JSONObject jsonObject1 = new JSONObject();
        jsonObject1.put(&quot;name&quot;, &quot;KHighness&quot;);
        jsonObject1.put(&quot;age&quot;, 19);
        jsonObject1.put(&quot;constellation&quot;, &quot;Virgo&quot;);
        jsonObject1.put(&quot;Hobby&quot;, &quot;Jay&quot;);
        String json1 = jsonObject1.toJSONString();
        JSONObject jsonObject2 = new JSONObject();
        jsonObject2.put(&quot;name&quot;, &quot;BingYao&quot;);
        jsonObject2.put(&quot;age&quot;, 16);
        jsonObject2.put(&quot;constellation&quot;, &quot;Taurus&quot;);
        jsonObject2.put(&quot;Hobby&quot;, &quot;Czk&quot;);
        String json2 = jsonObject2.toJSONString();
        jedis.set(&quot;user1&quot;, json1);
        jedis.set(&quot;user2&quot;, json2);

        // 加入乐观锁
        jedis.watch(&quot;user1&quot;, &quot;user2&quot;);

        // 开启事务
        Transaction multi = jedis.multi();
        new Thread( () -&gt; &#123;
           try &#123;
               TimeUnit.SECONDS.sleep(5);
               multi.set(&quot;user1&quot;, json1);
               multi.set(&quot;user2&quot;, json2);
               // 执行事务
               multi.exec();
           &#125; catch (InterruptedException e) &#123;
               // 发生异常
               // 放弃事务
               multi.discard();
               log.info(e.getMessage());
           &#125; finally &#123;
               // 输出数据
               log.info(&quot;user1: [&#123;&#125;]&quot;, jedis.get(&quot;user1&quot;));
               log.info(&quot;user2: [&#123;&#125;]&quot;, jedis.get(&quot;user2&quot;));
               jedis.close();
           &#125;
        &#125;, &quot;Multi&quot;).start();

        // 另一线程
        // 开启在事务之前
        new Thread( () -&gt; &#123;
            try &#123;
                new Affair().resetInfo1(jedis);
            &#125; catch (InterruptedException e) &#123;
                log.info(e.getMessage());
            &#125;
        &#125;, &quot;Other&quot;).start();

    &#125;

    public void resetInfo1(Jedis jedis) throws InterruptedException &#123;
        TimeUnit.SECONDS.sleep(1);
        JSONObject jsonObject1 = new JSONObject();
        jsonObject1.put(&quot;name&quot;, &quot;KHighness&quot;);
        jsonObject1.put(&quot;age&quot;, 20);
        jsonObject1.put(&quot;constellation&quot;, &quot;Leo&quot;);
        jsonObject1.put(&quot;Hobby&quot;, &quot;BingYao&quot;);
        String json1 = jsonObject1.toJSONString();
        jedis.set(&quot;user1&quot;, json1);
    &#125;
&#125;</code></pre>
<blockquote>
<p>运行结果</p>
</blockquote>
<pre><code class="shell">Exception in thread &quot;Other&quot; redis.clients.jedis.exceptions.JedisDataException: Cannot use Jedis when in Multi. Please use Transaction or reset jedis state.
    at redis.clients.jedis.BinaryJedis.checkIsInMultiOrPipeline(BinaryJedis.java:1895)
    at redis.clients.jedis.Jedis.set(Jedis.java:152)
    at top.parak.jedis.Affair.resetInfo1(Affair.java:82)
    at top.parak.jedis.Affair.lambda$main$1(Affair.java:66)
    at java.lang.Thread.run(Thread.java:748)
22:05:18.651 [Multi] INFO top.parak.jedis.Affair - user1: [&#123;&quot;constellation&quot;:&quot;Virgo&quot;,&quot;name&quot;:&quot;KHighness&quot;,&quot;Hobby&quot;:&quot;Jay&quot;,&quot;age&quot;:19&#125;]
22:05:18.654 [Multi] INFO top.parak.jedis.Affair - user2: [&#123;&quot;constellation&quot;:&quot;Taurus&quot;,&quot;name&quot;:&quot;BingYao&quot;,&quot;Hobby&quot;:&quot;Czk&quot;,&quot;age&quot;:16&#125;]</code></pre>
<h2 id="10-📩Springboot整合"><a href="#10-📩Springboot整合" class="headerlink" title="10. 📩Springboot整合"></a>10. 📩Springboot整合</h2><blockquote>
<p>⚠️notice</p>
</blockquote>
<p>在SpringBoot2.X之后，原来使用的jedis被替换为了lettuce，在windows下lettuce连接池仅支持3.2.100版本的Redis</p>
<ul>
<li><p>jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全，需要使用jedis pool连接池，更像BIO模式</p>
</li>
<li><p>lettuce：底层整合Netty，实例可以在多个线程中共享，不存在线程不安全的情况，可以减少线程数据，更像NIO模式</p>
</li>
</ul>
<h3 id="10-1-🔎源码分析"><a href="#10-1-🔎源码分析" class="headerlink" title="10.1 🔎源码分析"></a>10.1 🔎源码分析</h3><blockquote>
<p>自动配置类：RedisAutoConfiguration.java</p>
</blockquote>
<pre><code class="java">@Configuration(
    proxyBeanMethods = false
)
@ConditionalOnClass(&#123;RedisOperations.class&#125;)
@EnableConfigurationProperties(&#123;RedisProperties.class&#125;)
@Import(&#123;LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class&#125;)
public class RedisAutoConfiguration &#123;
    public RedisAutoConfiguration() &#123;
    &#125;

    @Bean
    @ConditionalOnMissingBean(name = &#123;&quot;redisTemplate&quot;&#125;) 
    // ==&gt; 这个注解说明，不存在我们自定义名为redisTemplate的Bean的情况下，这个Bean才生效
    // ==&gt; 因此我们可以使用自定义的RedisTemplate，SpringBoot会优先使用自定义RedisTemplate
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123;
        // 默认的RedisTemplate没有过多的配置，Redis对象都需要序列化和反序列化
        // 两个泛型都是 Object, Obeject 的类型，我们以后使用需要强制转换成 String, Object
        RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    &#125;

    @Bean
    @ConditionalOnMissingBean
    // 由于String是Redis中最常使用的类型，所以单独一个StringRedisTemplate
    // 所以操作String类型，直接使用StringRedisTemplate即可
    public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException &#123;
        StringRedisTemplate template = new StringRedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
    &#125;
&#125;</code></pre>
<h3 id="10-2-🔑整合使用"><a href="#10-2-🔑整合使用" class="headerlink" title="10.2 🔑整合使用"></a>10.2 🔑整合使用</h3><blockquote>
<p>导入依赖：pom.xml(见上jedis)</p>
</blockquote>
<blockquote>
<p>配置环境：application.properties</p>
</blockquote>
<pre><code class="properties"># Redis数据库索引（默认为0）
spring.redis.database=0
# Redis服务器地址
spring.redis.host=127.0.0.1
# Redis服务器连接端口
spring.redis.port=6379
# Redis服务器连接密码（默认为空）
spring.redis.password=
# 连接超时时间（毫秒）
spring.redis.timeout=100

# Spring 2.X以后，使用lettuce连接池
# 连接池最大阻塞等待时间（使用负值表示没有限制）
spring.redis.lettuce.pool.max-active=100
# 连接池中的最大空闲连接
spring.redis.lettuce.pool.max-idle=10
# 连接池中的最小空闲连接
spring.redis.lettuce.pool.min-idle=0
# 连接超时时间
spring.redis.lettuce.shutdown-timeout=100ms</code></pre>
<blockquote>
<p>⌨️自定义RedisTemplate：RedisConfig.java</p>
</blockquote>
<pre><code class="java">package top.parak.config;

import com.fasterxml.jackson.annotation.JsonAutoDetect;
import com.fasterxml.jackson.annotation.PropertyAccessor;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.connection.RedisConnectionFactory;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;
import org.springframework.data.redis.serializer.StringRedisSerializer;

/**
 * @author: KHighness
 * @date: 2020/10/7 20:23
 * @apiNote: 自定义RedisTemplate
 */

@Configuration
public class RedisConfig &#123;

    /**
     * &lt;p&gt;自定义redisTemplate&lt;/p&gt;
     * @param redisConnectionFactory
     * @return
     */
    @Bean
    @SuppressWarnings(&quot;all&quot;)
    @Qualifier(&quot;redisTemplate&quot;)
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
        /* 创建redisTemplate */
        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        /* 关联redisConnectionFactory */
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        /* Jackson2JsonRedisSerializer：Json序列化器 */
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        redisTemplate.setKeySerializer(jackson2JsonRedisSerializer);
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        objectMapper.activateDefaultTyping(LaissezFaireSubTypeValidator.instance, ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
        /* StringRedisSerializer：String序列化器 */
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        /* 设置key的序列化方式：String */
        redisTemplate.setKeySerializer(stringRedisSerializer);
        /* 设置value的序列化方式：Json */
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        /* 设置hash的key的序列化方式：Json */
        redisTemplate.setHashKeySerializer(jackson2JsonRedisSerializer);
        /* 设置hash的value的序列化方式：Json */
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    &#125;

&#125;</code></pre>
<blockquote>
<p>⌨️Redis工具类：RedisUtil.java</p>
</blockquote>
<pre><code class="java">package top.parak.common;

import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;

import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

/**
 * @author: KHighness
 * @date: 2020/10/7 21:33
 * @apiNote: Redis操作工具类
 */

@Log4j2
@Component
public class RedisUtil &#123;

    @Autowired
    private RedisTemplate&lt;String, Object&gt; redisTemplate;

    /*==================================================================
    //                            common                              //
    ==================================================================*/

    /**
     * 指定缓存失效时间
     * @param key 键
     * @param time 时间(秒)
     * @return true 成功，false 失败
     */
    public boolean expire(String key, long time) &#123;
        try &#123;
            if (time &gt; 0) &#123;
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 根据key获取过期时间
     * @param key 键
     * @return 时间(秒) 返回0代表永久有效
     */
    public long getExpire(String key) &#123;
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    &#125;

    /*==================================================================
    //                            String                              //
    ==================================================================*/

    /**
     * 判断key是否存在
     * @param key 键
     * @return true 存在，false 不存在
     */
    public boolean hasKey(String key) &#123;
        try &#123;
            return redisTemplate.hasKey(key);
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 删除缓存
     * @param key 可以传一个或多个
     */
    public void del(String... key) &#123;
        if (key != null &amp;&amp; key.length &gt; 0) &#123;
            if (key.length == 1) &#123;
                redisTemplate.delete(key[0]);
            &#125; else &#123;
                redisTemplate.delete(CollectionUtils.arrayToList(key));
            &#125;
        &#125;
    &#125;

    /**
     * 普通缓存获取
     * @param key 键
     * @return 值
     */
    public Object get(String key) &#123;
        return key == null ? null : redisTemplate.opsForValue().get(key);
    &#125;

    /**
     * 普通缓存放入
     * @param key   键
     * @param value 值
     * @return true 成功，false 失败
     */
    public boolean set(String key, Object value) &#123;
        try &#123;
            redisTemplate.opsForValue().set(key, value);
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 普通缓存放入并设置时间
     * @param key   键
     * @param value 值
     * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true 成功，false 失败
     */
    public boolean set(String key, Object value, long time) &#123;
        try &#123;
            if (time &gt; 0) &#123;
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            &#125; else &#123;
                set(key, value);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 递增
     * @param key   键
     * @param delta 增量
     * @return 递增后的值
     */
    public long incr(String key, long delta) &#123;
        if (delta &lt; 0) &#123;
            throw new RuntimeException(&quot;增量必须大于0&quot;);
        &#125;
        return redisTemplate.opsForValue().increment(key, delta);
    &#125;

    /**
     * 递减
     * @param key   键
     * @param delta 减量
     * @return 递减后的值
     */
    public long decr(String key, long delta) &#123;
        if (delta &lt; 0) &#123;
            throw new RuntimeException(&quot;减量必须大于0&quot;);
        &#125;
        return redisTemplate.opsForValue().decrement(key, delta);
    &#125;

    /*==================================================================
    //                              map                               //
    ==================================================================*/

    /**
     * HashGet
     * @param key  键 不能为NULL
     * @param item 项 不能为NULL
     * @return 值
     */
    public Object hget(String key, String item) &#123;
        return redisTemplate.opsForHash().get(key, item);
    &#125;

    /**
     * 获取hashKey对应的所有键值
     * @param key 键
     * @return 对应的多个键值
     */
    public Map&lt;Object, Object&gt; hmget(String key) &#123;
        return redisTemplate.opsForHash().entries(key);
    &#125;

    /**
     * HashSet
     * @param key 键
     * @param map 对应的多个键值
     * @return true 成功，false 失败
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123;
        try &#123;
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * HashSet 并设置时间
     * @param key 键
     * @param map 对应多个键值
     * @param time 时间(秒)
     * @return true 成功，false 失败
     */
    public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123;
        try &#123;
            redisTemplate.opsForHash().putAll(key, map);
            if (time &gt; 0) &#123;
                expire(key, time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 向一张hash表中放入数据，如果不存在则创建
     * @param key   键
     * @param item  项
     * @param value 值
     * @return true 成功，false 失败
     */
    public boolean hset(String key, String item, Object value) &#123;
        try &#123;
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 向一张hash表中放入数据，并设置时间，如果不存在则创建
     * @param key   键
     * @param item  项
     * @param value 值
     * @param time  时间(秒) 如果已存在的hash表有时间，这里会更新原值
     * @return true 成功，false 失败
     */
    public boolean hset(String key, String item, Object value, long time) &#123;
        try &#123;
            redisTemplate.opsForHash().put(key, item, value);
            if (time &gt; 0) &#123;
                expire(key, time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 删除hash表中的值
     * @param key  键 不能为NULL
     * @param item 项 可以使多个 不能为NULL
     */
    public void hdel(String key, Object... item) &#123;
        redisTemplate.opsForHash().delete(key, item);
    &#125;

    /**
     * 判断hash表中是否有该项的值
     * @param key  键 不能为NULL
     * @param item 项 不能为NULL
     * @return true 存在，false 不存在
     */
    public boolean hHasKey(String key, String item) &#123;
        return redisTemplate.opsForHash().hasKey(key, item);
    &#125;

    /**
     * hash递增 如果不存在，就会创建一个，并把递增后的值返回
     * @param key  键
     * @param item 值
     * @param by   增量
     * @return 递增后的值
     */
    public double hincr(String key, String item, double by) &#123;
        return redisTemplate.opsForHash().increment(key, item, by);
    &#125;

    /**
     * hash递减
     * @param key  键
     * @param item 值
     * @param by   减量
     * @return 递减后的值
     */
    public double hdecr(String key, String item, double by) &#123;
        return redisTemplate.opsForHash().increment(key, item, -by);
    &#125;

    /*==================================================================
    //                              set                               //
    ==================================================================*/

    /**
     * 根据key获取Set中的所有值
     * @param key 键
     * @return set中的所有值
     */
    public Set&lt;Object&gt; sGet(String key) &#123;
        try &#123;
            return redisTemplate.opsForSet().members(key);
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return null;
        &#125;
    &#125;

    /**
     * 根据value从一个set中查询是否存在
     * @param key   键
     * @param value 值
     * @return true 存在，false 不存在
     */
    public boolean sHasKey(String key, Object value) &#123;
        try &#123;
            return redisTemplate.opsForSet().isMember(key, value);
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 将数据放入set缓存
     * @param key    键
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object... values) &#123;
        try &#123;
            return redisTemplate.opsForSet().add(key, values);
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return 0;
        &#125;
    &#125;

    /**
     * 将set数据放入缓存，并设置时间
     * @param key    键
     * @param time   时间(秒)
     * @param values 值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key, long time, Object... values) &#123;
        try &#123;
            Long count = redisTemplate.opsForSet().add(key, values);
            if (time &gt; 0) &#123;
                expire(key, time);
            &#125;
            return count;
        &#125; catch (Exception e) &#123;
            log.info(e.getMessage());
            return 0;
        &#125;
    &#125;

    /**
     * 获取set缓存的长度
     * @param key 键
     * @return set的长度
     */
    public long sGetSetSize(String key) &#123;
        try &#123;
            return redisTemplate.opsForSet().size(key);
        &#125; catch (Exception e) &#123;
            log.info(e.getMessage());
            return 0;
        &#125;
    &#125;

    /*==================================================================
    //                             list                               //
    ==================================================================*/

    /**
     * 获取list缓存的长度
     * @param key 键
     * @return list的长度
     */
    public long lGetListSize(String key) &#123;
        try &#123;
            return redisTemplate.opsForList().size(key);
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return 0;
        &#125;
    &#125;

    /**
     * 通过索引获取list中的值
     * @param key   键
     * @param index 索引 index &gt;= 0时，0 表头，1 第二个元素，依次类推；index &lt; 0时，-1 表尾，-2 倒数第二个元素，依次类推
     * @return 值
     */
    public Object lGetIndex(String key, long index) &#123;
        try &#123;
            return redisTemplate.opsForList().index(key, index);
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return null;
        &#125;
    &#125;

    /**
     * 将list放入缓存
     * @param key   键
     * @param value 值
     * @return true 成功，false 失败
     */
    public boolean lSet(String key, Object value) &#123;
        try &#123;
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 将list放入缓存，并设置时间
     * @param key   键
     * @param value 值
     * @param time  时间(秒)
     * @return 成功数量
     */
    public boolean lSet(String key, Object value, long time) &#123;
        try &#123;
            redisTemplate.opsForList().rightPush(key, value);
            if (time &gt; 0) &#123;
                expire(key, time);
            &#125;
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 根据索引修改list中的某条数据
     * @param key   键
     * @param index 索引
     * @param value 值
     * @return true 成功，false 失败
     */
    public boolean lUpdateIndex(String key, long index, Object value) &#123;
        try &#123;
            redisTemplate.opsForList().set(key, index, value);
            return true;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return false;
        &#125;
    &#125;

    /**
     * 移除N个值为value
     * @param key   键
     * @param count 移除数量
     * @param value 值
     * @return 移除数量
     */
    public long lRemove(String key, long count ,Object value) &#123;
        try &#123;
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        &#125; catch (Exception e) &#123;
            log.error(e.getMessage());
            return 0;
        &#125;
    &#125;

&#125;</code></pre>
<h3 id="10-3-💨api测试"><a href="#10-3-💨api测试" class="headerlink" title="10.3 💨api测试"></a>10.3 💨api测试</h3><pre><code class="java">package top.parak;


import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.data.redis.core.StringRedisTemplate;
import top.parak.common.RedisUtil;
import top.parak.entity.User;
import lombok.extern.log4j.Log4j2;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.core.RedisTemplate;

import java.util.HashMap;
import java.util.Map;

@SpringBootTest
@Log4j2
class SpringbootRedisApplicationTest &#123;

    @Autowired
    private StringRedisTemplate stringRedisTemplate;

    @Autowired
    private RedisTemplate redisTemplate;

    @Autowired
    private RedisUtil redisUtil;

    @Test
    void main() &#123;
        redisTemplate.opsForValue().set(&quot;name&quot;, &quot;K殿下&quot;);
        log.info(redisTemplate.opsForValue().get(&quot;name&quot;));
    &#125;

    @Test
    void test1() &#123;
        stringRedisTemplate.opsForValue().set(&quot;Knum&quot;, &quot;3&quot;);
        log.info(stringRedisTemplate.opsForValue().increment(&quot;Knum&quot;, 3));
    &#125;

    @Test
    void test2() throws JsonProcessingException &#123;
        User user = new User(&quot;KHighness&quot;, 19);
        String jsonUser = new ObjectMapper().writeValueAsString(user);
        redisTemplate.opsForValue().set(&quot;user&quot;, user);
        log.info(redisTemplate.opsForValue().get(&quot;user&quot;));
    &#125;

    @Test
    void test3() &#123;
        HashMap hashMap = new HashMap&lt;String, String&gt;();
        hashMap.put(&quot;name1&quot;, &quot;KHighness&quot;);
        hashMap.put(&quot;name2&quot;, &quot;ParaK&quot;);
        hashMap.put(&quot;name3&quot;, &quot;FlowerK&quot;);
        redisUtil.hmset(&quot;K&quot;, hashMap);
        for (Map.Entry k : redisUtil.hmget(&quot;K&quot;).entrySet()) &#123;
            log.info(k.toString());
        &#125;
    &#125;

&#125;</code></pre>
<blockquote>
<p>运行结果</p>
</blockquote>
<pre><code class="java">
                        __ __ __    _       __
                       / //_// /_  (_)___ _/ /_  ____  ___  __________
                      / ,&lt;  / __ \/ / __ `/ __ \/ __ \/ _ \/ ___/ ___/
                     / /| |/ / / / / /_/ / / / / / / /  __(__  |__  )
                    /_/ |_/_/ /_/_/\__, /_/ /_/_/ /_/\___/____/____/
                                  /____/

                     Copyright © 2020 KHighness. All Rights Reserved

2020-10-12 13:36:35.073  INFO 18840 --- [           main] t.parak.SpringbootRedisApplicationTest   : No active profile set, falling back to default profiles: default
2020-10-12 13:36:35.417  INFO 18840 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Multiple Spring Data modules found, entering strict repository configuration mode!
2020-10-12 13:36:35.420  INFO 18840 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data Redis repositories in DEFAULT mode.
2020-10-12 13:36:35.445  INFO 18840 --- [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 10ms. Found 0 Redis repository interfaces.
2020-10-12 13:36:35.534  INFO 18840 --- [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory id=8d774ca9-71ca-37a9-91e1-35cd9af79e44
2020-10-12 13:36:35.699  INFO 18840 --- [           main] trationDelegate$BeanPostProcessorChecker : Bean &#39;org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration&#39; of type [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$$67ea5b63] is not eligible for getting processed by all BeanPostProcessors (for example: not eligible for auto-proxying)
2020-10-12 13:36:36.483  INFO 18840 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService &#39;applicationTaskExecutor&#39;
2020-10-12 13:36:36.818  INFO 18840 --- [           main] t.parak.SpringbootRedisApplicationTest   : Started SpringbootRedisApplicationTest in 2.287 seconds (JVM running for 3.29)

2020-10-12 13:36:37.191  INFO 18840 --- [           main] io.lettuce.core.EpollProvider            : Starting without optional epoll library
2020-10-12 13:36:37.192  INFO 18840 --- [           main] io.lettuce.core.KqueueProvider           : Starting without optional kqueue library
2020-10-12 13:36:37.740  INFO 18840 --- [           main] t.parak.SpringbootRedisApplicationTest   : K殿下

2020-10-12 13:36:37.762  INFO 18840 --- [           main] t.parak.SpringbootRedisApplicationTest   : 6

2020-10-12 13:36:37.802  INFO 18840 --- [           main] t.parak.SpringbootRedisApplicationTest   : User(name=KHighness, age=19)

2020-10-12 13:36:37.836  INFO 18840 --- [           main] t.parak.SpringbootRedisApplicationTest   : name3=FlowerK
2020-10-12 13:36:37.836  INFO 18840 --- [           main] t.parak.SpringbootRedisApplicationTest   : name2=ParaK
2020-10-12 13:36:37.836  INFO 18840 --- [           main] t.parak.SpringbootRedisApplicationTest   : name1=KHighness</code></pre>
<h2 id="11-📩Redis持久化"><a href="#11-📩Redis持久化" class="headerlink" title="11. 📩Redis持久化"></a>11. 📩Redis持久化</h2><blockquote>
<p>📌tip</p>
</blockquote>
<p>Redis是内存数据库，如果不将内存中的数据库状态保存在磁盘，那么一旦服务器进程退出，服务器中的数据库状态也会消失。所以Redis提供了持久化功能。</p>
<ul>
<li><p>Redis默认是按照快照RDB的持久化方式</p>
</li>
<li><p>Redis重启的时候会优先使用AOF文件还原数据库状态</p>
</li>
</ul>
<h3 id="11-1-📁RDB"><a href="#11-1-📁RDB" class="headerlink" title="11.1 📁RDB"></a>11.1 📁RDB</h3><blockquote>
<p>🔔RDB = Redis Database</p>
</blockquote>
<p>将内存中的数据以快照”RDB”的形式将数据持久化到磁盘的一个二进制文件dump.rdb，定时保存。</p>
<blockquote>
<p>🔨配置</p>
</blockquote>
<pre><code>save 900 1    # 15分钟备份一次
save 300 10   # 如果在300s内，至少有10个key进行了修改，就进行持久化操作
save 60 10000 # 如果在60s内，至少有10000个key进行了修改，就进行持久化操作</code></pre>
<p>可以在24小时内，每小时备份一次，并且在每个月的每一天也备份一个RDB文件。</p>
<p>这样的话，即使遇上问题，也可以随时将数据集恢复到不同的版本。</p>
<blockquote>
<p>🔍工作机制</p>
</blockquote>
<p>Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何I/O操作的。这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加高效。RDB的<strong>缺点是最后一次持久化后的数据可能丢失</strong>。我们默认的就是RDB，一般情况下不需要修改这个配置。</p>
<blockquote>
<p>💣触发机制</p>
</blockquote>
<ul>
<li>save的规则满足的情况下，会自动触发rdb规则</li>
<li>执行flushall命令，也会触发rdb规则</li>
<li>退出redis，也会产生rdb文件</li>
</ul>
<blockquote>
<p>💟恢复rdb</p>
</blockquote>
<ul>
<li><p>将rdb文件放在redis启动目录，redis服务器启动的时候就会自动检查dump.rdb，恢复其中的数据</p>
</li>
<li><p>查看需要存在的位置</p>
</li>
</ul>
<pre><code class="shell">127.0.0.1:6379&gt; config get dir
1) &quot;dir&quot;
2) &quot;/usr/local/bin&quot; # 如果在这个目录下存在dump.rdb文件，启动就会自动恢复其中的数据</code></pre>
<blockquote>
<p>🌠优点缺点</p>
</blockquote>
<p>优点：</p>
<ul>
<li><p>适合大规模的数据恢复(适合文件备份)</p>
</li>
<li><p>对数据的完整性要求不高</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li><p>Redis服务器宕机时会丢失数据</p>
</li>
<li><p>fork进程会占用一定的内容空间</p>
</li>
</ul>
<h3 id="11-2-📁AOF"><a href="#11-2-📁AOF" class="headerlink" title="11.2 📁AOF"></a>11.2 📁AOF</h3><blockquote>
<p>🔔AOF = Append Only Mode</p>
</blockquote>
<p>把所有的对Redis的服务器进行修改的命令都存到一个文件(默认为appendonly.aof)里，命令的集合。</p>
<blockquote>
<p>🔔配置</p>
</blockquote>
<pre><code class="shell">appendonly yes # 开启AOF
appendfsync yes # 默认开启同步
appendfsync always # 每次数据修改发生时候都会写入AOF文件
appendfsync everysec # 每秒钟同步一次，这个死AOF的缺省策略</code></pre>
<blockquote>
<p>📝AOF重写</p>
</blockquote>
<ul>
<li>AOF文件的大小随着时间的流逝一定越来越大，影响包括但不限于：对于Redis服务器计算机的存储压力；AOF还原数据库状态的时间增加</li>
<li>为了解决AOF文件体积膨胀的问题，Redis提供了AOF重写功能：Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个文件所保存的数据库状态是相同的，但是新的AOF 文件不会包含任何浪费空间的冗余命令，通常会较旧AOF文件小很多</li>
</ul>
<p>Redis会在最近一次重写后记住AOF文件的大小，将次基本大小与当前大小进行比较，如果当前大小大于指定的百分比，则触发重写。</p>
<p>指定零百分比可以禁用重写功能。</p>
<pre><code class="shell">auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size 64mb # 触发重写的AOF文件的最小大小</code></pre>
<blockquote>
<p>💢产生问题</p>
</blockquote>
<p>每次重启Redis的时候，会优先使用AOF文件还原数据。</p>
<p>如果AOF文件以外产生错位，或者人工意外改写，可以通过<code>redis-check-aof --fix appendonly.aof</code>修复文件</p>
<pre><code class="shell">[root@master bin]# redis-check-aof --fix appendonly.aof 
&#39;x              3f: Expected prefix &#39;*&#39;, got: &#39;
AOF analyzed: size=114, ok_up_to=63, diff=51
This will shrink the AOF from 114 bytes, with 51 bytes, to 63 bytes
Continue? [y/N]: y
Successfully truncated AOF</code></pre>
<blockquote>
<p>🌠优点缺点</p>
</blockquote>
<p>优点：</p>
<ul>
<li>AOF会让redis变得非常耐久，AOF的默认策略是每秒同步一次，在这种配置下，就算Redis服务器宕机，也最多丢失一秒钟的数据</li>
</ul>
<p>缺点：</p>
<ul>
<li>对于相同的数据集来说，AOF的文件体积要大于RDB的文件体积，数据恢复的速度更慢</li>
<li>根据所使用的sync策略，AOF的速度可能慢于RDB</li>
</ul>
<h2 id="12-📩Redis发布订阅"><a href="#12-📩Redis发布订阅" class="headerlink" title="12. 📩Redis发布订阅"></a>12. 📩Redis发布订阅</h2><h3 id="12-1-💬说明"><a href="#12-1-💬说明" class="headerlink" title="12.1 💬说明"></a>12.1 💬说明</h3><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者(pub) 发送方消息，订阅者(sub)接收消息。</p>
<p>Redis客户端可以订阅任意数量的频道。</p>
<h3 id="12-2-📷模型"><a href="#12-2-📷模型" class="headerlink" title="12.2 📷模型"></a>12.2 📷模型</h3><blockquote>
<p>🗼订阅模型</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201125132811770.png" class="" title="image-20201125132811770">

<blockquote>
<p>🗽消息模型</p>
</blockquote>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/image-20201125132839908.png" class="" title="image-20201125132839908">



<blockquote>
<p>📜发布订阅命令</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">psubscribe pattern [pattern …]</td>
<td align="center">订阅一个或多个符合给定模式的频道</td>
</tr>
<tr>
<td align="center">pubsub subcommand [argument [argument …]]</td>
<td align="center">查看订阅与发布系统状态</td>
</tr>
<tr>
<td align="center">publish channel message</td>
<td align="center">将消息发送到指定的频道</td>
</tr>
<tr>
<td align="center">punsubscribe channel [channel …]</td>
<td align="center">退订所有给定模式的频道</td>
</tr>
<tr>
<td align="center">subscribe channel [channel …]</td>
<td align="center">订阅给定的一个或多个频道的信息</td>
</tr>
<tr>
<td align="center">unsubscribe [channel [channel …]]</td>
<td align="center">退订给定的频道</td>
</tr>
</tbody></table>
<blockquote>
<p>🎏演示</p>
</blockquote>
<p>开启三个redis-cli</p>
<pre><code class="shell"># 第一个客户端，订阅频道：Khighness
127.0.0.1:6379&gt; subscribe Khighness
Reading messages... (press Ctrl-C to quit)
1) &quot;subscribe&quot;
2) &quot;Khighness&quot;
3) (integer) 1
1) &quot;message&quot;
2) &quot;Khighness&quot;

# 第二个客户端，在频道Khighness发布消息
127.0.0.1:6379&gt; publish Khighness &quot;Client1: Hello, Khighness&quot;
(integer) 1

# 第三个客户端，在频道Khighness发布消息
127.0.0.1:6379&gt; publish Khighness &quot;Client3: Hello, Khighness&quot;
(integer) 1

# 订阅频道的第一个客户端就能收到消息
1) &quot;message&quot;
2) &quot;Khighness&quot;
3) &quot;Client2: Hello, Khighness&quot;
1) &quot;message&quot;
2) &quot;Khighness&quot;
3) &quot;Client3: Hello, Khighness&quot;</code></pre>
<blockquote>
<p>🕵️原理</p>
</blockquote>
<p>Redis是C语言编写的，通过分析Redis源代码里面的pubsub.c文件，了解发布和订阅机制的底层实现。</p>
<p>通过subscribe命令订阅某频道后，redis-server里维护了一个字典，字典的键就是一个个频道channel，而字典的值则是一个个链表，链表中保存了所有订阅这个频道的客户端client。subscribe命令的关键，就是将client添加到给定channel的订阅链中。</p>
<p>通过publish命令向订阅者发送消息，redis-server会使用给定的频道作为键，在它所维护的channel字典查找记录了订阅这个频道的所有客户端的链表，遍历这个链表，将消息发布给所有订阅者。</p>
<p>在Redis中，可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到响应的消息。这一功能最明显的用法就是用作实时消息系统，普通的即时聊天和群聊功能。</p>
<h2 id="13-📩Redis主从复制"><a href="#13-📩Redis主从复制" class="headerlink" title="13. 📩Redis主从复制"></a>13. 📩Redis主从复制</h2><h3 id="13-1-📖概念"><a href="#13-1-📖概念" class="headerlink" title="13.1 📖概念"></a>13.1 📖概念</h3><p>主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主结点(master)，后者称为从结点(slave)；数据的复制是单向的，只能由主节点到从结点。master以写为主，salve以读为主。</p>
<p>默认情况下，每台Redis服务器都是主结点；且一个主结点可以有多个从结点(或没有从结点)，但一个从结点只能有一个主节点。</p>
<h3 id="13-2-🔧作用"><a href="#13-2-🔧作用" class="headerlink" title="13.2 🔧作用"></a>13.2 🔧作用</h3><ol>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复，实际上是一种服务的冗余</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供读服务，分担服务器负载；尤其是在写少读多的场景下，通过多个从结点分担读负载，可以大大提高Redis服务器的并发量</li>
<li>高可用基石：主从复制是哨兵和集群可实施的基础，因此说主从复制是Redis高可用的基础</li>
</ol>
<h3 id="13-3-🔍复制原理"><a href="#13-3-🔍复制原理" class="headerlink" title="13.3 🔍复制原理"></a>13.3 🔍复制原理</h3><p>slave启动成功连接到master后会发送一个sync同步命令。</p>
<p>master接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。</p>
<p><strong>全量复制</strong>：slave服务在接收到数据库文件后，将其存盘并加载到内存中。</p>
<p><strong>增量复制</strong>：master继续将新的所有收集到的修改命令依次传给slave，完成同步。</p>
<p>但是只要是重新连接master，一次完全同步(全量复制)将被自动执行。</p>
<h2 id="14-📩Redis集群搭建"><a href="#14-📩Redis集群搭建" class="headerlink" title="14. 📩Redis集群搭建"></a>14. 📩Redis集群搭建</h2><h3 id="14-1-🔱方法"><a href="#14-1-🔱方法" class="headerlink" title="14.1 🔱方法"></a>14.1 🔱方法</h3><p>==搭建临时伪集群，命令操作即可==</p>
<p>主要操作：<strong>操作从机，认老大。</strong></p>
<p>查看redis服务器信息：<code>info replication</code></p>
<p>在从机上认老大master：<code>slaveof &lt;master-ip&gt; &lt;master-port&gt;</code></p>
<p>==搭建永久集群，修改配置文件==</p>
<p>主要操作：修改redis-conf文件</p>
<pre><code class="shell">replicaof &lt;masterip&gt; &lt;masterport&gt;  # 配置master的ip和端口号
masterauth &lt;master-passwordd&gt;      # 如果master有密码则配置密码</code></pre>
<p>==master关机解决——谋权篡位==</p>
<p>通过<code>slaveof no one</code>让slave自己变成master</p>
<h3 id="14-2-🔪操作"><a href="#14-2-🔪操作" class="headerlink" title="14.2 🔪操作"></a>14.2 🔪操作</h3><ol>
<li>复制三份redis.conf文件，修改信息<ul>
<li>port</li>
<li>logfile</li>
<li>pidfile</li>
<li>dbfilename</li>
</ul>
</li>
<li>分别在三个配置文件下启动redis服务</li>
</ol>
<pre><code class="shell">[root@master bin]# ps -ef | grep redis
root      18914      1  0 00:54 ?        00:01:38 redis-server 127.0.0.1:6379
root      31612      1  0 11:51 ?        00:00:00 redis-server 127.0.0.1:6380
root      31623      1  0 11:51 ?        00:00:00 redis-server 127.0.0.1:6381
root      31634  31340  0 11:51 pts/2    00:00:00 grep --color=auto redis</code></pre>
<ol start="3">
<li>开启三个终端开启三个redis客户端分别连接三个redis服务器</li>
</ol>
<pre><code class="shell"># Terminal1
[parak@master bin]$ redis-cli -p 6379
# Terminal2
[parak@master bin]$ redis-cli -p 6380
# Terminal3
[parak@master bin]$ redis-cli -p 6381</code></pre>
<ol start="4">
<li>将6379端口的服务的配置成master，另外两个配置成slave</li>
</ol>
<pre><code class="shell"># 6380
127.0.0.1:6380&gt; slaveof 127.0.0.1 6379
OK
127.0.0.1:6380&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:3
master_sync_in_progress:0
slave_repl_offset:14
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:9c3e61afce386f90c00db9ee4e9a2e7b4b265297
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:14
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:14

# 6381
127.0.0.1:6381&gt; slaveof 127.0.0.1 6379
OK
127.0.0.1:6381&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6379
master_link_status:up
master_last_io_seconds_ago:8
master_sync_in_progress:0
slave_repl_offset:42
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:9c3e61afce386f90c00db9ee4e9a2e7b4b265297
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:42
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:43
repl_backlog_histlen:0

# 6379
127.0.0.1:6379&gt; info replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6380,state=online,offset=2087,lag=0
slave1:ip=127.0.0.1,port=6381,state=online,offset=2087,lag=0
master_replid:9c3e61afce386f90c00db9ee4e9a2e7b4b265297
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:2087
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:2087</code></pre>
<ol start="5">
<li>在master上写入值，在slave上读取值</li>
</ol>
<pre><code class="shell"># 6379
127.0.0.1:6379&gt; hmset student:1 name Khighness gender male age 19
OK
127.0.0.1:6379&gt; hmset student:2 name bingyao gender female age 16
OK
# 6380
127.0.0.1:6380&gt; hmget student:1 name gender age
1) &quot;Khighness&quot;
2) &quot;male&quot;
3) &quot;19&quot;
# 6381
127.0.0.1:6381&gt; hmget student:2 name gender age
1) &quot;bingyao&quot;
2) &quot;female&quot;
3) &quot;16&quot;

# slave只能读取，不能写入
127.0.0.1:6380&gt; set K2 V2
(error) READONLY You can&#39;t write against a read only replica</code></pre>
<h2 id="15-📩Redis哨兵模式"><a href="#15-📩Redis哨兵模式" class="headerlink" title="15. 📩Redis哨兵模式"></a>15. 📩Redis哨兵模式</h2><p><del>驾校手动挡=&gt;上路自动挡</del></p>
<h3 id="15-1-📙概述"><a href="#15-1-📙概述" class="headerlink" title="15.1 📙概述"></a>15.1 📙概述</h3><p>主从切换技术的方法：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。Redis从2.8开始正式提供了Sentinel(哨兵)架构来解决这个问题。</p>
<p>简单来说，哨兵模式就是谋权篡位的自动版，能够后台监控主机是否故障，如果发生故障则根据投票数自动将库转换为主库。</p>
<p>哨兵模式是一种特殊的模式，首先Redis提供了哨兵的命令，哨兵是一个独立的进程，作为进程，它会独立运行。</p>
<p>原理：哨兵通过发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p>
<div class="mermaid">
graph TD;
	A((哨兵))
	B(主Redis服务器)
	C(从Redis服务器1)
	D(从Redis服务器2)
	S[以独立的进程监控3台服务器Redis是否正常运行] 
	S --&gt; A
	A --&gt; C
	A --&gt; B
	A --&gt; D
	B --&gt; C
	B --&gt; D</div>




<p>这里的哨兵有两个作用：</p>
<ul>
<li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器</li>
<li>当哨兵监测到master宕机，会自动将slave切换为master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机</li>
</ul>
<p>一个哨兵进程对Redis服务器进行监控，可能会出现问题，为此，我们可以使用多个哨兵进行监控，各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</p>
<img src= "https://cdn.jsdelivr.net/gh/Khighness/cdn/common/loading.gif" data-lazy-src="/posts/bae4ff13/sentinel.jpg" class="" title="sentinel">



<p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行failover过程，仅仅是哨兵1主管的认为主服务器不可用，仅仅是哨兵1主观的认为主服务器不可用，这个现象称为主观下线，当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行failover[故障转移]操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。</p>
<h3 id="15-2-🎏测试"><a href="#15-2-🎏测试" class="headerlink" title="15.2 🎏测试"></a>15.2 🎏测试</h3><p>准备三个redis服务，6379-master、6380-slave、6381-slave</p>
<p>修改配置文件sentinel.conf</p>
<pre><code class="shell">sentinel monitor mymaster 127.0.0.1 6379 1</code></pre>
<p>启动哨兵</p>
<pre><code class="shell">34055:X 20 Oct 2020 14:39:15.404 * Increased maximum number of open files to 10032 (it was originally set to 1024).
                _._                                                  
           _.-``__ &#39;&#39;-._                                             
      _.-``    `.  `_.  &#39;&#39;-._           Redis 5.0.8 (00000000/0) 64 bit
  .-`` .-```.  ```\/    _.,_ &#39;&#39;-._                                   
 (    &#39;      ,       .-`  | `,    )     Running in sentinel mode
 |`-._`-...-` __...-.``-._|&#39;` _.-&#39;|     Port: 26379
 |    `-._   `._    /     _.-&#39;    |     PID: 34055
  `-._    `-._  `-./  _.-&#39;    _.-&#39;                                   
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|                                  
 |    `-._`-._        _.-&#39;_.-&#39;    |           http://redis.io        
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;                                   
 |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|                                  
 |    `-._`-._        _.-&#39;_.-&#39;    |                                  
  `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;                                   
      `-._    `-.__.-&#39;    _.-&#39;                                       
          `-._        _.-&#39;                                           
              `-.__.-&#39;                                               

34055:X 20 Oct 2020 14:39:15.407 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.
34055:X 20 Oct 2020 14:39:15.408 # Sentinel ID is dbfb304470e8ed2bb81b4be42f847e21ff5d9519
34055:X 20 Oct 2020 14:39:15.408 # +monitor master mymaster 127.0.0.1 6379 quorum 1
34055:X 20 Oct 2020 14:40:15.646 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:40:25.731 * +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379</code></pre>
<p>关闭master服务</p>
<pre><code class="shell"># 6379: master -&gt; shutdown
127.0.0.1:6379&gt; SHUTDOWN
not connected&gt; exit

# sentinel
# 监控到master宕机
# 选出6380为master
34055:X 20 Oct 2020 14:43:47.509 # +sdown master mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:47.509 # +odown master mymaster 127.0.0.1 6379 #quorum 1/1
34055:X 20 Oct 2020 14:43:47.509 # +new-epoch 1
34055:X 20 Oct 2020 14:43:47.509 # +try-failover master mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:47.510 # +vote-for-leader dbfb304470e8ed2bb81b4be42f847e21ff5d9519 1
34055:X 20 Oct 2020 14:43:47.510 # +elected-leader master mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:47.510 # +failover-state-select-slave master mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:47.594 # +selected-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:47.594 * +failover-state-send-slaveof-noone slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:47.678 * +failover-state-wait-promotion slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:48.296 # +promoted-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:48.296 # +failover-state-reconf-slaves master mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:48.371 * +slave-reconf-sent slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:49.310 * +slave-reconf-inprog slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:49.310 * +slave-reconf-done slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:49.362 # +failover-end master mymaster 127.0.0.1 6379
34055:X 20 Oct 2020 14:43:49.362 # +switch-master mymaster 127.0.0.1 6379 127.0.0.1 6380
34055:X 20 Oct 2020 14:43:49.362 * +slave slave 127.0.0.1:6381 127.0.0.1 6381 @ mymaster 127.0.0.1 6380
34055:X 20 Oct 2020 14:43:49.362 * +slave slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380
34055:X 20 Oct 2020 14:44:19.365 # +sdown slave 127.0.0.1:6379 127.0.0.1 6379 @ mymaster 127.0.0.1 6380

# 6380: 新王登基
127.0.0.1:6380&gt; info replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6381,state=online,offset=42337,lag=1
master_replid:12a540accf0c9347d3e45fad83ccddea86f3b3c3
master_replid2:b80e4fbbe06a83ac070f38e89267bd81b26ec5ca
master_repl_offset:42351
second_repl_offset:20188
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:8342
repl_backlog_histlen:34010

# 6381: 参拜新王
127.0.0.1:6381&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:0
master_sync_in_progress:0
slave_repl_offset:63969
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:12a540accf0c9347d3e45fad83ccddea86f3b3c3
master_replid2:b80e4fbbe06a83ac070f38e89267bd81b26ec5ca
master_repl_offset:63969
second_repl_offset:20188
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:8053
repl_backlog_histlen:55917

# 重启6379的服务
# 重启之后俯首称臣
[root@master bin]# redis-server kconfig/redis6379.conf 
[root@master bin]# redis-cli -p 6379
127.0.0.1:6379&gt; ping
PONG
127.0.0.1:6379&gt; info relplication
127.0.0.1:6379&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:2
master_sync_in_progress:0
slave_repl_offset:50522
slave_priority:100
slave_read_only:1
connected_slaves:0
master_replid:12a540accf0c9347d3e45fad83ccddea86f3b3c3
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:50522
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:48596
repl_backlog_histlen:1927</code></pre>
<h3 id="15-3-🌠优点"><a href="#15-3-🌠优点" class="headerlink" title="15.3 🌠优点"></a>15.3 🌠优点</h3><ul>
<li>哨兵集群，基于主从复制模式，继承了主从的所有优点</li>
<li>主从可以切换，故障可以转移，增强系统的可用性</li>
<li>哨兵模式是主从模式的升级版，手动到自动，更加健壮</li>
</ul>
<h3 id="15-4-📰配置详解"><a href="#15-4-📰配置详解" class="headerlink" title="15.4 📰配置详解"></a>15.4 📰配置详解</h3><pre><code class="shell"># sentinel.conf

# 哨兵sentinel实例运行的端口，默认26379
port 26379

# 守护进程 
daemonize no

# 进程文件
pidfile &quot;/var/run/redis-sentinel.pid&quot;

# 进程文件
logfile &quot;&quot;

# 工作目录
dir &quot;/tmp&quot;

# 哨兵sentinel监控的master的IP和Port
# quorum配置多少个哨兵统一认为master失联。那么这时客观上认为主结点失联
sentinel monitor &lt;master-name&gt; &lt;master-ip&gt; &lt;redis-ip&gt; &lt;quorum&gt;

# 在redis实例中开启了授权密码
# 设置哨兵senti的连接密码
sentinel auth-pass &lt;master-name&gt; &lt;password&gt;

# 配置指定在发生failover主从切换时最多可以有多少个slave同时对新的master同步
# numreplicas越小，完成failover的事件就越长
# numreplicas越大，就意味着越多的slave因为replication(复制)而不可用
# numreplicas设置为1，保证每次只有slave处于不能处理命令请求的状态
sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;

# 配置指定多milliseconds毫秒之后，master没有响应sentinel
# 此时，哨兵主观上认为master下线，默认30秒
sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;

# 配置故障转移的超时时间，默认2分钟
# 可以用于以下方面
# 1. 同一sentinel对同一个master两次failo ver的间隔时间
# 2. 当一个slave从一个错误的master那里同步数据开始计算时间，直至slave被纠正为向正确的master那里同步数据
# 3. 当想要取消一个正在进行的failover需要的时间
# 4. 当进行failover时，配置所有slaves指向新的master所需的最大时间
sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;

# 通知脚本
sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;

# 客户端重新配置主节点参数脚本
sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code></pre>
<h2 id="16-📩Redis穿透、击穿和雪崩"><a href="#16-📩Redis穿透、击穿和雪崩" class="headerlink" title="16. 📩Redis穿透、击穿和雪崩"></a>16. 📩Redis穿透、击穿和雪崩</h2><h3 id="16-1-🔥缓存穿透"><a href="#16-1-🔥缓存穿透" class="headerlink" title="16.1 🔥缓存穿透"></a>16.1 🔥缓存穿透</h3><blockquote>
<p>💭问题说明</p>
</blockquote>
<p>查询的key对应的数据不在redis缓存中，即缓存没有命中，于是向持久层数据库查询，数据库也没有，当请求量过大的时候，可能压垮数据库。</p>
<p>即大面积的缓存失效，大并发请求打崩DB。</p>
<blockquote>
<p>💖解决方法</p>
</blockquote>
<p>1️⃣<strong>参数校验</strong></p>
<p>在接口层增加校验，不合法的参数直接return，比如id&lt;0直接拦截。</p>
<p>2️⃣<strong>布隆过滤器</strong></p>
<p>利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return。</p>
<p>3️⃣<strong>缓存空对象</strong></p>
<p>当存储层不命中后，即使返回的空对象也将其缓存起来，同时会设置一个过期时间，之后再访问这个数据将会从缓存中获取，保护数据库。</p>
<h3 id="16-2-💧缓存击穿"><a href="#16-2-💧缓存击穿" class="headerlink" title="16.2 💧缓存击穿"></a>16.2 💧缓存击穿</h3><blockquote>
<p>💭问题说明</p>
</blockquote>
<p>查询的一个key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存。</p>
<p>即单个key的缓存失效，大并发请求击穿redis直落DB。</p>
<blockquote>
<p>💙解决方法</p>
</blockquote>
<p>设置热点数据永不过期，或者加上互斥锁。</p>
<pre><code class="java">public static String getData(String key) throws InterruptedException &#123;
        //从Redis查询数据
        String result = getDataByKV(key);
        //参数校验
        if (StringUtils.isBlank(result)) &#123;
            try &#123;
                //获得锁
                if (reenLock.tryLock()) &#123;
                    //去数据库查询
                    result = getDataByDB(key);
                    //校验
                    if (StringUtils.isNotBlank(result)) &#123;
                        //插进缓存
                        setDataToKV(key, result);
                    &#125;
                &#125; else &#123;
                    //睡一会再拿
                    Thread.sleep(100L);
                    result = getData(key);
                &#125;
            &#125; finally &#123;
                //释放锁
                reenLock.unlock();
            &#125;
        &#125;
        return result;
    &#125;</code></pre>
<h3 id="16-3-🌊缓存雪崩"><a href="#16-3-🌊缓存雪崩" class="headerlink" title="16.3 🌊缓存雪崩"></a>16.3 🌊缓存雪崩</h3><blockquote>
<p>💭问题说明</p>
</blockquote>
<p>当redis服务器重启或则大量缓存集中在某一个时间段失效，瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的</p>
<blockquote>
<p>💚解决方法</p>
</blockquote>
<p>1️⃣<strong>redis高可用</strong></p>
<p>搭建集群，异地多活</p>
<p>2️⃣<strong>限流降级</strong></p>
<p>在缓存失效后，通过加锁或者队列哎控制读数据库写缓存的线程数量</p>
<p>3️⃣<strong>数据预热</strong></p>
<p>在正式部署之前，先把可能的数据预先访问一遍，让可能的数据加载到缓存中。</p>
<p>在即将发生大并发访问写入key的时候，设置不同的缓存时间，让缓存失效的时间点尽量均匀。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://parak.top">Khighness</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://parak.top/posts/bae4ff13">https://parak.top/posts/bae4ff13</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"> CC BY-NC-SA 4.0 </a>许可协议。转载请注明来自<a href="https://www.parak.top">炒菜K殿下</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98/">缓存</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/wepay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/wepay.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/alipay.jpg" target="_blank"><img class="post-qr-code-img" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/avatar/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/f8cdfd0a/"><img class="prev-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-8.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">叶惠美</div></div></a></div><div class="next-post pull-right"><a href="/posts/83c5d7ce/"><img class="next-cover" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/top/bg-6.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/Khighness/cdn/common/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Regex</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Twikoo</span><span class="switch-btn"></span><span class="second-comment">Valine</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%F0%9F%93%A9NoSQL%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 📩NoSQL概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%F0%9F%93%83%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1 📃简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%F0%9F%8C%80%E7%89%B9%E7%82%B9"><span class="toc-text">1.2 🌀特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%F0%9F%9A%803V-3H"><span class="toc-text">1.3 🚀3V+3H</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%F0%9F%93%9A%E5%88%86%E7%B1%BB"><span class="toc-text">1.4 📚分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%F0%9F%93%88%E9%98%BF%E9%87%8C%E5%B7%B4%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B"><span class="toc-text">1.5 📈阿里巴技术演进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%F0%9F%93%A9Redis%E5%85%A5%E9%97%A8"><span class="toc-text">2. 📩Redis入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%F0%9F%93%91%E7%AE%80%E4%BB%8B"><span class="toc-text">2.1 📑简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%F0%9F%8C%A0%E7%89%B9%E6%80%A7"><span class="toc-text">2.2 🌠特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%F0%9F%94%B0%E6%8B%93%E5%B1%95"><span class="toc-text">2.3 🔰拓展</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%F0%9F%93%A9Redis%E5%AE%89%E8%A3%85"><span class="toc-text">3. 📩Redis安装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%F0%9F%92%BBWindows10-%E5%AE%89%E8%A3%85"><span class="toc-text">3.1 💻Windows10 安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%F0%9F%92%BBCentOS7-%E5%AE%89%E8%A3%85"><span class="toc-text">3.2 💻CentOS7 安装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%F0%9F%93%A9Redis%E9%85%8D%E7%BD%AE"><span class="toc-text">4. 📩Redis配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%F0%9F%9A%A9%E5%91%BD%E4%BB%A4"><span class="toc-text">4.1 🚩命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%F0%9F%93%9Dredis-conf-%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E"><span class="toc-text">4.2 📝redis.conf 配置项说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%F0%9F%94%8D-%E9%87%8D%E7%82%B9%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.3 🔍 重点详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%F0%9F%93%A9Redis%E6%B5%8B%E8%AF%95"><span class="toc-text">5. 📩Redis测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%F0%9F%94%AC%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95"><span class="toc-text">5.1🔬测试方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%F0%9F%93%9Dredis%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><span class="toc-text">5.2 📝redis性能测试工具可选参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%F0%9F%93%8A%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="toc-text">5.3 📊测试结果分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%F0%9F%93%A9Redis%E5%9F%BA%E7%A1%80"><span class="toc-text">6. 📩Redis基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%F0%9F%92%A0Redis%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">6.1 💠Redis数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%F0%9F%8C%8F6379%E7%9A%84%E6%95%85%E4%BA%8B"><span class="toc-text">6.2 🌏6379的故事</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E2%9A%A1Redis%E8%9C%9C%E6%B1%81%E9%80%9F%E5%BA%A6"><span class="toc-text">6.3 ⚡Redis蜜汁速度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%F0%9F%93%A9Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">7. 📩Redis数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%F0%9F%8F%86%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.1 🏆五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-%E2%9A%BDString"><span class="toc-text">7.1.1 ⚽String</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E2%9A%BEList"><span class="toc-text">7.1.2 ⚾List</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%F0%9F%8F%80Set"><span class="toc-text">7.1.3 🏀Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-%F0%9F%8F%88Hash"><span class="toc-text">7.1.4 🏈Hash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-5-%F0%9F%8F%89Sorted-Set"><span class="toc-text">7.1.5 🏉Sorted Set</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%F0%9F%8C%8C%E4%B8%89%E7%A7%8D%E7%89%B9%E6%AE%8A%E7%B1%BB%E5%9E%8B"><span class="toc-text">7.2 🌌三种特殊类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%F0%9F%94%AEGeospatial"><span class="toc-text">7.2.1 🔮Geospatial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%F0%9F%93%84HyperLogLog"><span class="toc-text">7.2.2 📄HyperLogLog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%F0%9F%94%B3Bitmaps"><span class="toc-text">7.1.3 🔳Bitmaps</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%F0%9F%93%A9Redis%E4%BA%8B%E5%8A%A1"><span class="toc-text">8. 📩Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1%F0%9F%93%96%E5%AE%9A%E4%B9%89"><span class="toc-text">8. 1📖定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%F0%9F%8C%A0%E7%89%B9%E5%BE%81"><span class="toc-text">8.2 🌠特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E2%8F%B3%E4%B8%89%E4%B8%AA%E9%98%B6%E6%AE%B5"><span class="toc-text">8.3 ⏳三个阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%F0%9F%93%9D%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-text">8.4 📝操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%F0%9F%95%B5%EF%B8%8F%E5%AE%9E%E4%BE%8B"><span class="toc-text">8.5 🕵️实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-%E2%AD%95%E5%BC%82%E5%B8%B8"><span class="toc-text">8.6 ⭕异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-7-%F0%9F%94%AD%E7%9B%91%E6%8E%A7"><span class="toc-text">9.7 🔭监控</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%F0%9F%93%A9Jedis"><span class="toc-text">9. 📩Jedis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E2%9E%95%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="toc-text">9.1 ➕导入依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E2%8C%A8%EF%B8%8F%E7%BC%96%E7%A0%81%E6%B5%8B%E8%AF%95"><span class="toc-text">9.2 ⌨️编码测试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%F0%9F%85%BFPing%E6%B5%8B%E8%AF%95"><span class="toc-text">9.2.1 🅿Ping测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E2%9A%AAGEO-api%E6%B5%8B%E8%AF%95"><span class="toc-text">9.2.1 ⚪GEO-api测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E2%9A%ABHyper-api%E6%B5%8B%E8%AF%95"><span class="toc-text">9.2.2 ⚫Hyper-api测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3-%F0%9F%94%B4Bitmaps-api%E6%B5%8B%E8%AF%95"><span class="toc-text">9.2.3 🔴Bitmaps-api测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-4-%F0%9F%94%B5%E4%BA%8B%E5%8A%A1%E6%B5%8B%E8%AF%95"><span class="toc-text">9.2.4 🔵事务测试</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%F0%9F%93%A9Springboot%E6%95%B4%E5%90%88"><span class="toc-text">10. 📩Springboot整合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-%F0%9F%94%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">10.1 🔎源码分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-%F0%9F%94%91%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">10.2 🔑整合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-%F0%9F%92%A8api%E6%B5%8B%E8%AF%95"><span class="toc-text">10.3 💨api测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%F0%9F%93%A9Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">11. 📩Redis持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%F0%9F%93%81RDB"><span class="toc-text">11.1 📁RDB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%F0%9F%93%81AOF"><span class="toc-text">11.2 📁AOF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%F0%9F%93%A9Redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-text">12. 📩Redis发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-%F0%9F%92%AC%E8%AF%B4%E6%98%8E"><span class="toc-text">12.1 💬说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-%F0%9F%93%B7%E6%A8%A1%E5%9E%8B"><span class="toc-text">12.2 📷模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%F0%9F%93%A9Redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-text">13. 📩Redis主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%F0%9F%93%96%E6%A6%82%E5%BF%B5"><span class="toc-text">13.1 📖概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%F0%9F%94%A7%E4%BD%9C%E7%94%A8"><span class="toc-text">13.2 🔧作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%F0%9F%94%8D%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="toc-text">13.3 🔍复制原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%F0%9F%93%A9Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA"><span class="toc-text">14. 📩Redis集群搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-%F0%9F%94%B1%E6%96%B9%E6%B3%95"><span class="toc-text">14.1 🔱方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-%F0%9F%94%AA%E6%93%8D%E4%BD%9C"><span class="toc-text">14.2 🔪操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%F0%9F%93%A9Redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="toc-text">15. 📩Redis哨兵模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#15-1-%F0%9F%93%99%E6%A6%82%E8%BF%B0"><span class="toc-text">15.1 📙概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-2-%F0%9F%8E%8F%E6%B5%8B%E8%AF%95"><span class="toc-text">15.2 🎏测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-3-%F0%9F%8C%A0%E4%BC%98%E7%82%B9"><span class="toc-text">15.3 🌠优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-4-%F0%9F%93%B0%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="toc-text">15.4 📰配置详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%F0%9F%93%A9Redis%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E5%92%8C%E9%9B%AA%E5%B4%A9"><span class="toc-text">16. 📩Redis穿透、击穿和雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-1-%F0%9F%94%A5%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-text">16.1 🔥缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-2-%F0%9F%92%A7%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-text">16.2 💧缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-3-%F0%9F%8C%8A%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-text">16.3 🌊缓存雪崩</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/Khighness/cdn/common/footer.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Khighness</div><div class="footer_custom_text"><a href="https://www.foreverblog.cn/" target="_blank" > <img src="https://img.foreverblog.cn/logo_en_default.png" alt="" style="width:auto;height:16px;"> </a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">簡</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script><script>(()=>{
  const $countDom = document.getElementById('twikoo-count')
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'hexo-2grv2lyu1131c342',
      region: ''
    }, null))
  }

  const getCount = () => {
    twikoo.getCommentsCount({
      envId: 'hexo-2grv2lyu1131c342',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      $countDom.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const loadTwikoo = (bool = false) => {
    if (typeof twikoo === 'object') {
      init()
      bool && $countDom && setTimeout(getCount,0)
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(()=> {
        init()
        bool && $countDom && setTimeout(getCount,0)
      })
    }
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo(true)
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'Py2eOHzSdrnxKPzKrOJaHJOq-9Nh9j0Va',
      appKey: '9eQhwuCgyshpYKn4rtEhqt4R',
      placeholder: '',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: 'https://cdn.jsdelivr.net/gh/imaegoo/emotion/owo.json',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick, mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('/js/Valine.min.js').then(initValine)
}

if ('Twikoo' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'hexo-2grv2lyu1131c342',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.innerHTML= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}'>${array[i].content}</a>
        <div class='name'><span>${array[i].nick} / </span><time datetime="${array[i].date}">${btf.diffDate(array[i].date, true)}</time></div>
        </div></div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom.innerHTML= result
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})


document.addEventListener('pjax:send', function () {
  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>function history_calendar_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = '<div class="card-widget card-history"><div class="card-content"><div class="item-headline"><i class="fas fa-clock fa-spin"></i><span>那年今日</span></div><div id="history-baidu" style="height: 100px;overflow: hidden"><div class="history_swiper-container" id="history-container" style="width: 100%;height: 100%"><div class="swiper-wrapper" id="history_container_wrapper" style="height:20px"></div></div></div></div>';
                console.log('已挂载history_calendar')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='/'|| '/' ==='all')){

            history_calendar_injector_config()
        } </script><script data-pjax  src="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><!-- hexo injector body_end end --></body></html>