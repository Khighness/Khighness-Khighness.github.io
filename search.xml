<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BloomFilter</title>
    <url>/posts/13354/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>布隆过滤器（Bloom Filter）是布隆在1970年提出的，它实际上是由一个很长的bit数组和一系列hash函数组成，布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询效率都远远超出一般的算法，缺点是存在误差和删除困难。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>数组的每个元素都只占1bit空间，并且每个元素只能为0或1。<br>布隆过滤器还拥有K个哈希函数，当一个元素加入到布隆过滤器时会使用k个hash函数对其进行k次计算，得到k个哈希值，并且根据得到的哈希值，在位数组中把对应下标的值置为1。</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13354/image1.png" class="" title="image1"><br />
<p>判断某个元素是否在布隆过滤器中，就对钙元素进行k次哈希计算，得到的值在位数组中判断每个元素是否都为1，如果每个元素都为1，就说明这个值在布隆过滤器中。</p>
<h2 id="误差"><a href="#误差" class="headerlink" title="误差"></a>误差</h2><p>假设 hash 函数以等概率条件选择并设置 Bit Array 中的某一位，m 是该位数组的大小，k 是 hash 函数的个数。</p>
<p>位数组中某一特定的位在进行元素插入时的hash操作中没有被置为1的概率：<br>$$<br>1 - \frac{1}{m} \<br>$$<br>那么在所有k次hash操作后该位都没有被置为1的概率：<br>$$<br>(1 - \frac{1}{m})^k \<br>$$<br>插入n个元素后，某一位仍然为0的概率：<br>$$<br>(1 - \frac{1}{m})^{k \times n} \<br>$$<br>那么，任意一位为1的概率：<br>$$<br>1 - (1 - \frac{1}{m})^{k \times n} \<br>$$<br>误差率即k个位置都为1的概率：<br>$$<br>[1 - (1 - \frac{1}{m})^{k \times n}]^k \<br>= (1 - e^{-\frac{k \times n}{m}})^k \<br>$$</p>
<p>那么求误差最小时的k值，问题就转化为：</p>
<p>$$<br>对于 f(k) = (1 - e^{-\frac{m}{n}})，求其值最小时的k值。 \<br>$$<br>过程如下：</p>
<p>$$<br>令e^{\frac{n}{m}}=b，则f(k) = (1-b^{-k})^k \<br>$$</p>
<p>$$<br>等式两边取对数，\ln f(k) = k \times \ln (1-b^{-k}) \<br>$$</p>
<p>$$<br>等式两边求导数，\frac{1}{f(k)} \times {f^{‘}(k)} = \ln(1-b^{-k}) + k \times {\frac{1}{1-b^{-k}} \times (-b^{-k}) \times \ln (b) \times (-1)} \<br>$$</p>
<p>$$<br>简化，\frac{f^{‘}(k)}{f(k)} = \ln(1-b^{-k}) + k \times {\frac{b^{-k} \ln b}{1-b^{-k}}} \<br>$$</p>
<p>$$<br>令f^{‘}(k) = 0，则\ln(1-b^{-k}) + k \times {\frac{b^{-k} \ln b}{1-b^{-k}}} = 0 \<br>$$</p>
<p>$$<br>令1-b^{-k}=a，则b=-\frac{\ln (1-a)}{k} \<br>$$</p>
<p>$$<br>上式转化为，\ln a + {k} \times {\frac{(1-a) \times ({-\frac{1}{k}}) \times {\ln (1-a)}}{a}} = 0 \<br>$$</p>
<p>$$<br>简化，a \ln a = (1 - a) \ln (1-a) \<br>$$</p>
<p>$$<br>根据g(x) = xlnx的特性，a = 1 - a =&gt; a = \frac{1}{2} \<br>$$</p>
<p>$$<br>从而，1 - b^{-k} = \frac{1}{2} =&gt; b^{-k} = \frac{1}{2} \<br>$$</p>
<p>$$<br>所以，k = \frac{m}{n} \ln 2 \<br>$$</p>
<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>不同的哈希函数对于随机字符的测试结果如下：</p>
<table>
<thead>
<tr>
<th>哈希函数</th>
<th>时间(ns)</th>
<th>冲突个数</th>
<th>总个数</th>
</tr>
</thead>
<tbody><tr>
<td>SDBMHash</td>
<td>158062897</td>
<td>180</td>
<td>1000000</td>
</tr>
<tr>
<td>SimMurMurHash</td>
<td>144356292</td>
<td>108</td>
<td>1000000</td>
</tr>
<tr>
<td>JSHash</td>
<td>160829523</td>
<td>230</td>
<td>1000000</td>
</tr>
<tr>
<td>PJW</td>
<td>169142421</td>
<td>3901</td>
<td>1000000</td>
</tr>
<tr>
<td>MurMurHash2</td>
<td>144678973</td>
<td>129</td>
<td>1000000</td>
</tr>
<tr>
<td>ELFHash</td>
<td>173966075</td>
<td>3901</td>
<td>1000000</td>
</tr>
<tr>
<td>BKDRHash</td>
<td>160517055</td>
<td>258</td>
<td>1000000</td>
</tr>
<tr>
<td>CalcNrHash</td>
<td>180425843</td>
<td>124</td>
<td>1000000</td>
</tr>
<tr>
<td>APHash</td>
<td>166644369</td>
<td>245</td>
<td>1000000</td>
</tr>
<tr>
<td>BPHash</td>
<td>144647091</td>
<td>920005</td>
<td>1000000</td>
</tr>
<tr>
<td>FNVHash</td>
<td>160584860</td>
<td>109</td>
<td>1000000</td>
</tr>
<tr>
<td>RSHash</td>
<td>160316468</td>
<td>240</td>
<td>1000000</td>
</tr>
<tr>
<td>DJB</td>
<td>185411123</td>
<td>97</td>
<td>1000000</td>
</tr>
<tr>
<td>DJB2Hash</td>
<td>151799803</td>
<td>97</td>
<td>1000000</td>
</tr>
<tr>
<td>DEKHash</td>
<td>145856752</td>
<td>119</td>
<td>1000000</td>
</tr>
<tr>
<td>SipHashNoCase</td>
<td>205930199</td>
<td>126</td>
<td>1000000</td>
</tr>
<tr>
<td>SipHash</td>
<td>187972639</td>
<td>126</td>
<td>1000000</td>
</tr>
</tbody></table>
<p>经过很多素材的测试，最终选择了<code>MurmurHash2</code>函数。<br>​</p>
<blockquote>
<p>草稿</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13354/image2.jpg" class="" title="image2">
</blockquote>
]]></content>
      <categories>
        <category>BloomFilter</category>
      </categories>
      <tags>
        <tag>BloomFilter</tag>
      </tags>
  </entry>
  <entry>
    <title>疫念</title>
    <url>/posts/12327/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/12327/p1.jpg" class="" title="p1"><br />

<p>新时代的浩瀚，未来的乌托邦，我们未谋其面，铸剑台就被病毒摧毁。</p>
<p>不平凡的一年里，在线教育受国家制裁，互联网行业诸如OPPO、爱奇艺和蘑菇街等大幅裁员，还有教培转行、房企暴雷、平台经济反垄断等消息搅动市场。</p>
<p>与此同时，“双碳”目标下的新能源和新能源车产业蓬勃发展；硬科技站上风口成为资本眼中的香饽饽；元宇宙爆火，人类开始畅享创建一个虚拟的世界。</p>
<hr>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/12327/p2.jpg" class="" title="p2"><br />

<p>一个世纪前，世界爆发的流感感染了世界上四分之一的人口，这比第一次世界大战造成的死亡人数还要多。但是从客观上来讲，疫情和世界大战，在经济上产生了这样一个逻辑链条：</p>
<ol>
<li>灾难过后，世界进入报复性消费，需求瞬间上涨；</li>
<li>灾难期间，劳动力大量减少，面对蓬勃的需求，企业需要快速补充劳动力；</li>
<li>为了吸引劳动力加入，企业提高工资待遇；</li>
<li>工薪阶层收入提高，形成了一个庞大的可以实现“美国梦”的中产阶级群体；</li>
<li>手里有闲钱就去消费，对于消费品的需求大幅增长，依此不断循环。</li>
</ol>
<p>在一战之前，美国已经高速发展，在疫情和一战结束以后，美国不仅没有因为灾难一蹶不振，反而进入了第二波高速发展期，也就是所谓的咆哮的20年代。</p>
<p>时至今日，我们进入了一个新的20年代，虽然我们在很大范围上，解决了有没有的问题，而我们也到了要解决好不好的时候。这个时候，我们需要的不是更多的洛克菲特建立更多大平台，跟菜市场或者小商贩抢生意，打外卖小哥五险一金的主意，而是需要更多的福特和亚历桑德森，来发展核心竞争力，推动社会的发展。</p>
<hr>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/12327/p3.jpg" class="" title="p3"><br />

<p>有一个词，叫作「向死而生」，就是做最坏的打算，过好自己的生活。</p>
<p>疫情当下，我觉得也要怀着一个充满希望的态度，去看待这个时代和我们的生活。</p>
<p>我们可以像规划任期一样规划自己的生活，计划虽然赶不上变化，但是希望我们可以朝着那个方向去努力，同时，很期待这条路上的所有意外。</p>
<hr>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/12327/p4.jpg" class="" title="p4"><br />

<p>寒假了，我的大学从鹰击长空的开始，最终也只是掠过了一片原野。</p>
<p>大学教会了我很多，比如留长发？更重要的是，学会「跳出圈子看世界」。</p>
<p>当我在上大学的时候，我身边的人也在上大学。当我在为期末备战的时候，身边的人也在图书馆内卷。</p>
<p>或许勤奋，披星戴月，三点一线；或许安逸，小床一躺，游戏一打；或许平凡，按时上课，从不挂科。</p>
<p>为什么勤奋？为了成绩？证明自己？推免研究生？</p>
<p>为什么安逸？家有万贯？自甘堕落？就选择躺平？</p>
<p>当我们跳出读书的圈子，就发现并非所有人都如此。跳出所处的环境，去接触社会的其他方面。</p>
<p>当我们能够跳出圈子看世界的时候，在不一样的角度看待世界，或许就能看到不一样的格局，更容易看清自己在整个世界的定位，我们真正想要成为什么，迷茫之时不丢失自己的目标，而不是跟着身边人一样，不知道为何而勤奋或者因何而堕落，不知道大四时到底为何要考研还是去找工作。</p>
<p>我们的人生，也不该被某一个地点或者学校所标记，该学到的是一种学习方式和思维方式，而不是具体的知识点。未来我们会忘记很多事情，那些留在脑海里的东西，将会塑造我们的思维和人格。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>双蛋问题</title>
    <url>/posts/53991/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>谷歌的一道经典面试题 ——「双蛋问题」。</p>
<p>一个百层高大楼，从低层往下扔鸡蛋的时候，鸡蛋不会碎；从高层往下扔鸡蛋的时候，鸡蛋才会碎。<br>中间有一个临界楼层，在这个临界楼层以下的楼层扔，鸡蛋不会碎，超过这个楼层扔，鸡蛋会碎掉。</p>
<p>问题：如果拥有N个鸡蛋，最少要扔多少次，记为M，才能找出临界层？</p>
<h2 id="思路解析"><a href="#思路解析" class="headerlink" title="思路解析"></a>思路解析</h2><p>（1）N = 1<br>如果只有1个鸡蛋，那么只能从1层开始尝试，逐层尝试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、2、3、4、... 100</span><br></pre></td></tr></table></figure>

<p>最坏的情况就是在第100层扔鸡蛋，鸡蛋才碎掉。<br>因此，N = 1的时候，M=100。</p>
<p>（2）N = +⚮<br>如果有无限个鸡蛋，这时候可以采用二分法进行尝试：<br>$$<br>2^{M} \ge 100 \<br>$$</p>
<p>$$<br>M \ge \log_{2}{100} \<br>$$</p>
<p>$$<br>M \ge = 6.64 \<br>$$</p>
<p>$$<br>M = 7<br>$$</p>
<p>因此，N=+⚮的时候，M=7。</p>
<p>（3）N = 2<br>如果只有2个鸡蛋，让第一个鸡蛋A分别逐层尝试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10、20、30、40、50、60、70、80、90、100</span><br></pre></td></tr></table></figure>

<p>如果A在第「X」层没碎，但是在第「X+10」层碎了，那么让第二个鸡蛋B在区间(X, X+10)尝试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X+1、X+2、X+3、X+4、X+5、X+6、X+7、X+8、X+9</span><br></pre></td></tr></table></figure>

<p>这个方法，最好情况下只需要扔10（A1+B9）次，最坏情况下需要扔19（A10+B9）次。<br>它不平均，原因是因为A它确定的间隔是等间隔的，B的尝试次数就是一样的，临界楼层越靠后，A的尝试次数就越多。</p>
<p>所以，我们需要思考，能不能让间隔变得不等，就是说，A每多扔一次，B的搜索区间就缩小一点，这样一来让A和B的总次数平均一点。<br>下面，调整A每次扔鸡蛋的间隔，第一次间隔为n，第二次间隔为n-1，第三次间隔为n-2，最后一次间隔为1层，尝试楼层如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n、n+(n-1)、n+(n-1)+(n-2)、...、n(n+1)&#x2F;2</span><br></pre></td></tr></table></figure>

<p>从而，B的搜索区间长度就会呈现线性递减趋势：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(n, n+(n-1))、(n+(n-1), n+(n-1)+(n-2))、...(n(n+1)&#x2F;2-1, n(n+1)&#x2F;2)</span><br></pre></td></tr></table></figure>

<p>这样，A每多扔一次，B就少搜索一次，可以达到A和B的权衡。</p>
<p>$$<br>\frac{n \times {(n+1)}} {2} = 100 \<br>$$</p>
<p>$$<br>n \ge {13.65} \<br>$$</p>
<p>$$<br>n = 14 \<br>$$</p>
<p>这种方法，可以让M稳定在14。</p>
<h2 id="问题拓展"><a href="#问题拓展" class="headerlink" title="问题拓展"></a>问题拓展</h2><p>将问题拓展到更具有一般性的情况，可以参考「<a href="https://leetcode-cn.com/problems/super-egg-drop/">leetcode 887. 鸡蛋掉落</a>」。<br>简单描述：给定「n」层楼和「m」个鸡蛋，要求找到临界楼层「c」，最少需要尝试几次？</p>
<h2 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h2><p>求最值，不难想到经典DP（Dynamic Planning），打表格。<br>设尝试次数为「f」，F(i，j) 表示在「i」层楼和「j」个鸡蛋下找临界楼层的尝试次数。</p>
<p>只有1层楼或者只有1个鸡蛋的时候都只需要尝试1次，初始化表格如下：</p>
<table>
<thead>
<tr>
<th align="center">i \ f \ j</th>
<th align="center">1</th>
<th align="center">2</th>
<th align="center">3</th>
<th align="center">4</th>
<th align="center">5</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>无论如何，我们总要选择一层「k」，然后扔下去：</p>
<ul>
<li>如果碎了，那么「c」一定在「k」前面，同时鸡蛋数量减少一个，此时求解 f(k - 1，j - 1) ；</li>
<li>如果不碎，那么「c」一定在「k」后面，但是鸡蛋数量没有变化，此时求解 f(n - k，j)。</li>
</ul>
<p>在这两种情况下，我们需要取一个最大值，即：</p>
<p>$$<br>\max_{}(f(k-1, j-1), f(i-k, j)) \<br>$$</p>
<p>再加上这一次扔的次数，于是得到：</p>
<p>$$<br>f(i, j) = \max_{}(f(k-1, j-1), f(i-k, j)) + 1 \<br>$$</p>
<p>这个「k」无法确定，于是我们通过枚举取值方案，取最小值：<br>​<br>$$<br>f(i, j) = \min_{1 \le k \le i }(\max_{}(f(k-1, j-1), f(i-k, j)) + 1) \<br>$$</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>根据上面的状态转移方程，可以写出动态规划对应的代码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/53991/code1.png" class="" title="code1">

<br />

<p>这样写的话，时间复杂度达到O(KN^2)，空间复杂度是O(KN)。</p>
<h2 id="二分优化"><a href="#二分优化" class="headerlink" title="二分优化"></a>二分优化</h2><p>再看这个状态转移方程：</p>
<p>$$<br>f[i, j] = \min_{1 \le k \le i }(\max_{}(f[k-1, j-1], f[i-k, j]) + 1) \<br>$$</p>
<p>设碎蛋函数f1 = f(k - 1, j - 1)，未碎函数f2 = f(i - k, j)，那么f=min(f1, f2)。<br>方程最外层的变量是「k」，它枚举了扔下鸡蛋的楼层的高度，这里它是函数的自变量，将「i」和「j」视为常数，那么：</p>
<ul>
<li>对于f1：k增大的时候，楼层大小越大，它的值就越大，所以碎蛋函数是个单调递增函数；</li>
<li>对于f2：k增大的时候，楼层大小越小，它的值就越小，是个未碎函数是个单调递减函数。</li>
</ul>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/53991/f.svg" class="" title="f">

<br />
这就类似于寻找数据峰值问题，可以参考「leetcode 162. 寻找峰值」。

<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/53991/code2.png" class="" title="code2">

<br />


<p>最终，代码便可以优化成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> K 鸡蛋数量</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> N 楼层数量</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">superEggDrop</span><span class="params">(<span class="keyword">int</span> K, <span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// dp[i][j]表示i层楼j个鸡蛋，需要扔的次数</span></span><br><span class="line">     <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>][K + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 初始化 */</span></span><br><span class="line">     <span class="comment">// 求最小值，初始化取一个较大值</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">         Arrays.fill(dp[i], i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 楼层数量为0，扔0次</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= K; j++) &#123;</span><br><span class="line">         dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 楼层为0，没有鸡蛋，扔0次</span></span><br><span class="line">     dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">     <span class="comment">// 楼层为1，鸡蛋足够，扔1次</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= K; j++) &#123;</span><br><span class="line">         dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 鸡蛋为0，无法测试，扔0次</span></span><br><span class="line">     <span class="comment">// 鸡蛋为1，需要进行逐层尝试</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">         dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">         dp[i][<span class="number">1</span>] = i;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 递推状态 */</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= K; j++) &#123;</span><br><span class="line">             <span class="comment">// 在区间[1, i]里确定一个最优值</span></span><br><span class="line">             <span class="keyword">int</span> l = <span class="number">1</span>, r = i;</span><br><span class="line">             <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                 <span class="keyword">int</span> m = l + ((r - l + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">                 <span class="comment">// 碎蛋函数，递增</span></span><br><span class="line">                 <span class="keyword">int</span> f1 = dp[m - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                 <span class="comment">// 不碎函数，递减</span></span><br><span class="line">                 <span class="keyword">int</span> f2 = dp[i - m][j];</span><br><span class="line">                 <span class="keyword">if</span> (f1 &gt; f2) &#123;</span><br><span class="line">                     r = m - <span class="number">1</span>;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     l = m;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">             dp[i][j] = Math.max(dp[l - <span class="number">1</span>][j - <span class="number">1</span>], dp[i - l][j]) + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> dp[N][K];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 📺 <a href="https://www.bilibili.com/video/BV1KE41137PK">李永乐老师B站视频</a><br>[2] 📄 <a href="https://leetcode-cn.com/problems/super-egg-drop/solution/dong-tai-gui-hua-zhi-jie-shi-guan-fang-ti-jie-fang/">李维维哥哥力扣题解</a><br>[3] 💤 <a href="https://zhuanlan.zhihu.com/p/92288604">labuladong知乎专栏</a></p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>秋招</title>
    <url>/posts/18127/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>至此，10月末，我的秋招告一段落。</p>
<p><img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/Khighness/cdn/common/wait.jpg" alt="wait"><br /></p>
<p>感谢以下公司对我的认可：</p>
<table>
<thead>
<tr>
<th align="center">company</th>
<th align="center">position</th>
<th align="center">base</th>
</tr>
</thead>
<tbody><tr>
<td align="center">shopee</td>
<td align="center">Golang后端</td>
<td align="center">深圳</td>
</tr>
<tr>
<td align="center">58同城</td>
<td align="center">安居客后端</td>
<td align="center">上海</td>
</tr>
<tr>
<td align="center">北森云计算</td>
<td align="center">中间件开发</td>
<td align="center">北京</td>
</tr>
</tbody></table>
<p>但是，之前网签的北森，想毁约签虾皮了。</p>
<p>可是，我不知道只能签一个啊，要等到12月才能毁约，搞心态。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>RAFT-NOTE</title>
    <url>/posts/13171/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="RAFT概述"><a href="#RAFT概述" class="headerlink" title="RAFT概述"></a>RAFT概述</h2><p>相比于Paxos，Raft主要使用两种方法来提高可理解性。</p>
<h3 id="问题分解"><a href="#问题分解" class="headerlink" title="问题分解"></a>问题分解</h3><p>尽可能将问题分解为若干个可解决的、更容易理解的小问题——这是众所周知的简化问题的方法论。</p>
<p>Raft算法把问题分解成了领导人选举（leader election）、日志复制（log replication）、安全性（safety）和成员关系变化（membership changes）这几个子问题。</p>
<ul>
<li><strong>领导人选举</strong>：在一个领导人结点发生故障之后必须重新给出一个新的领导人节点。</li>
<li><strong>日志复制</strong>：领导人结点从客户端接收操作请求，然后将操作日志复制到集群中的其他服务器上，并且强制要求其他服务器的日志必须和自己的保持一致。</li>
<li><strong>安全性</strong>：Raft关键的安全特性是状态机安全原则（Safety Machine Safety）——如果一个服务器已经将给定索引位置的日志条目应用到状态机上，则所有其他服务器不会再该索引位置应用不同的条目。</li>
<li><strong>成员关系变化</strong>：配置发生变化的时候，集群能够继续工作。</li>
</ul>
<h3 id="状态简化"><a href="#状态简化" class="headerlink" title="状态简化"></a>状态简化</h3><p>Raft算法通过减少需要考虑的状态数量来简化状态空间。这将使得整个系统更加一致并且能够尽可能地消除不确定性。需要特别说明的是，日志条目之间不允许出现空洞，并且还要限制日志出现不一致的可能性。尽管在大多数情况下，Raft都在试图消除不确定性以减少状态空间。但在一种场景下（选举），Raft会用随机方法来简化选举过程中的状态空间。</p>
<p>Raft算法与现有的一些Paxos变种（主要是Oki和Liskov的Viewstamped Replication）存在一些相似的地方，但是Raft还有几点重要的创新：</p>
<ul>
<li><strong>强领导人</strong>：Raft使用一种比其他算法更强的领导形式。例如，日志条目只从领导人发向其他服务器。这样就简化了对日志复制的管理，提高了Raft的可理解性。</li>
<li><strong>领导人选举</strong>：Raft使用随机定时器来选举领导人。这种方式仅仅是在所有算法都需要实现的心跳机制上增加了一点变化，就使得冲突解决更加简单和快速。</li>
<li><strong>成员变化</strong>：Raft在调整集群成员关系时使用了一种新的一致性（joint consensus，联合一致性）方法。使用这种方法，使得集群配置在发生变化时，集群依旧能够正常工作。</li>
</ul>
<h2 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h2><h3 id="节点角色"><a href="#节点角色" class="headerlink" title="节点角色"></a>节点角色</h3><p>一般情况下，分布式系统中存在如下两种节点关系模型：</p>
<ul>
<li>对称：所有的节点都是平等的，不存在主节点。客户端可以与任意节点进行交互。</li>
<li>非对称：基于选主模型，只有主节点拥有决策权。任意时刻有且只有一个主节点，客户端只与主节点进行交互。</li>
</ul>
<p>基于简化操作和效率等因素考虑，Raft算法采用的是非对称节点关系模型。</p>
<p>在一个由Raft协议组织的集群中，一共包含了如下3类角色：</p>
<ul>
<li>Leader（领导人）</li>
<li>Candidate（候选人）</li>
<li>Follower（群众）</li>
</ul>
<h3 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h3><p>Raft算法将时间划分为任意不同长度的任期（Term），任期是单调递增的，用连续的数组（1，2，3······）表示。在Raft的世界里，每一个任期的开始都是一次领导人的选举。</p>
<p>如果一个领导人赢得了选举，那么它就会在该任期的剩余时间内担任领导人。在某些情况下，选票会被瓜分，导致没有哪位候选人能够得到超过半数的选票，这样本次任期将以没有领导人而结束。那么忙，系统就会自动进入下一个任期，开始一次新的选举。Raft算法保证在给定的一个任期内最多只有一个领导人。某些Term会由于选举失败，存在没有领导人的情况。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图1. Raft算法任期示意图</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/time-synchronization.png" class="" title="time-synchronization">

<br />

<p>任期在Raft中起着逻辑时钟的作用，同时也可用于在Raft节点中检测过期信息——比如过期的领导人。</p>
<p>每个Raft节点都在本地维护一个当前任期值，触发这个数字变化（增加）主要有两个场景：</p>
<ul>
<li>开始选举</li>
<li>与其他节点交换信息</li>
</ul>
<p>当节点之间开始通信时，会互相交换当前的任期号：</p>
<ul>
<li><p>如果一个节点（包括领导人）的当前任期号比其他节点的任期号小，则将自己本地的任期号自觉地更新为较大的任期号。</p>
</li>
<li><p>如果一个候选人或者领导人意识到它的任期号过时了（比别人的小），那么它会立刻切换回群众状态。</p>
</li>
<li><p>如果一个节点收到的请求所携带的任期号是过时的，那么该节点就会拒绝响应本次请求。</p>
</li>
</ul>
<p>需要注意的是，由于分布式系统节点之间无法做到在任意时刻完全同步，因此不同的Raft节点可能会在不同的时刻感知到任期的切换。甚至在出现网络分区或节点异常的情况下，某个节点可能会感知不到一次选举或者一个完整的任期。</p>
<h3 id="领导人选举"><a href="#领导人选举" class="headerlink" title="领导人选举"></a>领导人选举</h3><p>Raft通过选举一个权利至高无上的领导人，并采取赋予他管理复制日志重任的方式来维护节点间复制日志的一致性。领导人从客户端接收日志条目，再把日志条目复制到其他服务器上，并且在保证安全性的前提下，告诉其他服务器将日志条目应用到它们的状态机中。强领导人的存在大大简化了复制日志的管理。</p>
<p>例如，领导人可以决定新的日志条目需要放在日志文件的什么位置，而不需要和其他服务器商议，并且数据都是单向地从领导人流向其他服务器。当然，在这种方式下，领导人自身的日志正确性显得尤为重要，下文会证明日志的正确性。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图2. Raft集群三类角色切换示意图</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/role-switch.png" class="" title="role-switch">

<br />

<p>在Raft的选举中，有两个概念非常重要：心跳和选举定时器。每个Raft结点都有一个选举定时器，所有的Raft节点最开始以Follower角色运行时，都会启动这个选举定时器。不过，每个结点的选举定时器市场均不相等。</p>
<p>Leader在任期内必须顶起向集群内的其他节点广播心跳包，昭告自己的存在。Follower每次收到心跳包后就会主动将自己的选举定时器清零重置（reset）。因此如果Follower选举定时器超时，则意味着在Raft规定的一个选举超时时间周期内，Leader的心跳包并没有发给Follower（或者已经发送了但在网络传输过程中发生了延迟或被丢弃了），于是Follower就假定Leader已经不存在或者发生了故障，于是会发生一次新的选举。</p>
<p>对此，我们都可以形象地理解为每个Raft的Follower都有一颗不安分的“野心”，只是碍于Leader的心跳广播“号令”不敢“造反”。而Follower从最后一次接收到Leader的心跳包算起，最长的“蛰伏”时间就是Raft协议为每个节点规定的选举超时时间，超过这个时间，大家就都“蠢蠢欲动”了。</p>
<p>因此，要求Leader广播心跳的周期必须要短于选举定时器的超时时间，否则会频繁地发生选举，切换Leader。</p>
<p>如果一个Follower决定开始参加选举，那么它会执行如下步骤：</p>
<ol>
<li>将自己本地维护的当前任期号（current_term_id）加1。</li>
<li>将自己的状态切换到候选人（Candidate），并为自己投票。也就是说每个候选人的第一张选票来自于他自己。</li>
<li>向其所在集群中的其他节点发送 RequestVote RPC，要求它们投票给自己。</li>
</ol>
<p>一个候选人有三种状态迁移的可能性：</p>
<ol>
<li>得到大多数节点的选票（包括自己），成为Leader。</li>
<li>发现其他节点赢得了选举，主动切换回Follower。</li>
<li>过了一段时间后，发现没有人赢得选举，重新发起一次选举。</li>
</ol>
<p>第一种场景【先到先得】：一个候选人如果在一个任期内收到了集群中大多数Follower的投票，就算赢得了选举。在一个任期内，一个Raft结点最多只能为一个候选人投票，按照先到先得的原则，投给最早来拉选票的候选人。选举安全性原则使得在一个任期内最多有一个候选人能够赢得选举。一旦某个候选人赢得了选举，它就会向其他节点发送心跳信息来建立自己的领导地位。</p>
<p>第二种场景【自动放弃】：当一个候选人在等待其他人的选票时，它有可能会收到来自其他节点的，声称自己是领导人的心跳包。此时，这个候选人会将信将疑地检查包含这位领导人RPC中的任期号：如果大于或等于自己本地维护的当前任期，则承认该领导人合法，并且主动将自己的状态切换回Follower；反之，候选人则认为该领导人不合法，拒绝此次RPC，并且返回当前较新的那个任期号，以便让领导人意识到自己的任期号已经过时，该节点继续保持候选人状态不变。</p>
<p>第三种场景【选票瓜分】：一个候选人既没有赢得选举也没有输掉选举。如果多个Follower在同一时刻都成了候选人，那么选票可能会被多个候选人平分，这就使得没有哪个候选人能够获得超过半数的选票。当这种情形发生时，显然不能一直这样“僵持下去”，于是Raft的每一个候选人又都设置了超时时间内（类似于选举超时时间，区别是选举超时时间是针对Follower的），发生超时后，每个候选人自增任期号（Term++）并且发起新一轮的拉选票活动。然后，如果没有其他手段来分配选票的话，选票均分的情况可能会无限循环下去。为了避免发生这种问题，Raft采用了一种非常简单的方法——随机重试。例如，设置一个区间（150~300ms），超时时间将从这个区间内随机选择。错开发起竞选的时间窗口，可以使得在大多数情况下只有一个节点会率先超时，该节点会在其他节点超时之前赢得选举，并且向其他节点发送心跳信息。要知道，在每个选票打平时都会采用这种随机的方式，因此连续发生选票被均匀的概率非常小。</p>
<blockquote>
<p>据Raft算法的作者回忆，最开始时他们计划使用一种排名系统：为每一个候选人分配一个独一无二的排名，用于在候选人竞争时候根据排名的高低选择领导人。如果发现一个候选人的排名比另一个候选人的排名高，排名较低的就会切换回Follower的状态，这样排名搞的候选人就会轻而易举地赢得选举。</p>
<p>但是他们马上就发现这种方法在可用性方面存在一些问题——低排名的节点在高排名的节点发生故障后，需要等待超时才能再次成为候选人，但是如果进行得太快，就有可能中断领导人选举的过程。</p>
<p>在对算法进行了多次调整之后，最终他们认为随机重试的方法更加明确。</p>
</blockquote>
<p>候选人“拉票”过程使用Raft算法预定义的RPC——RequestVote RPC就能描述。RequestVote RPC的发起/调用方是Candidate，接收方是集群内所有的其他节点（包括Leader、Follower和Candidate）。</p>
<p>RequestVote RPC有4个参数，2个返回值。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>表1. RequestVote RPC参数列表</font>
</center>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">term</td>
<td align="left">候选人</td>
</tr>
<tr>
<td align="left">candidateId</td>
<td align="left">请求投票的候选人id</td>
</tr>
<tr>
<td align="left">lastLogIndex</td>
<td align="left">候选人最新日志条目的索引值（槽位）</td>
</tr>
<tr>
<td align="left">lastLogTerm</td>
<td align="left">候选人最新日志条目对应的任期号</td>
</tr>
</tbody></table>
<center>
    <font face="Old English Text MT" color="#555555" size=3>表2. RequestVote RPC返回值列表</font>
</center>

<table>
<thead>
<tr>
<th align="left">返回值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">term</td>
<td align="left">当前任期号，用于候选人更新自己本地的term值</td>
</tr>
<tr>
<td align="left">voteGranted</td>
<td align="left">如果候选人得到了这张选票，则为true，否则为false</td>
</tr>
</tbody></table>
<p>RPC接收方需要实现的逻辑具体如下：</p>
<ol>
<li>如果term &lt; currentTerm，即RPC的第一个参数term的值小于接收方本地维护的term（currentTerm）值，则返回 (currentTerm, false)，以提醒调用方其term过时了，并且明确地告诉这位候选人这张选票不会投给他；否则执行步骤2。</li>
<li>如果之前没把选票投给任何人（包括自己）或者已经把选票投给当前候选人了，并且候选人的日志和自己的日志一样新，则返回 (term, true)，表示在这个任期，选票都投给这位候选人。如果之前已经把选票投给其他人，那么很遗憾，这张选票还是不能投给他，这时就会返回 (term, false)。</li>
</ol>
<h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p>一旦某个领导人赢得了选举，那么它就会开始接收客户端的请求。每一个客户端请求都将被解析成一条需要复制状态机执行的指令。领导人把这条指令作为一条心的日志加入它的日志文件中，然后并行地向其他Raft节点发起AppendEntries RPC，要求其他节点复制这个日志条目。当这个日志条目被“安全”地复制之后，Leader会将这条日志应用到它的状态机中，并且向客户端返回执行结果。如果Follower发生错误，运行缓慢没有及时响应AppendEntries RPC，或者发生了网络丢包的问题，那么领导人会无限地重试AppendEntries RPC（甚至在它响应了客户端之后），直到所有的Follower最终存储了和Leader一样的日志条目。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图3. RAFT协议追加日志示意图</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/log-composition.png" class="" title="log-composition">

<br />

<p>如图3所示，日志由有序编号的日志条目组成。每一个日志条目一般均包含三个属性：整数索引（log index）、任期号（term）和指令（command）。每个条目所包含的整数索引即该条目在日志文件中的槽位。term是指其被领导人创建时所在的任期号，对应到图中就是每个方块的数字，用于检测在不同的服务器上日志不一致性问题。指令即用于被状态机执行的外部命令。如果某个日志条目能够被状态机安全执行，就认为是可以被提交（commited）了。</p>
<p>领导人决定什么时候将日志条目应用到状态机是安全的，即可被提交的。Raft算法保证可被提交的日志条目是持久化的，并且最终是会所有状态机执行的。一旦领导人创建的条目已经被复制到半数以上的节点上了，那么这个条目就称为可被提交的。例如，图中的7号提阿偶在其中3个结点上均有复制，所以7号条目是可被提交的；但条目8只在其中2个节点上有复制，因此8号条目是不可被提交的。</p>
<p>领导人日志中只有commitIndex之前的日志项目可以被提交，这种提交方式是安全的。领导人跟踪记录他所知道的被提交日志条目的最大索引值，并且这个索引值会包含在他向其他节点发送的AppendEntries RPC中，目的就是让其他节点知道该索引值对应的日志条目已经被提交。由于领导人广播的心跳包就是一个内容为空的AppendEntries RPC，因此其他节点也能通过领导人的心跳包获悉某个日志条目的提交情况。一旦Follower得知某个日志条目已经被提交，那么它会将该日志应用到本地的状态机（按照日志顺序）。</p>
<p>Raft算法设计了以下日志机制来保证不同节点上日志的一致性：</p>
<ol>
<li>如果在不同的日志中两个条目有着相同的索引和任期号，则它们所存储的命令是相同的。</li>
<li>如果在不同的日志中两个条目有着相同的索引和任期号，则它们之前的所有条目都是完全一样的。</li>
</ol>
<p>第一条特性的满足条件在于，领导人在一个任期里在给定的一个日志索引位置最多创建一条日志条目，同时该条目在日志文件中的槽位永远也不会改变。</p>
<p>第二条特性的满足条件在于，AppendEntries RPC有一个简单的一致性检查。领导人在发送一个AppendEntries RPC消息试图向其他节点追加新的日志条目时，会把这些新日志条目之前一个槽位的日志条目的任期号和索引位置包含在消息体中。如果Follower在它的日志文件中没有找到相同的任期号和索引的日志，它就会拒绝该AppendEntries RPC，即拒绝在自己的状态机中追加新日志条目。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图4. 新Leader产生时一个集群可能的一个状态图</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/cluster-status.png" class="" title="cluster-status">

<br />

<p>当一个新的Leader被选举出来时，它的日志与其他的Follower可能是不一样的。这是就需要一个机制来保证日志是一致的。产生一个新Leader时，集群状态可能如上。</p>
<p>如图4所示的例子中，一个格子代表一个日志条目，格子中的数字是它对应的任期号。假设最上面的那个是领导人，a~f所代表的场景分别如下：</p>
<ul>
<li>a和b表示Follower丢失一些日志条目的场景。</li>
<li>c和d表示Follower可能多出来一些未提交的条目的场景。</li>
<li>e和f表示上述两种情况都有的场景。</li>
</ul>
<p>丢失的或者多出来的条目可能会持续多个任期。举个例子，场景f会在如下情况下发生：如果一台服务器在任期2时是领导人，并且其向他自己的日志文件中追加了一些日志条目，然后在将这些日志条目提交之前系统出现了故障。但是他很快又重启了，选举成功继续成功任期3的领导人，而且又向他自己的日志文件中追加了一些日志条目。但是不幸的是，在任期2和任期3中创建的日志条目在被提交之前又出现了故障，并且在后面几个任期内也一直处于故障状态。</p>
<p>一般情况下，Leader和Follower的日志都是保持一致的，因此AppendEntries RPC的一致性检查通常不会失败。然后，如果领导人节点在故障之前没有向其他节点完全复制日志文件中的所有复制条目，则会导致日志不一致的问题。在Raft算法中，Leader通过强制Follower复制它的日志类处理日志不一致的问题。这就意味着，Follower上与Leader的冲突日志会被领导者的日志强制覆写。</p>
<p>为了让Follower的日志同自己的保持一致，Leader需要找到第一个Follower与它的日志条目不一致的位置，然后让Follower连续删除该位置之后（包括该位置）所有的日志条目，并且将自己在该位置（包括该位置）之后的日志条目发送给Follower。</p>
<p>那么，Leader是如何精准地找到每个Follower与其日志条目不一致的那么槽位的呢？这些操作都会在AppendEntries RPC进行一致性检查时完成。Leader为每一个Follower维护了一个nextIndex，它表示领导人将要发送给该群众的下一条日志条目的索引。当一个Leader赢得选举时，它会假设每个Follower上的日志都与自己的保持一致，于是先将nextIndex初始化为它最新的日志条目索引树+1。在图4所示的例子中，由于Leader最新的日志条目index为10，所以nextIndex的初始值是11。</p>
<p>当Leader向Follower发送AppendEntries RPC时，它携带了 (term_id, nextIndex - 1) 二元组信息，term_id即nextIndex - 1这个槽位的日志条目的term。Follower接收到AppendEntries RPC消息后，会进行一致性检查，即搜索自己的日志文件中是否存在这样的日志条目，如果不存在，就向Leader返回AppendEntries RPC失败。如果返回失败信息，就意味着Follower发现自己的日志与领导人的不一致。在失败之后，领导人会将nextIndex递减（nextIndex–），然后重试AppendEntries RPC，直到AppendEntries RPC返回成功为止。这才表明在nextIndex位置的日志条目中领导人与群众的保持一致。这时，Follower上nextIndex位置之前的日志条目将全部保留，在此之后（与Leader有冲突）的日志条目将被Follower全部删除，并且从该位置起追加Leader上在nextIndex位置之后的所有日志条目。因此，一旦AppendEntries RPC返回成功，Leader和Follower的日志就可以保持一致了。</p>
<p>以上即Raft日志的一致性检查的全过程，下面将以图4的Leader和b节点，举例说明日志一致性检查Leader和Follower之间的交互过程：</p>
<ol>
<li>Leader的nextIndex的初始值为11，Leader向b发送AppendEntries RPC(6, 10)。b检查自己的日志文件的10号位置没有找到term为6的日志记录，于是b向leader返回了一个拒绝消息。</li>
<li>Leader将nextIndex减1，变成10，继续向b发送AppendEntries RPC(6, 9)。b检查自己的日志文件的9号位置没有找到term为6的日志记录，于是b再次向Leader返回了一个拒绝消息。</li>
<li>Leader将nextIndex减1，变成9，继续向b发送AppendEntries RPC(6, 8)。b检查自己的日志文件的8号位置没有找到term为6的日志记录，于是b再次向Leader返回了一个拒绝消息。</li>
<li>Leader将nextIndex减1，变成8，继续向b发送AppendEntries RPC(5, 7)。b检查自己的日志文件的7号位置没有找到term为5的日志记录，于是b再次向Leader返回了一个拒绝消息。</li>
<li>Leader将nextIndex减1，变成6，继续向b发送AppendEntries RPC(5, 6)。b检查自己的日志文件的6号位置没有找到term为5的日志记录，于是b再次向Leader返回了一个拒绝消息。</li>
<li>Leader将nextIndex减1，变成5，继续向b发送AppendEntries RPC(4, 5)。b检查自己的日志文件的5号位置没有找到term为4的日志记录，于是b再次向Leader返回了一个拒绝消息。</li>
<li>Leader将nextIndex减1，变成4，继续向b发送AppendEntries RPC(4, 4)。b检查自己的日志文件的4号位置，找到了term为4的日志记录，于是接受了Leader的AppendEntries RPC请求，并架构自己的日志文件中从5号位置开始的日志记录全部删除。随后，Leader就从5号位置开始把余下的所有日志条目一次性推给b（5~10）。</li>
</ol>
<p>如果需要的话，在 Raft算法的实现上还可以优化AppendEntries RPC失败的次数。例如，当Follower拒绝了一个AppendEntries RPC时，Follower可以在自己本地的日志文件中找到该冲突日志项对应的任期号内所有日志条目索引（index）值最小的那个，然后反馈给Leader。于是，领导人就可以跳跃式递减nextIndex，跨过那个任期内所有的冲突条目。通过这种方式，一个冲突的任期只需要一次AppendEntries RPC检查，而无须为每个冲突条目都做一次AppendEntries RPC检查。</p>
<p>Raft算法的日志复制机制，使得Leader和Follower只需要调用和响应AppendEntries RPC即可让集群内节点的各复制状态机的日志逐渐地趋于一致，而无须再采取额外的措施。一个领导人从来不会删除自己的日志（包括前任领导人创建的日志），也不会被别人覆盖日志。</p>
<p>Raft算法的日志复制机制表明：只要集群中的大部分节点是正常的，那么Raft算法就能接收客户端复制日志的请求，并将其复制到各节点上且应用（Apply）带各节点复制状态机上。通常情况下，一次AppendEntries RPC就能完成一条心的日志条目在集群内的大多数节点上的复制。而且Raft只要求日志条目在大多数节点上完成复制就算提交成功，因此速度较慢的Follower并不会影响整体的日志复制性能。</p>
<p>一次正常的Raft日志的复制流程：</p>
<ol>
<li>客户端向Leader发送写请求。</li>
<li>Leader将写请求解析成操作指令追加到哦本地日志文件中。</li>
<li>Leader为每个Follower广播哦AppendEntries RPC。</li>
<li>Follower通过一致性检查，选择从哪个位置开始追加Leader的日志条目。</li>
<li>一旦日志项提交成功，Leader就将该日志条目对应的指令应用到本地状态机，并向客户端返回操作结果。</li>
<li>Leader后续通过AppendEntries RPC将已经成功（在大多数节点上）提交的日志项告知Follower。</li>
<li>Follower收到提交的日志项之后，将其应用到本地状态机。</li>
</ol>
<p>从上面流程可以看出，针对Raft日志条目有两个操作，提交（commit）和应用（apply），应用必须发生在提交之后，即某个日志条目被提交之后才能被应用到本地状态机上。</p>
<p>AppendEntries RPC的调用方式Leader，接收方是Follower。AppendEntries RPC除了用于复制文件之外，还可以广播Leader的心跳包。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>表3. AppendEntries RPC参数列表</font>
</center>

<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>领导人的任期号</td>
</tr>
<tr>
<td>leaderId</td>
<td>领导人的ID，为了其他Raft节点能够重定向客户端请求</td>
</tr>
<tr>
<td>prevLogIndex</td>
<td>本次AppendEntries RPC新增日志的前一个位置日志的索引值</td>
</tr>
<tr>
<td>prevLogTerm</td>
<td>本次AppendEntries RPC新增日志的前一个位置日志的任期号</td>
</tr>
<tr>
<td>entries[]</td>
<td>将要追加到Follower上的日志条目。发生心跳包时为空，有时会为了效率高而向多个节点并发发送</td>
</tr>
<tr>
<td>leaderCommit</td>
<td>领导人会为每个Follower都维护一个leaderCommit，表示领导人认为Follower已经提交的日志条目索引值。</td>
</tr>
</tbody></table>
<center>
    <font face="Old English Text MT" color="#555555" size=3>表4. AppendEntries RPC返回值列表</font>
</center>

<table>
<thead>
<tr>
<th>返回值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前的任期号，即AppendEntries RPC参数中term（领导人的）与Follower本地维护的当前任期号的较大值。用于领导人更新自己的任期号。一旦领导人发现当前任期号比自己的要大，就表明自己是一个“过时”的领导人，便停止发送AppendEntries RPC，主动切换回Follower。</td>
</tr>
<tr>
<td>success</td>
<td>如果其他服务器包含能够匹配prevLogIndex和prevLogTerm的日志，则为真</td>
</tr>
</tbody></table>
<p>RPC 接收者需要实现如下操作步骤：</p>
<ol>
<li>如果term &lt; currentTerm，即领导人的任期号小于Follower本地维护的当前任期号，则返回 (currentTerm, false)，否则继续步骤2。</li>
<li>如果Follower在prevLogIndex位置的日志的任期号与prevLogTerm不匹配，则返回 (term, false)，否则继续步骤3。</li>
<li>Follower进行日志一致性检查。</li>
<li>添加任何在已有的日志中不存在的条目，删除多余的条目。</li>
<li>如果leaderCommit &gt; commiIndex，则将commitIndex （Follower自己维护的本地已提交的日志条目索引值）更新为min{leaderCommit, Follower本地最新日志条目索引}。即信任Leader的数据，乐观地将本地已提交日志的索引值跃进领导人为该Follower跟踪记录的那个值（除非leaderCommit比本地最新的日志条目索引值还要大）。这种场景通常发生在Follower刚从故障中恢复过来的场景。</li>
</ol>
<h3 id="安全性Q-amp-A"><a href="#安全性Q-amp-A" class="headerlink" title="安全性Q&amp;A"></a>安全性Q&amp;A</h3><p>前面讨论了Raft算法的是如何进行领导人选举和日志复制的。然后，到目前为止这个机制还不能保证每一个状态机都能按照相同的顺序执行同样的指令。例如，当领导人正在复制日志条目时一个Follower发生了故障，且故障发生之前没有复制领导人的日志，之后该Follower重启并且当选为领导人，那么它在产生了一些新的日志条目后，会用自己的日志覆盖掉其他节点的日志，这就导致不同的状态机可能执行不同的指令序列。</p>
<p>下面将介绍如何在领导人选举部分加入一个限制规则来保证——任何的领导人都拥有之前任期的全部日志条目。有了这一限制，就不会上述例子所描述的情形了。</p>
<p>Q: 怎样才能具有称为领导人的资格？</p>
<p>A: 在所有以领导人选举为基础的一致性算法中，领导人最终必须要存储全部已经提交的日志条目。在一些一致性算法中，例如，Viewstamped Replication中，即时一开始没有包含全部已提交的条目也可以当选为领导人。这些算法都包含一些另外的机制来保证找到丢失的条目并将它们传输给新的领导人，这个过程要么在选举过程中完成，要么在选举之后立即开始。毫无疑问的是，这种方式显著增加了算法的复杂性。</p>
<p>Raft算法使用的是一种更简单的方式来保证新当选的领导人，之前任期已提交的所有日志条目都已经出现在了上面，而不需要将这些条目传送给新领导人。这种方式隐含了以下两点内容：</p>
<ul>
<li>没有包含所有已提交日志条目的节点成为不了领导人。</li>
<li>日志条目只有一个流向：从Leader流向Follower。领导人永远不会覆盖已经存在的日志条目。</li>
</ul>
<p>Raft算法使用投票的方式来阻止那些没有包含所有已提交日志条目的节点赢得选举。一个候选人为了赢得选举必须要与集群中的大多数节点进行通信，这就意味着每一条已经提交的日志条目都会出现在至少其中一个与之通信的节点上。如果候选人的日志比集群内的大多数节点上的日志更加新（或至少一样新），那么它一定包含所有已经提交的日志条目。因此，RequestVote RPC的接收方有一个检查：如果他自己的日志比RPC调用方（候选人）的日志更加新，就会拒绝候选人的投票请求。</p>
<p>那么，如何比较两份日志哪个更加新呢？比较的依据是日志文件中最后一个条目的索引和任期号：如果两个日志条目的任期号不同，则任期号大的更加新；如果任期号相同，则索引值更大（即日志文件条目更多）的日志更加新。</p>
<p>Q: 如何判断日志已经提交？</p>
<p>A: 领导人当前任期的某条日志条目只要存储在大多数节点上，就认为该日志记录已经被提交（commited）了。如果领导人在提交某个日志条目之前崩溃了，那么未来后继的领导人会让其他节点继续复制这个日志条目。</p>
<p>然后，一个领导人不能因为由之前领导人创建（即之前任期）的某条日志存储在大多数节点上了，就笃定该日志条目已经被提交了。图4中的时序a~d就展示了这种情况，一条已经被存储到大多数节点上的日志条目，也依然有可能被未来的领导人覆盖掉。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图5. Raft算法某一时刻日志状态图</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/log-status.png" class="" title="log-status">

<br />

<p>时刻a，S1是任期2的领导人并且向部分节点（S1和S2）复制了2号位置的日志条目，然后宕机。</p>
<p>时刻b，S5获得了S3、S4（S5的日志与S3和S4的一样新，最新的日志的任期号都是1）和自己的选票赢得了选举，成了3号任期的领导人，并且在2号位置上写入了一条任期号为3日志条目。在新日志复制到其他节点之前，S5宕机了。</p>
<p>时刻c，S1重启，并且通过S2、S3、S4和自己的选票赢得了选举，成了4号任期的领导人，并且继续向S3复制2号位置的日志。此时，任期2的日志条目已经在大多数节点上完成了复制。</p>
<p>时刻d，S1发生故障，S5通过S2、S3、S4的选票再次成为领导人（因为S5最后一条日志的任期号是3，比S2、S3、说中任意一个节点上的日志都更加新），任期号为5。然后S5用自己的本地日志覆写了其他节点上的日志。</p>
<p>这个例子说明，即时日志条目被半数以上的节点写盘（复制）了，也并不代表它已经被提交（commited）到Raft集群了——因为一旦某条日志被提交，那么它将永远没法被删除或修改。这个例子同时也说明了，领导人无法单纯地依靠之前任期的日志条目信息判断它的提交状态。</p>
<p>因此，针对以上场景，Raft算法对日志提交条件增加了一个额外的限制，要求Leader在当前任期至少有一条日志被提交，即被超过半数的节点写盘。</p>
<p>正如图5时刻e描述的那样，S1作为Leader，在崩溃之前，将3号位置的日志（任期号为4）在大多数节点上复制了一条日志条目（条目3，任期4），那么即使这时S1宕机了，S5也不可能赢得选举——因为S2和S3的最新日志条目的任期号为4，比S5的要大，S5无法获得超过半数的选票，S5无法赢得选举，这就意味着2号位置的日志条目不会被覆写。</p>
<p>将上面的描述进行归纳，可以总结为以下几点：</p>
<ul>
<li>只要一个日志条目被存在了大多数的服务器上，领导人就知道当前任期可以提交该条目了。</li>
<li>如果领导人在提交日志之前就崩溃了，之后的领导人会试着继续完成对日志的复制。但是，新领导人无法断定存储在大多数服务器上的日志条目一定在之前的任期中被提交了（即时日志保存在大多数的服务器上，也有可能没来得及提交）。</li>
</ul>
<div class="note icon simple"><i class="note-icon fab fa-korvue"></i><p><strong>关于状态机安全性的三段论证明</strong></p>
<p>定义：A为上个任期最后一条已提交日志，B为当前任期的Leader</p>
<ol>
<li><strong>因为</strong> A必然同步到了集群中的半数以上节点</li>
<li><strong>又因为</strong> B只有获得集群中半数以上节点的选票才能成为Leader</li>
<li><strong>所以</strong> B的选民中必然存在拥有A日志的节点</li>
<li><strong>又因为</strong> 选举限制，B成为Leader的前提是比给它投票的所有选民都要新</li>
<li><strong>所以</strong> B的日志中必然要包含A</li>
<li><strong>又因为</strong> 日志完全匹配规则，如果A被B包含，那么比A小的所以日志都被B包含</li>
<li><strong>因为</strong> lastApplied &lt;= commitIndex</li>
<li><strong>又因为</strong> Raft保证已提交日志在所有集群节点上的顺序一致</li>
<li><strong>所以</strong> 应用日志必然在所有节点上顺序一致</li>
<li><strong>因为</strong> 状态机只能按序执行应用日志部分</li>
<li><strong>得证</strong> 状态机在整个集群所有节点上必然最终一致</li>
</ol>
</div>



<h2 id="可用性与时序"><a href="#可用性与时序" class="headerlink" title="可用性与时序"></a>可用性与时序</h2><p>我们对分布式一致性算法的要求之一就是不依赖于时序（timing）——系统不能仅仅因为某些事件发生得比预想的快一些或慢一些就产生错误。然而，可用性（系统及响应客户端的请求）不可避免地要依赖时序。从上面的描述中可以看出，没有一个稳定的领导人，Raft算法将无法工作（至少没法接受客户端的写请求）。因此，如果消息交换发生在服务器崩溃时，则需要花费更多的时间，而候选人不会等待太长的时间来赢得选举。</p>
<p>领导人选取是Raft算法中对时序要求最多的地方。只有当系统环境满足以下时序要求时，Raft算法才能选举并且保持一个稳定的领导人存在：</p>
<center>
    <font face="Kristen ITC" color="#555555" size=3>broadcastTime << electionTimeout < MTBF</font><br>
</center>

<p>在以上不等式中，各个时间含义如下：</p>
<ul>
<li>broadcastTime： 一个节点向集群中其他节点发送RPC，并且收到它们响应的平均时间。</li>
<li>electionTimeout：选举超时时间。</li>
<li>MTBF：单个节点发生故障的平均时间间隔。</li>
</ul>
<p>为了使领导人能够持续发送心跳包来阻止下面的Follower发起选举，broadcastTime应该比electionTimeout小一个数量级。根据已经给出的随机化选举超时时间方法，这个不等式也显著降低了选票瓜分的概率。为了使得系统稳定运行，election也应该比MTBF小几个数量级。当领导人出现故障且在新的领导人选举出来之前，系统对外将不可用，这个时长大约为electionTimeout。</p>
<p>broadcastTime和MTBF与系统环境息息相关，但是我们可以根据实际情况配置electionTimeout的值。一次Raft算法的RPC的完成需要接收方将信息持久化到存储中去。所以广播时间是网络传输时延与存储写入时延的总和，一般在几毫秒到几十毫秒之间。因此，通常将electionTimeout设置在10ms到500ms之间。大多数的服务器的MTBF都在几个月甚至更长的时间里，因此很容易满足这个时序要求。</p>
<h2 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h2><p>一个Raft系统的异常情况通常可以分为两大类：Leader异常和Followe/Candidate异常。</p>
<p>Follower/Candidate异常问题的解决方法要比Leader异常简单得多。如果一个Follower或者Candidate崩溃了，那么领导人在这之后发送给他们的RequestVote RPC和AppendEntries RPC就会失败。Raft算法通过Leader无限的重试要应对这些失败，直到故障的节点重启并处理了这些RPC为止。如果一个节点在收到RPC之后但在响应之前崩溃了，那么它会在重启之后再次收到同一个RPC。因为Raft算法中的RPC都是幂等的，因此不会有什么问题。例如，如果一个Follower收到了已经包含在其日志中的AppendEntries RPC，那么它会忽略本次请求。</p>
<p>由于Raft算法是强领导人特性的，因此保证领导人即时出现故障也不影响数据一致性就显得格外重要。</p>
<p>数据提交的全过程，如图6所示。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图6. Raft算法数据交换示意图</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/data-exchange.svg" class="" title="data-exchange"><br />

<p>图6中，数据的流向只能从Leader节点向Follower节点转移。当Client向集群Leader节点提交数据时，Leader节点接收到的数据处于未提交状态（Uncommitted），接着Leader节点会并发向所有Follower节点复制数据并等待响应，在确保集群中至少有超过半数的节点已经接收到数据之后，再向Client确认数据已接收。一旦Leader节点向Client发出数据接收ACK响应之后，即表明此时数据状态进入已提交（Committed）状态，Leader节点会再次向Follower节点发送通知，告知该数据状态已提交。</p>
<p>在这个过程中，领导人可能会在任意阶段崩溃，下面将注意师范Raft算法在各个场景下是如何保障数据一致性的。</p>
<p><strong>（1）数据到达Leader前</strong></p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图7. 数据到达Leader之前</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/raft-exception1.svg" class="" title="raft-exception1"><br />

<p>这个阶段领导人出现故障不会影响数据一致性。</p>
<p><strong>（2）数据到达Leader节点，但未复制到Follower节点</strong></p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图8. 数据到达Leader节点，但未复制到Follower节点</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/raft-exception2.svg" class="" title="raft-exception2"><br />

<p>如果在这个阶段Leader出现故障，此时数据属于未提交状态，那么Client不会收到ACK，而是会认为超时失败可安全发起重试。Follower节点上没有该数据，重新选主后Client重试重新提交可成功。原来的Leader节点回复之后将作为Follower加入集群，重新从当前任期的心Leader处同步数据，与Leader数据强制保持一致。</p>
<p><strong>（3）数据到达Leader节点，成功复制到Follower的部分节点上，但还未向Leader响应接收</strong></p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图9. 数据到达Leader节点，成功复制到Follower的部分节点上，但还未向Leader响应接收</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/raft-exception3.svg" class="" title="raft-exception3"><br />

<p>如果在这个阶段Leader出现故障，此时数据在Follower节点处于未提交状态（Uncommitted）且不一致，那么Raft协议要求投票只能投给拥有最新数据的节点。所以拥有最新数据的节点会被选为Leader，再将数据强制同步到Follower，数据不会丢失并且能够保证最终一致性。</p>
<p><strong>（4）数据到达Leader节点，成功复制到Follower的所有节点上，但还未向Leader响应接收</strong></p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图10. 数据到达Leader节点，成功复制到Follower的所有节点上，但还未向Leader响应接收</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/raft-exception4.svg" class="" title="raft-exception4"><br />

<p>如果在这个阶段Leader出现故障，虽然此时数据在Follower节点处于未提交状态（Uncommitted），但也能保持一致，那么重新选出Leader后即可完成数据提交，由于此时客户端不知道到底有没有提交成功，因此可重试提交。针对这种情况，Raft要求RPC请求实现幂等性，也就是要实现内部去重机制。</p>
<p><strong>（5）数据到达Leader节点，成功复制到Follower的所有或大多数节点上，数据在Leader上处于已提交状态，但在Follower上处于未提交状态</strong></p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图11. 数据到达Leader节点，成功复制到Follower的所有或大多数节点上，数据在Leader上处于已提交状态，但在Follower上处于未提交状态</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/raft-exception5.svg" class="" title="raft-exception5"><br />

<p>如果在这个阶段Leader出现故障，那么重新选出新Leader后的处理流程与（3）一样。</p>
<p><strong>（6）数据到达Leader节点，成功复制到Follower的所有或大多数节点上，数据在所有节点都处于已提交状态，但还未响应Client</strong></p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图12. 数据到达Leader节点，成功复制到Follower的所有或大多数节点上，数据在所有节点都处于已提交状态，但还未响应Client</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/raft-exception6.svg" class="" title="raft-exception6"><br />

<p>如果在这个阶段Leader出现故障，此时集群内部数据其实是一致的，那么Client重复重试基于幂等策略对一致性无影响。</p>
<p><strong>（7）网络分区导致的集群脑裂情况，出现双Leader</strong></p>
<p>网络分区将原先的Leader节点和Follower节点分隔开，Follower收不到Leader的心跳将发起选举产生新的Leader。这是就产生了双Leader，原先的Leader独自在一个区，向它提交数据不可能复制到大多数节点上，所以永远都是提交不成功。向新的Leader提交数据可以提交成功，网络恢复后旧的Leader发现集群中有更新任期（Term）的新Leader，则自动降级为Follower并从新Leader处同步数据达成集群数据一致。具体情形如图13所示。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>图13. 网络分区导致的集群脑裂情况，出现双Leader</font>
</center>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/raft-exception7.svg" class="" title="raft-exception7"><br />



<p>以上七种场景穷举了一个三节点的最小集群面临的所有异常情况，可以看出Raft算法在各种异常场景下均能保证数据的一致性。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="日志压缩与快照"><a href="#日志压缩与快照" class="headerlink" title="日志压缩与快照"></a>日志压缩与快照</h3><p>在实际的系统中，Raft结点上的日志记录不可能无限制地增加下去。</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/13171/compress-snapshot.png" class="" title="compress-snapshot"><br />



<p>定时的将状态机中的状态生成快照，而将之前的日志全部删除，是一种常见的压缩方式。</p>
<ol>
<li>将节点的状态保存为LSM Tree，然后存储最后应用日志的索引与任期，以保证日志匹配特性</li>
<li>持集群的配置更新，快照中也要将最后应用的集群配置也当做状态保存下来</li>
<li>跟随者需要的日志已经在领导者上面被删除时，需要将快照通过RPC发送过</li>
</ol>
<p>注意：由领导人调用以将快照的分块发送给跟随者。领导者总是按顺序发送分块。</p>
<center>
    <font face="Old English Text MT" color="#555555" size=3>表5. InstallSnapshot RPC返回值列表</font>
</center>


<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>领导人的任期号</td>
</tr>
<tr>
<td>leaderId</td>
<td>领导人的Id，以便于跟随者重定向请求</td>
</tr>
<tr>
<td>lastIncluedIndex</td>
<td>快照中包含的最后日志条目的索引值</td>
</tr>
<tr>
<td>lastIncludedTerm</td>
<td>快照中包含的最后日志条目的任期号</td>
</tr>
<tr>
<td>offset</td>
<td>分块在快照中的字节偏移量</td>
</tr>
<tr>
<td>data[]</td>
<td>从偏移量开始的快照分块的原始字节</td>
</tr>
<tr>
<td>done</td>
<td>如果这是最后一个</td>
</tr>
</tbody></table>
<center>
    <font face="Old English Text MT" color="#555555" size=3>表6. InstallSnapshot RPC返回值列表</font>
</center>

<table>
<thead>
<tr>
<th>结果</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>term</td>
<td>当前任期号（currentTerm），便于领导人更新自己的任期号</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果term &lt; currentTerm就立即拒绝</span><br><span class="line">如果是第一个分块（offset &#x3D; 0）就创建一个新的快照</span><br><span class="line">在指定偏移量写入数据</span><br><span class="line">如果 done 是 false，则继续等待更多的数据 ack</span><br><span class="line">保存快照文件，丢弃具有较小索引的任何现有或部分快照</span><br><span class="line">如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留</span><br><span class="line">否则，丢弃整个日志</span><br><span class="line">使用快照重置状态机，并架子啊快照的集群配置</span><br></pre></td></tr></table></figure>

<p>Q: 快照何时创建？过于频繁会浪费性能，过于低频则日志占用磁盘的量更大，重建时间更长。</p>
<p>A: 限定日志文件大小到达某一个阈值后立刻生成快照。</p>
<p>Q: 写入快照花费的时间昂贵如何处理？如何保证不影响节点的正常工作？</p>
<p>A: 使用写时复制技术，状态机的函数式顺序性天然支持。</p>
<h3 id="调节参数"><a href="#调节参数" class="headerlink" title="调节参数"></a>调节参数</h3><ol>
<li>心跳的随机时间，过快会增加网络负载，过慢则导致感知领导者崩溃的时间更长</li>
<li>选举的随机时间，如果大部分跟随者同时变为候选人则会导致选票被瓜分</li>
</ol>
<h3 id="流批结合"><a href="#流批结合" class="headerlink" title="流批结合"></a>流批结合</h3><p>首先可以做的就是batch，在很多情况下面，使用batch能明显提高性能，譬如对于RocksDB的写入来说，我们通过不会每次写入一个值，而是会用一个WriteBatch缓存一批修改，然后再整个写入。对于Raft来说，Leader可以一次手机多个requests，然后一批发送给Follower。当然，我们也需要有一个最大发送size来限制每次最多可以发送多少数据。</p>
<p>如果只是用batch，Leader还是需要等待Follower返回才能继续后面的流程，我们这里还可以使用Pipeline来进行加速。Leader会维护一个NextIndex的变量来表示下一个给Follower发送的log位置，通常情况下，只要Leader跟Follower建立起了连接，我们都会认为网络是稳定互通的。所以当Leader给Follower发送了一批log之后，它可以直接更新NextIndex，并且立刻发送后面的log，不需要等待Follower的返回。如果网络出现了错误，或者Follower返回一些错误，Leader就需要重新调整NextIndex，然后重新发送log。</p>
<h3 id="并行追加"><a href="#并行追加" class="headerlink" title="并行追加"></a>并行追加</h3><p>对于上面提到的一次request简易Raft流程来说，Leader可以先并行的将log发送给Followers，然后再将log append。为什么可以这么做，主要是因为在Raft里面，如果一个log被大多数的结点append，我们就可以认为这个log是被committed了，所以即使Leader再给Follower发送log之后，自己append log失败panic了，只要<code>N / 2 + 1</code>个Follower能接收到这个log并成功append，我们仍可以认为这个log是被committed了，被committed了，被committed的log后续就一定能被成功apply。</p>
<p>原因：主要是因为append log会涉及到落盘，有开销，所以我们完全可以在Leader落盘的同时让Follower也尽快的收到log是被committed了，这样系统就有丢失数据的风险了。</p>
<p>这里我们还需要注意，虽然 Leader 能在 append log 之前给 Follower 发 log，但是 Follower 却不能在 append log 之前告诉 Leader 已经成功 append 这个 log。如果 Follower 提前告诉 Leader 说已经成功 append，但实际后面 append log 的时候失败了，Leader 仍然会认为这个 log 是被 committed 了，这样系统就有丢失数据的风险了。</p>
<h3 id="异步应用"><a href="#异步应用" class="headerlink" title="异步应用"></a>异步应用</h3><p>当一个log被大部分节点append之后，我们就可以认为这个log被committed了，被committed的log在什么时候apply都不会再影响数据的一致性。所以当一个log被committed之后，我么可以用另一个线程去异步的apply这个log。<br>所以整个Raft流程就可以变成：</p>
<ol>
<li>Leader接受一个client发送的request。</li>
<li>Leader将对应的log发送给其他Follower并本地append。</li>
<li>Leader继续接受其他client的requests，持续进行步骤2。</li>
<li>Leader发现log已经被committed，在另一个线程apply。</li>
<li>Leader异步apply log之后，返回结果给对应的client。</li>
</ol>
<p>使用 asychronous apply的好处在于我们现在可以安全的并行处理append log和apply log，虽然对于一个client来说，它的一次request仍然要走完完整的Raft流程，但对于多个clients来说，整体的并发和吞吐量是上去了。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 📓 <a href="https://book.douban.com/subject/30386518/">云原生分布式存储基石</a></p>
<p>[2] 📑 <a href="https://github.com/maemual/raft-zh_cn">RAFT论文中文翻译</a></p>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>Distributed</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-事务原理</title>
    <url>/posts/15536/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="事务使用"><a href="#事务使用" class="headerlink" title="事务使用"></a>事务使用</h2><p>引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>包结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line">└─parak</span><br><span class="line">    ├─entity</span><br><span class="line">    │   └─User</span><br><span class="line">    ├─mapper</span><br><span class="line">    │   └─UserMapper</span><br><span class="line">    ├─service</span><br><span class="line">    │   │   └─UserService</span><br><span class="line">    │   └─impl</span><br><span class="line">    │       └─UserServiceImpl</span><br><span class="line">    └─KHighnessApplication</span><br></pre></td></tr></table></figure>
<p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户名&#x27;</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">&#x27;用户年龄&#x27;</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">4</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=KAG1823</span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=GMT%2b8</span><br><span class="line">logging.level.top.parak.mapper=debug</span><br></pre></td></tr></table></figure>
<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建持久接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into user(username,age) values(#&#123;username&#125;,#&#123;age&#125;)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建业务接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建业务实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="keyword">if</span> (!user.getUsername().contains(<span class="string">&quot;K&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名不含有K&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(KHighnessApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplicationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user1 = <span class="keyword">new</span> User();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> User user2 = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user1.setUsername(<span class="string">&quot;KHighness&quot;</span>);</span><br><span class="line">        user2.setUsername(<span class="string">&quot;Flower&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userService.saveUser(user1);</span><br><span class="line">        userService.saveUser(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image1.png" class="" title="image1"><br />
<p>说明user1插入，user2回滚。</p>
<h2 id="事务原理"><a href="#事务原理" class="headerlink" title="事务原理"></a>事务原理</h2><h3 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h3><p>直接查看模块驱动注解<code>@EnableTransactionManagement</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(TransactionManagementConfigurationSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTransactionManagement &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个注解通过<code>@Import</code>向容器中导入了一个<code>TransactionManagementConfigurationSelector</code>组件，查看其源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image2.png" class="" title="image2"><br />


<h3 id="AutoRegistrar"><a href="#AutoRegistrar" class="headerlink" title="AutoRegistrar"></a>AutoRegistrar</h3><p>查看<code>AutoProxyRegistrar</code>的源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image3.png" class="" title="image3"><br />
<p>查看<code>AopConfigUtils.registerAutoProxyCreatorIfNecessary(registry)</code>源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image4.png" class="" title="image4"><br />
<p>查看<code>InfrastructureAdvisorAutoProxyCreator</code>的层级关系图：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image5.png" class="" title="image5"><br />
<p>这个和AOP中的<code>AnnotationAwareAspectJAutoProxyCreator</code>的层级关系图一致，所以我们可以推断出<code>InfrastructureAdvisorAutoProxyCreator</code>的作用为：为目标Service创建代理对象，增强目标Service方法，用于事务控制。</p>
<h3 id="ProxyTransactionManagementConfiguration"><a href="#ProxyTransactionManagementConfiguration" class="headerlink" title="ProxyTransactionManagementConfiguration"></a>ProxyTransactionManagementConfiguration</h3><img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image6.png" class="" title="image6"><br />
<ol>
<li>注册<code>BeanFactoryTransactionAttributeSourceAdvisor</code>增强器，该增强器需要如下两个Bean<ul>
<li>TransactionAttributeSource</li>
<li>TransactionInterceptor</li>
</ul>
</li>
<li>注册TransactionAttributeSource</li>
</ol>
<p>查看<code>AnnotationTransactionAttributeSource</code>源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image7.png" class="" title="image7"><br />
<p>查看<code>SpringTransactionAnnotationParser</code>源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image8.png" class="" title="image8"><br />

<ol start="3">
<li>注册<code>TransactionInterceptor</code>事务拦截器</li>
</ol>
<p>查看<code>TransactionInterceptor</code>源码，其实现了<code>MethodInterceptor</code>方法拦截器接口，目标方法执行的时候，对应拦截器的<code>invoke</code>方法会被执行，所以重点关注<code>TransactionInterceptor</code>实现的<code>invoke</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image9.png" class="" title="image9"><br />
<p>查看<code>invokeWithinTransaction</code>方法源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image10.png" class="" title="image10"><br />
<p>查看<code>completeTransactionAfterThrowing</code>方法源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image11.png" class="" title="image11"><br />
<p>这里，如果没有在<code>@Transaction</code>注解上指定回滚的异常类型的话，默认只对<code>RuntimeException</code>和<code>Error</code>类型的异常进行回滚：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image12.png" class="" title="image12"><br />
<p>再看<code>commitTransactionAfterReturning</code>方法源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image13.png" class="" title="image13"><br />


<h3 id="DEBUG验证"><a href="#DEBUG验证" class="headerlink" title="DEBUG验证"></a>DEBUG验证</h3><p>在测试代码上打上断点：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image14.png" class="" title="image14"><br />
<p>以DEBUG方式运行test2：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image15.png" class="" title="image15"><br />
<p>可以看到目标对象已经被JDK代理（因为UserServiceImpl实现了接口，所以采用JDK动态代理）。<br>在断点处执行Step Into，程序跳转到<code>JdkDynamicAopProxy</code>的<code>invoke</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image16.png" class="" title="image16"><br />
<p>在<code>invocation.proceed()</code>处继续Step Into，查看内部调用过程：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image17.png" class="" title="image17"><br />
<p>点击Step Into，程序跳转到<code>TransactionInterceptor</code>的<code>invoke</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image18.png" class="" title="image18"><br />
<p>继续Step Into，程序跳转到<code>TransactionAspectSupport</code>的<code>invokeWithinTransaction</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image19.png" class="" title="image19"><br />


<h2 id="不生效场景"><a href="#不生效场景" class="headerlink" title="不生效场景"></a>不生效场景</h2><h3 id="场景一"><a href="#场景一" class="headerlink" title="场景一"></a>场景一</h3><p>Service方法抛出的异常不是RuntimeException或者Error类型，并且<code>@Transactional</code>注解上没有指定回滚异常类型。<br>​</p>
<p><strong>原因</strong><br>默认情况下，Spring事务只对RuntimeException或者Error类型异常进行回滚，检查异常（通常为业务类异常）不会导致事务回滚。<br>​</p>
<p><strong>解决</strong></p>
<ol>
<li>手动在<code>@Transactional</code>注解上声明回滚的异常类型<code>rollbackFor</code>（方法抛出该异常及其所有子类型异常都能出发事务回滚）：</li>
<li>将方法内抛出的异常继承RuntimeException。</li>
</ol>
<h3 id="场景二"><a href="#场景二" class="headerlink" title="场景二"></a>场景二</h3><p>非事务方法直接通过<code>this</code>调用本类事务方法。<br>比如，修改UserServiceImpl如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="keyword">if</span> (!user.getUsername().contains(<span class="string">&quot;K&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名不含有K&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser2</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    userService.saveUser2(user2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/image20.png" class="" title="image20"><br />
<p>发现插入成功，说明事务不生效。</p>
<p><strong>原因</strong><br>这让我想起面试字节时一个AOP的面试题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@log</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123; A(); &#125;</span><br></pre></td></tr></table></figure>
<p>问直接通过<code>this.B()</code>调用<code>A()</code>方法能否打印日志。答案当然是不能的。<br>AOP的实现是通过目标类的JDK动态代理类或者CGlib动态代理类来实现的，直接调用方法调用的是目标类的方法而不是代理类的增强后方法，因此不能打印出日志。<br>Spring事务控制使用AOP代理实现，通过对目标对象的代理来增强目标方法，直接通过<code>this</code>调用本类的方法的时候，<code>this</code>的指向并非代理类，而是目标类本身。<br>​</p>
<p><strong>解决</strong><br>从IOC容器中获取<code>UserService</code>，然后调用<code>saveUser</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserMapper userMapper;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper = userMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.save(user);</span><br><span class="line">        <span class="keyword">if</span> (!user.getUsername().contains(<span class="string">&quot;K&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;用户名不含有K&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser2</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        UserService userService = applicationContext.getBean(UserService.class);</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最终总结"><a href="#最终总结" class="headerlink" title="最终总结"></a>最终总结</h2><img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/15536/last.png" class="" title="last"><br />

<p>模块驱动注解<code>@EnableTransactionManagement</code>通过<code>@Import</code>导入了一个<code>@TransactionManagementConfigurationSelector组件</code>，它通过<code>selectImports</code>方法批量注册两个类：</p>
<ol>
<li>注册器：<code>AutoProxyRegistrar</code></li>
<li>配置类：<code>ProxyTransactionManagementConfiguration</code></li>
</ol>
<p>（1）AutoProxyRegistrar</p>
<p>通过<code>AopConfigUtils</code>向容器中注册<code>InfrastructureAdvisorAutoProxyCreator</code>，作用是为目标Service创建代理对象，增强Service方法，用于事务控制。</p>
<p>（2）ProxyTransactionManagementConfiguration</p>
<p>主要向容器中注册两个bean：</p>
<p>① <code>BeanFactoryTransactionAttributeSourceAdvisor</code></p>
<p>② <code>TransactionInterceptor</code></p>
<p>①创建<code>SpringTransactionAnnotationParser</code>，解析<code>@Transaction</code>注解上的各个属性值，包装为Transaction对象</p>
<p>② 实现了<code>MethodInterceptor</code>方法拦截器，在<code>invoke</code>方法中先处理和Kotlin相关内容，再执行<code>invokeWithTransaction</code>方法。</p>
<p>这个方法是事务核心，先获取目标方法的<code>@Transaction</code>注解的属性，再获取事务管理器<code>JdbcTransactionManager</code>，在一个try-catch块中通过反射执行目标方法<code>proceedWithInvocation</code></p>
<ul>
<li>出现异常则执行<code>completeTransactionThrowing</code>方法：需要判断方法抛出的异常是否在指定的范围内，是则通过事务管理器回滚事务，否则提交事务。</li>
<li>成功则执行<code>commitTransactionAfterReturning</code>方法：通过事务管理器提交事务。</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-aop原理</title>
    <url>/posts/54880/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>AOP(Aspect Oritented Programming)：面向切面编程，通过预编译和运行期动态代理实现程序功能的唯一维护的一种技术。AOP是OOP的延续，也是对OOP的补充。它是Spring框架中的一个重要内容，是函数式变成的一种衍生泛型。利用AOP可以对业务逻辑的各个部分进行隔离，对MVC的垂直架构进行横向切入，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。<br>​</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是GOF23种设计模式之一，为其他对象提供了一个代理以提供对某个对象的访问。</p>
<p>主要包括:</p>
<ol>
<li>抽象接口</li>
<li>具体实现类</li>
<li>代理类</li>
</ol>
<p>静态代理是代理模式的实现方式之一，是在程序运行前，由程序员创建或者特定工具自动生成源代码并对其编程生成<code>.class</code>文件。</p>
<p><strong>对于静态代理而言，具体实现类与代理类是一一对应的，这也是广义上的代理模式特点。但是，如果抽象接口有K个实现类，那么也必然需要手动创建K个代理类，这便是静态代理的痛点。</strong></p>
<p>相较于在编译期实现的静态代理，动态代理则在程序运行期实现。动态代理可以很方便地对委托类的相关方法进行统一增强处理。</p>
<p>下面以演唱会为场景进行演示静态代理和动态代理。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理的实现步骤如下：</p>
<ol>
<li>定义业务接口；</li>
<li>创建业务接口实现类；</li>
<li>定义代理类并实现业务接口。</li>
</ol>
<p>首先定义一个演唱会接口，定义演唱会的两个功能，开始和结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Concert</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(String song)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end</span><span class="params">(String song)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建具体的演唱会实现类，在该类中真正实现演唱会的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealConcert</span> <span class="keyword">implements</span> <span class="title">Concert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> String singerName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealConcert</span><span class="params">(String singerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.singerName = singerName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String song)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;演唱会即将开始&quot;</span>, singerName);</span><br><span class="line">        log.info(<span class="string">&quot;第一首：《&#123;&#125;&#125;》&quot;</span>, song);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(String song)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;最后一首：《&#123;&#125;》&quot;</span>, song);</span><br><span class="line">        log.info(<span class="string">&quot;&#123;&#125;演唱会即将结束&quot;</span>, singerName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为演唱会是需要场地举办，场地上要进行其他的广告插入和安全措施，通过代理创建最终的演唱会：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyRealConcert</span> <span class="keyword">implements</span> <span class="title">Concert</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> Concert concert;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyRealConcert</span><span class="params">(Concert concert, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.concert = concert;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String song)</span> </span>&#123;</span><br><span class="line">        startNotice();</span><br><span class="line">        concert.start(song);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">(String song)</span> </span>&#123;</span><br><span class="line">        concert.end(song);</span><br><span class="line">        endNotice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;欢迎来到&#123;&#125;看演唱会，荧光棒、粉丝牌9.8折，欢迎购买！&quot;</span>, address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;演唱会已经结束，请带走私人物品和垃圾，家长注意看好小孩&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后编写测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务实现类</span></span><br><span class="line">        Concert originConcert = <span class="keyword">new</span> RealConcert(<span class="string">&quot;周杰伦&quot;</span>);</span><br><span class="line">        <span class="comment">// 目标代理类</span></span><br><span class="line">        Concert proxyConcert = <span class="keyword">new</span> ProxyRealConcert(originConcert, <span class="string">&quot;鸟巢&quot;</span>);</span><br><span class="line">        proxyConcert.start(<span class="string">&quot;花海&quot;</span>);</span><br><span class="line">        proxyConcert.end(<span class="string">&quot;安静&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行，控制台输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span>:<span class="number">33</span>:<span class="number">55.064</span> [<span class="type">main</span>] INFO top.parak.quiet.SuperRealConcert - 欢迎来到鸟巢看演唱会，荧光棒、粉丝牌<span class="number">9.8</span>折，欢迎购买！</span><br><span class="line"><span class="number">15</span>:<span class="number">33</span>:<span class="number">55.067</span> [<span class="type">main</span>] INFO top.parak.quiet.RealConcert - 周杰伦演唱会即将开始</span><br><span class="line"><span class="number">15</span>:<span class="number">33</span>:<span class="number">55.067</span> [<span class="type">main</span>] INFO top.parak.quiet.RealConcert - 第一首：《花海》</span><br><span class="line"><span class="number">15</span>:<span class="number">33</span>:<span class="number">55.067</span> [<span class="type">main</span>] INFO top.parak.quiet.RealConcert - 最后一首：《安静》</span><br><span class="line"><span class="number">15</span>:<span class="number">33</span>:<span class="number">55.067</span> [<span class="type">main</span>] INFO top.parak.quiet.RealConcert - 周杰伦演唱会即将结束</span><br><span class="line"><span class="number">15</span>:<span class="number">33</span>:<span class="number">55.067</span> [<span class="type">main</span>] INFO top.parak.quiet.SuperRealConcert - 演唱会已经结束，请带走私人物品和垃圾，家长注意看好小孩</span><br></pre></td></tr></table></figure>
<p>可以看到，代理模式可以在不修改代理对象的基础上，通过扩展代理类，进行一些功能的附加与增强。值得注意的是，代理类和被代理类应该共同实现一个接口，或者是共同继承某个抽象类。</p>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>JDK动态代理需要使用到<code>java.lang.reflect</code>包下的三个类：<code>InvocationHanler</code>、<code>Method</code>和<code>Proxy</code>。</p>
<p><code>InvocationHanler</code>的<code>invoke</code>方法增强原实现类的功能，该方法有三个参数：</p>
<ol>
<li><code>Object proxy</code>：JDK创建的代理对象；</li>
<li><code>Method method</code>：目标类中的方法；</li>
<li><code>Object[] args</code>：目标类中的参数。</li>
</ol>
<p><code>Proxy</code>的<code>newProxyInstance</code>方法用于生成代理类，该方法有三个参数：</p>
<ul>
<li><code>ClassLoader loader</code>：目标类的类加载器，一般通过反射<code>class.getClassLoader()</code>获取；</li>
<li><code>Class[] interfaces</code>：目标类实现的接口，一般通过反射<code>class.getInterfaces()</code>获取；</li>
<li><code>InvocationHandler h</code>： 需要具体实现类实现这个接口，需要<code>new</code>出来当作参数。</li>
</ul>
<p>动态代理的接口和被代理类与静态代理相同，只需要修改具体实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyRealConcert</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line">    <span class="keyword">private</span> Object concert;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyRealConcert</span><span class="params">(Object concert, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.concert = concert;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;start&quot;</span>)) &#123;</span><br><span class="line">            startNotice();</span><br><span class="line">            method.invoke(concert, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;end&quot;</span>)) &#123;</span><br><span class="line">            method.invoke(concert, args);</span><br><span class="line">            endNotice();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;欢迎来到&#123;&#125;看演唱会，荧光棒、粉丝牌9.8折，欢迎购买！&quot;</span>, address);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">endNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;演唱会已经结束，请带走私人物品和垃圾，家长注意看好小孩&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 业务实现类</span></span><br><span class="line">        Concert originConcert = <span class="keyword">new</span> RealConcert(<span class="string">&quot;周杰伦&quot;</span>);</span><br><span class="line">        InvocationHandler invocationHandler = <span class="keyword">new</span> ProxyRealConcert(originConcert, <span class="string">&quot; 鸟巢&quot;</span>);</span><br><span class="line">        <span class="comment">// 目标代理类</span></span><br><span class="line">        Concert proxyConcert = (Concert) Proxy.newProxyInstance(RealConcert.class.getClassLoader(), RealConcert.class.getInterfaces(), invocationHandler);</span><br><span class="line">        proxyConcert.start(<span class="string">&quot;花海&quot;</span>);</span><br><span class="line">        proxyConcert.end(<span class="string">&quot;安静&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行启动类，实现效果与静态代理相同。<br>​</p>
<h2 id="AOP的术语"><a href="#AOP的术语" class="headerlink" title="AOP的术语"></a>AOP的术语</h2><p>在AOP中，切面的工作被称为通知。<br>通知定义了切面是什么以及何时使用，定义如下：</p>
<ol>
<li>连接点（JpinPoint）：在应用执行过程中能够插入切面的一个点。这个点是调用方法时，抛出异常时，甚至是修改一个字段时。切面代码可以利用这些点插入到应用的正常流程之中，并添加新的行为。</li>
<li>切点（Pointcut）：切点的定义会匹配通知所要织入的一个或多个连接点。我们通常使用明确的类和方法名称来指定这些切点，或是利用正则表达式定义要匹配的类和方法名称来指定这些切点。</li>
<li>切面（Aspect）：切面是通知和切点的结合。通知和切点共同定义了关于切面的全部内容——它是什么，在何时和何处完成其功能。</li>
<li>引入（Introdution）：引入允许我们向现有的类添加新的方法和属性。</li>
<li>织入（Weaving）：织入是将切面应用到目标对象来创建新的代理对象的过程。切面在指定的连接点被织入到目标对象中。在目标对象的生命周期里有多个点可以进行织入：<ul>
<li>编译期：切面在目标类编译期时被织入</li>
<li>类加载期：切面在目标类加载到JVM时被织入</li>
<li>运行期：切面在应用运行的某个时候被织入（Spring使用）</li>
</ul>
</li>
</ol>
<p>Spring切面可以应用五种类型的通知：</p>
<ol>
<li>Before：在方法被调用之前调用通知</li>
<li>After：在方法完成之后调用通知，无论方法是否执行成功</li>
<li>After-returning：在方法成功执行之后调用通知</li>
<li>After-throwing：在方法抛出异常之后调用通知</li>
<li>Around：通知包括了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li>
</ol>
<h2 id="AOP的使用"><a href="#AOP的使用" class="headerlink" title="AOP的使用"></a>AOP的使用</h2><p>新建项目，引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">spring.boot.version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">spring.boot.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.boot.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建一个目标类，里面包含需要被AOP代理增强的方法<code>test</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetClass</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">&quot;: test()被执行&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasLength(value)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;value不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;new&quot;</span> + value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编写切面类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(public * top.parak.TargetClass.test(..))&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onBefore: &quot;</span> + joinPoint.getSignature().getName() +</span><br><span class="line">                <span class="string">&quot;()开始执行，参数：&quot;</span> + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointcut()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;onAfter: &quot;</span> + joinPoint.getSignature().getName() +</span><br><span class="line">                <span class="string">&quot;()执行结束，参数：&quot;</span> + Arrays.asList(joinPoint.getArgs()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pointcut()&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning: &quot;</span> + joinPoint.getSignature().getName() +</span><br><span class="line">                <span class="string">&quot;()执行返回，参数：&quot;</span> + Arrays.asList(joinPoint.getArgs()) + <span class="string">&quot;，返回值：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointcut()&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing: &quot;</span> + joinPoint.getSignature().getName() +</span><br><span class="line">                <span class="string">&quot;()执行出错，参数：&quot;</span> + Arrays.asList(joinPoint.getArgs()) + <span class="string">&quot;，异常：&quot;</span> + exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该切面包含了4个通知方法：</p>
<ol>
<li>前置通知（@Before）：在目标方法调用之前调用通知</li>
<li>后置通知（@After）：在目标方法完成之后调用通知</li>
<li>返回通知（@AfterReturning）：在目标方法成功执行之后通知</li>
<li>异常通知（@AfterThrowing）：在目标方法抛出异常之后通知</li>
</ol>
<p>通知是顺序在不同的Spring版本中会有所不同：</p>
<ul>
<li>Spring4.x<ol>
<li>正常情况：@Before —&gt; 目标方法 —&gt; @After —&gt; @AfterReturning</li>
<li>异常情况：@Before —&gt; 目标方法 —&gt; @After —&gt; @AfterThrowing</li>
</ol>
</li>
<li>Spring5.x<ol>
<li>正常情况：@Before —&gt; 目标方法 —&gt; @AfterReturning —&gt; @After</li>
<li>异常情况：@Before —&gt; 目标方法 —&gt; @AfterThrowing —&gt; @After</li>
</ol>
</li>
</ul>
<p>编写SpringBoot启动类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AOPApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = SpringApplication.run(AOPApplication.class, args);</span><br><span class="line">        TargetClass targetClass = applicationContext.getBean(TargetClass.class);</span><br><span class="line">        targetClass.test(<span class="string">&quot;aop&quot;</span>);</span><br><span class="line">        targetClass.test(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数：&quot;aop&quot;</span></span><br><span class="line">onBefore: test()开始执行，参数：[<span class="type">aop</span>]</span><br><span class="line">TargetClass: test()被执行</span><br><span class="line">afterReturning: test()执行返回，参数：[<span class="type">aop</span>]，返回值：newaop</span><br><span class="line">onAfter: test()执行结束，参数：[<span class="type">aop</span>]</span><br><span class="line"><span class="comment"># 参数：&quot;&quot;</span></span><br><span class="line">onBefore: test()开始执行，参数：[]</span><br><span class="line">TargetClass: test()被执行</span><br><span class="line">afterThrowing: test()执行出错，参数：[]，异常：value不能为空</span><br><span class="line">onAfter: test()执行结束，参数：[]</span><br></pre></td></tr></table></figure>


<h2 id="EnableAspectAutoProxy"><a href="#EnableAspectAutoProxy" class="headerlink" title="@EnableAspectAutoProxy"></a>@EnableAspectAutoProxy</h2><p>在前面引入的<code>spring-boot-starter-aop</code>中，@Enable模块驱动注解<code>@EnableAspectJAutoProxy</code>用于开启AspectJ自动代理，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(AspectJAutoProxyRegistrar.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAspectJAutoProxy &#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">exposeProxy</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该注解类通过<code>@Import</code>导入了<code>AspectJAutoProxyRegistrar</code>AspectJ自动代理注册器，查看<code>AspectJAutoProxyRegistrar</code>源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image1.png" class="" title="image1"><br />
<p>这个类实现了<code>ImportBeanDefinitionRegistrar</code>接口，通过注释可以了解，这个注册器的作用是往IOC容器中注册一个<code>AnnotationAwareAspectJAutoProxyCreator</code>（注解驱动的AspectJ自动代理创建器)的Bean。<br>重点关注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);</span><br></pre></td></tr></table></figure>
<p>查看源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BeanDefinition <span class="title">registerAspectJAnnotationAutoProxyCreatorIfNecessary</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上调用下面方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image2.png" class="" title="image2"><br />
<p>可以看到，核心逻辑为通过<code>RootBeanDefinition</code>向IOC注册了名称为<code>AUTO_PROXY_CREATOR_BEAN_NAME</code>（常量，值为<code>org.springframework.aop.config.internalAutoProxyCreator</code>），类型为<code>AnnotationAwareAspectJAutoProxyCreator</code>的Bean。</p>
<blockquote>
<p>总结：@EnableAspectJAutoProxy模块驱动注解向IOC容器中注册了类型为<code>AnnotationAwareAspectJAutoProxyCreator</code>的bean。</p>
</blockquote>
<h2 id="AnnotationAwareAspectJAutoProxyCreator"><a href="#AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="AnnotationAwareAspectJAutoProxyCreator"></a>AnnotationAwareAspectJAutoProxyCreator</h2><p>通过前面的分析，我们的目光聚焦在<code>AnnotationAwareAspectJAutoProxyCreator</code>类上，为了搞清楚这个类的作用，先捋清类的层级关系：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image3.png" class="" title="image3"><br />
<p>可以看到<code>AnnotationAwareAspectJAutoProxyCreator</code>的父类<code>AbstractAutoProxyCreator</code>实现了<code>SmartInstantiationAwareBeanPostProcessor</code>和<code>BeanFactoryAware</code>接口。实现<code>BeanFactoryAware</code>用于在Bean初始化时注入<code>BeanFactory</code>，而<code>SmartInstantiationAwareBeanPostProcessor</code>接口的父类为<code>InstantiationAwareBeanPostProcessor</code>，该接口继承自<code>BeanPostProcesor</code>。<code>BeanPostProcessor</code>和<code>InstantiationAwareBeanProcessor</code>接口包含一些用于Bean实例化和初始化前后进行自定义操作的方法，所以可以大体猜测出目标的代理是在这些接口方法中实现的。<br>查看<code>AbstractAutoProxyCreator</code>的源代码，它实现了<code>BeanPostProcessor</code>和<code>InstantiationAwareBeanProcessor</code>接口，重写了<code>InstantiationAwareBeanProcessor</code>的<code>postProcessBeforeInstantiation</code>方法（自定义Bean实例化前的操作逻辑）和<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法（自定义Bean初始化后的操作逻辑）：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image4.png" class="" title="image4"><br />
<p>所以在这两个方法上打上两个断点，用于后续Debug：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image5.png" class="" title="image5"><br />


<h2 id="AOP创建代理过程"><a href="#AOP创建代理过程" class="headerlink" title="AOP创建代理过程"></a>AOP创建代理过程</h2><p>使用Debug方式启动上述AOP的Demo，因为后置处理器对所有Bean都生效，所以每个Bean创建时都会进入我们刚刚打断点的两个方法中。但我们只关心Spring AOP是如何增强我们的目标类<code>TargetClass</code>的，所以如果Bean类型不是<code>TargetClass</code>，我们直接点击Resume Program跳过，知道Bean类型是<code>TargetClass</code>：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image6.png" class="" title="image6"><br />
<p><code>postProcessBeforeInstantiation</code>方法主要包含以下几个核心步骤：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image7.png" class="" title="image7"><br />
<p>（1）通过Bean名称和Bean类型获取该Bean的唯一缓存键名，<code>getCache</code>方法源码如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image8.png" class="" title="image8"><br />
<p>在这里，cacheKey的值为targetClass。<br>（2）判断当前Bean（TargetClass）是否包含在advisedBeans集合中（AbstractAutoProxyCreator的成员变量）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** Default is global AdvisorAdapterRegistry. */</span></span><br><span class="line"><span class="keyword">private</span> AdvisorAdapterRegistry advisorAdapterRegistry = GlobalAdvisorAdapterRegistry.getInstance();</span><br></pre></td></tr></table></figure>
<p>advisedBeans用于存放Bean是否需要增强的标记，键为每个Bean的cacheKey，值为布尔类型，true表示需要增强，false表示不需要增强，此时TargetClass还未实例化，所以自然不在该集合中。<br>（3）判断当前Bean（TargetClass）是否基础类，查看<code>AnnotationAwareAspectJAutoProxyCreator</code>的<code>isInfrastructureClass</code>方法源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image9.png" class="" title="image9"><br />
<p>其中<code>isInfrastructureClass</code>调用父类方法，如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image10.png" class="" title="image10"><br />
<p><code>this.aspectAdvisorFactory.isAspect</code>方法源码如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image11.png" class="" title="image11"><br />
<p>所以这一步的逻辑为：判断该当前Bean（TargetClass）是否是<code>Advice</code>、<code>PointCut</code>、<code>Advisor</code>、<code>AopInfrastructureBean</code>的子类或者是否为切面类（被<code>@Aspect</code>注解标注）。<br>（4）判断是否需要跳过，<code>shouldSkip</code>方法源码如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image12.png" class="" title="image12"><br />
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image13.png" class="" title="image13"><br />
<p>通过Bean名称判断是否以<code>AutowireCapableBeanFactory._ORIGINAL_INSTANCE_SUFFIX_</code>（.ORIGINAL）结尾，是的话返回true代表跳过处理。<br>显然，TargetClass不符合3和4，继续走第5步。<br>（5）如果我们自定义了TargetSource，则在此处理Bean代理，以取代目标Bean的后续默认实例化方式。我们并没有自定义TargetClass，所以直接跳过。</p>
<p>经过以上五步，就TargetClass这个Bean而言，<code>postProcessBeforeInstantiation</code>方法最终返回null。Bean实例化前置处理到此完毕，点击Resume Program，继续Bean的后续生命周期处理逻辑，程序跳转到Bean初始化后置处理方法<code>postProcessAfterInitialization</code>：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image14.png" class="" title="image14"><br />
<p>重点关注<code>wrapIfNecessary</code>方法，查看<code>wrapIfNecessary</code>方法源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image15.png" class="" title="image15"><br />
<p>（1）getAdvicesAndAdvisors方法内部主要包含以下这些逻辑：</p>
<ol>
<li>获取所有的通知方法（切面里定义的各个方法）；</li>
<li>通过切点表达式判断这些通知方法是否为当前Bean所用；</li>
<li>如果有符合的通知方法，则对它们进行排序（排序规则不同版本Spring有所不同，上面已经提及）。</li>
</ol>
<p>在前面的AOP例子中，切面MyAspect里的通知方法就是为了增强TargetClass所设的（根据切点表达式），所以<code>getAdvicesAndAdvisorsForBean</code>方法返回值如下所示：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image16.png" class="" title="image16"><br />
<p>这些通知方法就是我们在MyAspect切面里定义的通知方法。<br>（2）如果该Bean的通知方法集合不为空的话，则创建该Bean的代理对象，具体查看<code>createProxy</code>方法源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image17.png" class="" title="image17"><br />
<p>继续跟踪<code>proxyFactory.getProxy(getProxyClassLoader())</code>源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image18.png" class="" title="image18"><br />
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image19.png" class="" title="image19"><br />
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image20.png" class="" title="image20"><br />
<p>Spring会判断当前使用哪种代理对象（一般来说Bean有实现接口时，使用JDK动态代理，当Bean没有实现接口时，使用Cglib动态代理。在SpirngBoot中，我们可以通过spring.aop.proxy-target-class=true配置来强制使用Cglib代理）。</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image21.png" class="" title="image21"><br />
<p>后续从IOC容器中获得的TargetClass就是被代理后的对象，执行代理对象的目标方法的时候，代理对象会执行相应的通知方法链。<br>​</p>
<h2 id="生成拦截器链"><a href="#生成拦截器链" class="headerlink" title="生成拦截器链"></a>生成拦截器链</h2><p>AOP代理对象生成后，我们接着关注代理对象的目标方法执行时，通知方式是怎么被执行的。<br>先将前面的所有断点去掉，然后在AOPApplication的如下位置打上断点：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image22.png" class="" title="image22"><br />
<p>再次以Debug方式启动程序，可以看到获取到的TargetClass就是前面Cglib代理后的Bean：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image23.png" class="" title="image23"><br />
<p>点击Step Into进入<code>test</code>方法内部调用逻辑，会发现程序跳转到了<code>CglibAopProxy</code>的<code>intercept</code>方法中，也就是说我们的目标对象的目标方法中，也就是说我们的目标对象的目标方法被<code>CglibAopProxy</code>的<code>intercept</code>方法拦截了，该拦截方法主要逻辑如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image24.png" class="" title="image24"><br />
<p>这里重点关注<code>getInterceptorsAndDynamicInterceptionAdvice</code>方法，源码如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image25.png" class="" title="image25"><br />

<blockquote>
<p>所谓的拦截器链，就是在代理对象的某个方法被执行时，从通知方法集合（创建代理对象的时候就已经通知集合保存在代理对象中了）中筛选出适用于该方法的通知，然后封装为拦截器对象集合（类型为MethodInterceptor）。</p>
</blockquote>
<p>继续查看<code>this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice</code>方法源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image26.png" class="" title="image26"><br />
<p>在<code>intercept</code>方法的<code>this.advised.getInterceptorsAndDynamicInterceptionAdvice_(_method, targetClass_)_</code>这一行打个断点，点击Resume Program，看到拦截器链的内容如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image27.png" class="" title="image27"><br />
<p>拦截器链第一个元素类型为<code>ExposeInvocationInterceptor</code>，是默认的拦截器，后面会详细介绍。<br>剩下四个类型依次为：</p>
<ul>
<li><code>MethodBeforeAdviceInterceptor</code></li>
<li><code>AspectJAfterAdvice</code></li>
<li><code>AfterReturningAdviceInterceptor</code></li>
<li><code>AspectJAfterThrowingAdvice</code></li>
</ul>
<p>它们都是<code>MethodInterceptor</code>的实现类：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image28.png" class="" title="image28"><br />


<h2 id="链式调用通知方法"><a href="#链式调用通知方法" class="headerlink" title="链式调用通知方法"></a>链式调用通知方法</h2><p>获取到了代理对象目标方法的拦截器链后，我们最后来关注这些拦截器是如何链式调用通知方法的。获取拦截器链并且拦截器链不为空时，<code>CglibAopProxy</code>的<code>intercept</code>方法创建<code>CglibMethodInvoation</code>对象，并调用它的<code>proceed</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image29.png" class="" title="image29"><br />
<p>查看<code>CglibMethodInvocation</code>源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image30.png" class="" title="image30"><br />
<p>查看父类<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法源码：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image31.png" class="" title="image31"><br />
<p>清除之前打的所有断点，在该方法上第一行打个断点，重新以Debug方式启动程序：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image32.png" class="" title="image32"><br />
<p>程序第一次进入该方法时<code>currentInterceptorIndex</code>值为-1，<code>this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)</code>取出拦截器链第一个拦截器<code>ExposeInvocationInterceptor</code>，方法最后调用该拦截器的<code>invoke</code>方法，点击Step into，进入<code>ExposeInvocationInterceptor</code>的<code>invoke</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image33.png" class="" title="image33"><br />
<p><code>mi</code>就是我们传入的<code>ReflectiveMethodInvocation</code>对象，程序执行到<code>mi.proceed</code>方法时，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image34.png" class="" title="image34"><br />
<p>可以看到，此时程序第二次执行<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，<code>currentInterceptorIndex</code>值为0，<code>this.interceptorsAndDynamicMethodMatchers.get_(_++this.currentInterceptorIndex_)_</code>取拦截器链第二个拦截器<code>MethodBeforeInterceptor</code>，方法最后调用该拦截器的<code>invoke</code>方法，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image35.png" class="" title="image35"><br />
<p>可以看到<code>MethodBeforeInterceptor</code>的<code>invoke</code>方法第一行调用通知方法<code>before</code>，此时控制台打印内容如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">onBefore: test()开始执行，参数：[<span class="type">aop</span>]</span><br></pre></td></tr></table></figure>
<p>接着又通过<code>mi.proceed</code>再次调用<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image36.png" class="" title="image36"><br />
<p>此时程序第三次执行<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，<code>currentInterceptorIndex</code>值为1，<code>this.interceptorsAndDynamicMethodMatchers.get_(_++this.currentInterceptorIndex_)_</code>取拦截器链第三个拦截器<code>AspectJAfterAdvice</code>，方法最后调用该拦截器的<code>invoke</code>方法，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image37.png" class="" title="image37"><br />
<p>可以看到<code>AspectJAfterAdvice</code>的<code>invoke</code>方法内通过<code>mi.proceed</code>再次调用<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image38.png" class="" title="image38"><br />
<p>此时程序第四次执行<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，<code>currentInterceptorIndex</code>的值为2，<code>this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)</code>取出拦截器链第四个拦截器<code>AfterReturningAdviceInterceptor</code>，方法最后调用该拦截器的<code>invoke</code>方法，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image39.png" class="" title="image39"><br />
<p>可以看到<code>AfterReturningAdviceInterceptor</code>的<code>invoke</code>方法内通过<code>mi.proceed</code>再次调用<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image40.png" class="" title="image40"><br />
<p>此时程序第五次执行<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，<code>currentInterceptorIndex</code>值为3，<code>this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex)</code>取出拦截器链第五个拦截器<code>AspectJAfterThrowingAdvice</code>，方法最后调用该拦截器的<code>invoke</code>方法，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image41.png" class="" title="image41"><br />
<p>可以看到<code>AspectJAfterThrowingAdvice</code>的<code>invoke</code>方法内通过<code>mi.proceed</code>再次调用<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，Step Into进入该方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image42.png" class="" title="image42"><br />
<p>此时程序第六次执行<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法，<code>currentInterceptorIndex</code>值为4，条件程序，所以执行<code>invokeJoinPoint</code>方法，该方法内部通过反射调用了目标方法，执行后，控制台打印内容如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">onBefore: test()开始执行，参数：[<span class="type">aop</span>]</span><br><span class="line">TargetClass: test()被执行</span><br></pre></td></tr></table></figure>
<p>随着<code>invokeJoinpoint()</code>方法执行结束返回出战，程序回到<code>AspectJAfterThrowingAdvice</code>的<code>invoke</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image43.png" class="" title="image43"><br />
<p><code>this.advice.afterReturning</code>执行<code>afterReturning</code>通知方法，控制台打印内容如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">onBefore: test()开始执行，参数：[<span class="type">aop</span>]</span><br><span class="line">TargetClass: test()被执行</span><br><span class="line">onAfter: test()执行结束，参数：[<span class="type">aop</span>]</span><br></pre></td></tr></table></figure>
<p><code>AfterReturningAdviceInterceptor</code>的<code>invoke</code>方法执行结束出栈，程序回到<code>AspectJAfterAdvice</code>的<code>invoke</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image44.png" class="" title="image44"><br />
<p><code>AspectJAfterAdvice</code>的<code>invoke</code>方法最终执行finally after逻辑，控制台打印内容如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">onBefore: test()开始执行，参数：[<span class="type">aop</span>]</span><br><span class="line">TargetClass: test()被执行</span><br><span class="line">onAfter: test()执行结束，参数：[<span class="type">aop</span>]</span><br><span class="line">afterReturning: test()执行返回，参数：[<span class="type">aop</span>]，返回值：newaop</span><br></pre></td></tr></table></figure>
<p><code>AspectJAfterAdvice</code>的<code>invoke</code>方法执行结束出栈，程序回到<code>MethodBeforeAdviceInterceptor</code>的<code>invoke</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image45.png" class="" title="image45"><br />
<p><code>MethodBeforeAdviceInterceptor</code>的<code>invoke</code>方法正常执行结束，出栈，程序回到<code>ExposeInvocationInterceptor</code>的<code>invoke</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image46.png" class="" title="image46"><br />
<p><code>ExposeInvocationInterceptor</code>的<code>invoke</code>方法执行结束出栈，程序回到<code>CglibAopProxy</code>的<code>intercept</code>方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/image47.png" class="" title="image47"><br />
<p><code>CglibAopProxy</code>的<code>intercep</code>执行完毕后，整个AOP的拦截器链调用也随之结束了。<br>​</p>
<p>下面用一张图总结拦截器链调用过程：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/54880/spring-aop.svg" class="" title="spring-aop"><br />


<h2 id="最终总结"><a href="#最终总结" class="headerlink" title="最终总结"></a>最终总结</h2><p>（1）生成代理对象</p>
<p><code>@EnableAspectJAutoProxy</code>模块驱动注解用于开启AspectJ自动代理，这个注解使用<code>@Import</code>导入一个<code>AspectJAutoProxyRegistrar</code>AspectJ自动代理注册器，这个类的作用是向IOC容器中注册<code>AnnotationAwareAspectJAutoProxyCreator</code>组件。</p>
<p><code>AnnotationAwareAspectJAutoProxyCreator</code>的父类<code>AbstractAutoProxyCreator</code>重写了<code>InstantiationAwareBeanPostProcessor</code>的<code>postProcessBeforeInstantiation</code>方法和<code>BeanPostProcessor</code>的<code>postProcessAfterInitialization</code>方法。自定义Bean的实例化前逻辑中包含五个核心步骤，主要目的是进行一些校验，如果Bean本身就是切面类，那么就不会被代理了；如果我们自定义了TargetClass，则返回代理后的Bean。自定义Bean的初始化后逻辑中，主要进行<code>wrapIfNecessary</code>方法，先通过<code>getAdvicesAndAdvisors</code>方法获取Bean的通知方法集合并且进行排序，如果集合不为空，则通过<code>createProxy</code>创建该Bean的代理对象，最终会调用<code>DefaultAopProxyFactory</code>的<code>createAopProxy</code>方法，这个方法会判断使用CGLIB还是JDK动态代理。</p>
<p>（如果代理对象没有实现接口或者实现的都是空接口，则使用CGLIB动态代理；默认使用JDK动态代理）</p>
<p>（2）生成拦截器链</p>
<p>目标方法会被<code>CglibAopProxy</code>的<code>intercept</code>方法拦截，方法里会通过<code>getInterceptorsAndDynamicInterceptionAdvice</code>方法获取目标对象的拦截器链，创建目标方法的缓存key，首先从<code>methodCache</code>缓存中获取拦截器链，第一次调用时获取到的必然为空，那么则调用<code>advisorChainFactory</code>的<code>getInterceptorsAndDynamicInterceptionAdvice</code>方法封装拦截器链，并且将拦截器链存入缓存，此后调用直接从缓存中获取，提高AOP的性能。</p>
<p>『springboot2.4.0』(之前的版本后面四个拦截器顺序反转)最终生成的拦截器链的类型顺序：</p>
<ol>
<li><p><code>ExposeInvocationInterceptor</code>(默认拦截器)</p>
</li>
<li><p><code>MethodBeforeAdviceInterceptor</code>(方法执行前拦截器)</p>
</li>
<li><p><code>AspectJAfterAdvice</code>(方法执行完成拦截器)</p>
</li>
<li><p><code>AfterReturningAdviceInterceptor</code>(方法执行成功拦截器)</p>
</li>
<li><p><code>AspectJAfterThrowingAdvice</code>(方法执行异常拦截器)</p>
</li>
</ol>
<p>（3）链式调用通知</p>
<p>如果拦截器链为空，则直接通过反射执行目标方法；不为空则创建一个<code>CglibMethodInvocation</code>对象，它是<code>ReflectiveMethodInvocation</code>的子类，内部的<code>proceed</code>方法主要逻辑调用父类方法，内部维护了一个索引<code>currentInterceptorIndex</code>，初始值为-1，一步步取出拦截器链中的拦截器，并执行<code>invoke</code>方法，<code>invoke</code>方法中会通过参数<code>this</code>继续调用<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法实现链式调用。</p>
<p>对于拦截器，<code>ExposeInterceptorInvocation</code>直接调用<code>proceed</code>，<code>MethodBeforeAdviceInterceptor</code>先执行<code>before</code>再执行<code>proceed</code>，<code>AspectJAfterAdvice</code>先调用<code>proceed</code>再执行<code>invokeAdviceMethod</code>，<code>AfterReturningAdviceInterceptor</code>先调用<code>proceed</code>再执行<code>afterReturning</code>，<code>AspectJAfterThrowingAdvice</code>先调用<code>proceed</code>再执行<code>invokeAdviceMethod</code>，先链式调用然后方法出栈，最后回到<code>CglibAopProxy</code>的<code>intercept</code>方法，执行完毕后，拦截器链调用随之结束。</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-循环依赖</title>
    <url>/posts/408/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h2><p>循环依赖其实就是循环引用，即两个或者两个以上的bean互相持有对方，最终形成闭环</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/408/image1.png" class="" title="image1"><br />

<h2 id="两大场景"><a href="#两大场景" class="headerlink" title="两大场景"></a>两大场景</h2><img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/408/image2.png" class="" title="image2"><br />


<p>第一种：构造器注入循环依赖</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AService</span><span class="params">(BService bService)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BService</span><span class="params">(AService aService)</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">The dependencies of some of the beans <span class="keyword">in</span> the application context form a cycle:</span><br><span class="line"></span><br><span class="line">┌─────┐</span><br><span class="line">|  AService defined <span class="keyword">in</span> file [<span class="type">D</span>:\<span class="type">Java</span>\<span class="type">springboot</span>\<span class="type">springboot</span>\<span class="type">target</span>\<span class="type">classes</span>\<span class="type">top</span>\<span class="type">parak</span>\<span class="type">depend</span>\<span class="type">AService.class</span>]</span><br><span class="line">↑     ↓</span><br><span class="line">|  BService defined <span class="keyword">in</span> file [<span class="type">D</span>:\<span class="type">Java</span>\<span class="type">springboot</span>\<span class="type">springboot</span>\<span class="type">target</span>\<span class="type">classes</span>\<span class="type">top</span>\<span class="type">parak</span>\<span class="type">depend</span>\<span class="type">BService.class</span>]</span><br><span class="line">└─────┘</span><br></pre></td></tr></table></figure>
<p>Spring解决循环依赖依靠的是Bean的中间态，而这个中间态是指已经实例化，但未初始化。构造器执行是在中间态之前，因此构造器的循环依赖无法解决。</p>
<p>第二种：单例的setter注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种场景经常使用，没有问题。</p>
<p>第三种：多例的setter注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BService bService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_SINGLETON)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AService aService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">The dependencies of some of the beans <span class="keyword">in</span> the application context form a cycle:</span><br><span class="line"></span><br><span class="line">   c (field private top.parak.depend.AService top.parak.depend.C.aService)</span><br><span class="line">┌─────┐</span><br><span class="line">|  AService (field private top.parak.depend.BService top.parak.depend.AService.bService)</span><br><span class="line">↑     ↓</span><br><span class="line">|  BService (field private top.parak.depend.AService top.parak.depend.BService.aService)</span><br><span class="line">└─────┘</span><br></pre></td></tr></table></figure>
<p>没有使用缓存，每次都会生成一个新对象。</p>
<blockquote>
<p>总结</p>
<ol>
<li>构造器注入和prototype类型的field注入发生循环依赖时都无法初始化</li>
<li>field注入单例的bean时，尽管有循环依赖，但是bean可以成功初始化</li>
</ol>
</blockquote>
<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>Bean在创建的时候可以给该Bean打个标志，如果递归调用回来发现正在创建中的话，即说明产生了循环依赖。</p>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p><code>DefaultSingletonBeanRegistry</code></p>
<p>内部属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 一级缓存  */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 三级缓存 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 二级缓存 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 保存所有已经注册的bean的名字 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; registeredSingletons = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** 标识指定名字的bean对象是否处于创建状态 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">			Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三级缓存：</p>
<table>
<thead>
<tr>
<th>缓存</th>
<th>级别</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>singletonObjects</td>
<td>一级</td>
<td>存放最终单例，key为bean名称，value为bean实例。这里的bean实例指的是已经完全创建好的，即已经经历实例化-&gt;属性填充-&gt;初始化-&gt;后置处理过程的bean，可以直接使用。</td>
</tr>
<tr>
<td>earlySingletonObjects</td>
<td>二级</td>
<td>存放早期对象，key为bean名称，value为bean实例。这里的bean实例指的是仅完成实例化的bean，还未进行属性填充等后续操作。用于提前曝光，供别的bean引用，解决循环依赖。</td>
</tr>
<tr>
<td>singletonFactories</td>
<td>三级</td>
<td>存放回调方法，key为bean名称，value为bean工厂。在bean实例化之后，属性填充之前，如果允许提前曝光，Spring会把该bean转换为bean工厂并加入到三级缓存。在需要引用提前曝光对象时再通过工厂对象的getObject方法获取。</td>
</tr>
</tbody></table>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>IOC容器获取bean的入口为<code>AbstractBeanFactory</code>的<code>getBean</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">extends</span> <span class="title">FactoryBeanRegistrySupport</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正实现</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="meta">@Nullable</span> Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String beanName = transformedBeanName(name);</span><br><span class="line">        Object bean;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先去获取一次，如果不为null，此处就会走缓存</span></span><br><span class="line">        Object sharedInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 不为空，则进行后续处理并返回</span></span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ...</span><br><span class="line">                RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">                ...</span><br><span class="line">                <span class="comment">// 从三级缓存中没有获取到Bean实例，并且目标Bean是单实例Bean的话</span></span><br><span class="line">                <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                    <span class="comment">// 通过getSingleton方法创建Bean实例</span></span><br><span class="line">                    sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 创建Bean实例</span></span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="comment">// 后续处理，并返回</span></span><br><span class="line">                    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过<code>getSingleton(String beanName)</code>方法从三级缓存中获取bean实例，如果不为空则进行后续处理；如果为空，则通过<code>getSingleton(String beanName, ObjectFactory&lt;?) singletonFactory</code>方法创建bean实例并进行后续处理。</p>
<p>从三级缓存中获取bean实例的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSingleton(beanName, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 从一级缓存中获取bean</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">// 一级缓存中的bean为空，且当前bean正在创建</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="comment">// 从二级缓存中获取bean</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                <span class="comment">// 二级缓存中的bean为空，且允许提前创建</span></span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                    <span class="comment">// 从三级缓存中获取对应的ObjectFactory</span></span><br><span class="line">                    ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                    <span class="comment">// ObjectFactory不为空</span></span><br><span class="line">                    <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 从单例工厂中获取bean</span></span><br><span class="line">                        singletonObject = singletonFactory.getObject();</span><br><span class="line">                        <span class="comment">// 添加到二级缓存</span></span><br><span class="line">                        <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                        <span class="comment">// 从三级缓存中删除</span></span><br><span class="line">                        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要流程：</p>
<ul>
<li>首先，尝试从一级缓存中<code>singletonObjects</code>中获取单例Bean</li>
<li>获取不到，则从二级缓存<code>earlySingletonObjects</code>中获取单例Bean</li>
<li>获取不到，则从三级缓存<code>singletonFactories</code>中获取单例<code>ObjectFactory</code></li>
<li>如果从三级缓存中获取成功，则将<code>ObjectFactory</code>中的<code>object</code>取出放入到二级缓存中，并将<code>ObjectFactory</code>从三级缓存中移除</li>
</ul>
<p>如果通过三级缓存的查找都没有找到目标bean实例，则通过<code>getSingleton(String beanName, ObjectFactory&lt;?&gt; singleton)</code>方法创建：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 添加互斥锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 从一级缓存获取</span></span><br><span class="line">        Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 为空则继续</span></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 将当前bean名称添加到正在创建bean的集合singletonsCurrentlyInCreation</span></span><br><span class="line">            beforeSingletonCreation(beanName);</span><br><span class="line">            <span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过函数式接口创建bean实例，该实例已经经历实例化、属性填充、初始化和后置处理，可直接使用</span></span><br><span class="line">                singletonObject = singletonFactory.getObject();</span><br><span class="line">                newSingleton = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                <span class="comment">// 判断在此期间是否隐式出现了单例对象</span></span><br><span class="line">                ...</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 将当前bean名称从正在创建的集合singletonsCurrentlyInCreation中移除</span></span><br><span class="line">                afterSingletonCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">                <span class="comment">// 添加到缓存中</span></span><br><span class="line">                addSingleton(beanName, singletonObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singletonObject;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingleton</span><span class="params">(String beanName, Object singletonObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 添加到一级缓存</span></span><br><span class="line">        <span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br><span class="line">        <span class="comment">// 删除对应的二级缓存</span></span><br><span class="line">        <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">        <span class="comment">// 删除对应的三级缓存</span></span><br><span class="line">        <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">        <span class="comment">// 添加到已注册单例</span></span><br><span class="line">        <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注<code>singletonFactory.getObject()</code>，<code>singletonFactory</code>是一个函数式接口，对应<code>AbstractBeanFactory</code>的<code>doGetBean</code>方法中的lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建bean实例</span></span><br><span class="line">        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">        destroySingleton(beanName);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>重点关注<code>createBean</code>方法，该方法为抽象方法，由<code>AbstractBeanFactory</code>子类<code>AbstractAutowireCapableBeanFactory</code>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(<span class="string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化bean</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 执行MergedBeanDefinitionPostProcessor类型后置处理器</span></span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该bean是单例，并且允许循环依赖的出现以及该bean正在创建中</span></span><br><span class="line">    <span class="comment">// 那么就标识允许单例bean提前暴露原始对象引用</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">                                      isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 添加到单实例集合中，即三级缓存对象，该方法第二个参数类型为ObjectFactory函数式接口</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化bean</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 属性赋值</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 允许bean提前暴露</span></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">// 第二个参数为false标识仅从一级和二级缓存中获取bean单例</span></span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                <span class="comment">// 如果从一级和二级缓存中获取到bean实例为空</span></span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>addSingletonFactory</code>方法在父类<code>DefaultSingletonBeanRegistry</code>已实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加互斥锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">        <span class="comment">// 如果一级缓存没有，那么添加到三级缓存</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line">            <span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line">            <span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程总结如下：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/408/image3.svg" class="" title="getBean"><br />

<h2 id="面试逼问"><a href="#面试逼问" class="headerlink" title="面试逼问"></a>面试逼问</h2><p>（1）只用一级缓存是否可以解决循环依赖？<br>可以解决。</p>
<blockquote>
<p>对于一级缓存，我们不等对象初始化完成之后再存入缓存，而是等对象实例化完成后就提前暴露，存入一级缓存，由于此时缓存对象并没有进行初始化操作，即早期对象。那么A实例化完成提前暴露早期对象，A在属性注入时，发现B不在容器中，也没有提前暴露，那么去进行B的生命周期，B实例化后进行属性注入，发现A提前暴露，那么B可以从一级缓存中获取到A的早期对象完成初始化，回到A的生命周期从而A也可以完成初始化。<br>但是这样会引发另一个问题：早期对象和完整对象都存在一级缓存中，如果此时来了其他线程并发获取bean，就可能从一级缓存中获取到bean的早期对象，这样明显不行，那么我们不得已在从一级缓存获取对象处加一个互斥锁，以避免这个问题。<br>加互斥锁代理来另一个问题：容器刷新完成后的普通获取bean的请求都需要竞争锁，如果这样处理，在高并发场景下使用Spring的性能必然降低。</p>
</blockquote>
<p>（2）加上二级缓存有什么好处？</p>
<p>优化一级循环加锁带来的性能问题。</p>
<blockquote>
<p>将对象的早期对象存入二级缓存中，一级缓存用于存储完整对象。<br>这样B在创建过程中进行属性注入时，先从一级缓存中获取A，获取失败则从二级缓存中获取。<br>这种获取bean的逻辑也可能出现其他线程获取到早期对象的问题，所以还是要加互斥锁。只不过这里的加锁逻辑可以下沉到二级缓存。那么普通的getBean请求可以直接从一级缓存获取对象，而不用去竞争锁。</p>
</blockquote>
<p>（3）二级缓存如何解决AOP问题？</p>
<p>代理对象提前创建。</p>
<blockquote>
<p>Spring支持以CGLIB和JDK动态代理的方式为对象创建代理类以提供AOP支持，代理对象的创建通常是在bean初始化完成之后进行（通过BeanPostProcessor后置处理器）。<br>如果没有循环依赖，那么代理对象依然在初始化完成后创建，如果有循环依赖，那么提前创建代理对象。<br>如何判断发生了循环依赖？<br>在B创建的过程中获取A的时候，发现二级缓存中有A，就说明发生了循环依赖，此时就为A创建代理对象，将其覆盖到二级缓存中，并且将代理对象复制给B的对应数字。<br>当出现多级循环依赖的时候，可以在对象实例化完成之后，将beanName存在一个Set中，标识对应的bean正在创建中，而当其他对象创建的过程依赖某个对象的时候，判断其是否在这个Set中，如果在就说明发生了循环依赖。</p>
</blockquote>
<p>（4）那么三级缓存有什么作用？</p>
<p>虽然仅仅依靠二级缓存能够解决循环依赖和AOP的问题，但是从解决方案上来看，维护代理对象的逻辑和getBean的逻辑过于耦合。</p>
<blockquote>
<p>三级缓存的key还是为beanName，但是value是一个函数（ObjectFactory#getBean方法），在该函数中执行获取早期对象的逻辑：getEarlyBeanReference方法。 在getEarlyBeanReference方法中，Spring会调用所有SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference方法，通过该方法可以修改早期对象的属性或者替换早期对象。这个是Spring留给开发者的另一个扩展点，虽然我们很少使用，不过在循环依赖遇到AOP的时候，代理对象就是通过这个后置处理器创建。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] 🕊️ <a href="https://mrbird.cc/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96.html">鸟叔博客</a><br /><br>[2] 💤 <a href="https://zhuanlan.zhihu.com/p/375308988">黑哥知乎</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-bean的生命周期</title>
    <url>/posts/55590/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>懒得从spring源码角度分析，直接通过Demo演示总结bean的生命轨迹。</p>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">top.parak.springlearn</span><br><span class="line">├───config</span><br><span class="line">│   └───Config</span><br><span class="line">├───common</span><br><span class="line">│   └───KHighnessExecutingLog</span><br><span class="line">├───life</span><br><span class="line">│   └───KHighnessAwareBeanPostProcessor</span><br><span class="line">│   └───KHighnessBeanFactoryPostProcessor</span><br><span class="line">│   └───KHighnessBeanPostProcessor</span><br><span class="line">└───service</span><br><span class="line">│   └───UserInterface</span><br><span class="line">│   └───UserService</span><br><span class="line">└───KHighnessApplication </span><br></pre></td></tr></table></figure>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>日志输出记录类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.parak.springlearn.common;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KHighness</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-05-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessExecutingLog</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> AtomicLong COUNTER = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(FORMATTER.format(LocalDateTime.now()) + <span class="string">&quot; [&quot;</span> + COUNTER.incrementAndGet() + <span class="string">&quot;] =&gt; &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户业务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.parak.springlearn.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KHighness</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-04-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户业务接口实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.parak.springlearn.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.env.Environment;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ResourceLoader;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringValueResolver;</span><br><span class="line"><span class="keyword">import</span> top.parak.springlearn.common.KHighnessExecutingLog;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KHighness</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-04-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        /* 业务接口 */  <span class="title">UserInterface</span>,</span></span><br><span class="line"><span class="class">        /* <span class="title">Bean</span>接口 */ <span class="title">BeanNameAware</span>, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>,</span></span><br><span class="line"><span class="class">        /* 环境接口 */ <span class="title">EnvironmentAware</span>, <span class="title">EmbeddedValueResolverAware</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">MessageSourceAware</span>, <span class="title">ApplicationEventPublisherAware</span>, <span class="title">ApplicationContextAware</span>,</span></span><br><span class="line"><span class="class">        /* 后置接口 */ <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;构造函数: UserService.UserService() &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;set函数: UserService.setName() &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;自定义初始化: UserService.initMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;自定义销毁: UserService.destroyMethod()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入bean名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanNameAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入bean名称: BeanNameAware.setBeanName()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入bean类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanClassLoaderAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入bean类加载器: BeanClassLoaderAware.setBeanClassLoader()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入bean工厂</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> BeanFactoryAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入bean工厂: BeanFactoryAware.setBeanFactory()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入运行时环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> EnvironmentAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入运行时环境: EnvironmentAware.setEnvironment()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入文件解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> EmbeddedValueResolverAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmbeddedValueResolver</span><span class="params">(StringValueResolver stringValueResolver)</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入文件解析器: EmbeddedValueResolverAware.setEmbeddedValueResolver()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入资源加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ResourceLoaderAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceLoader)</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入资源加载器: ResourceLoaderAware.setResourceLoader()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入事件发布器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ApplicationEventPublisherAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入事件发布器: ApplicationEventPublisherAware.setApplicationEventPublisher()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入语言国际化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> MessageSourceAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessageSource</span><span class="params">(MessageSource messageSource)</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入语言国际化: MessageSourceAware.setMessageSource()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 传入应用上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> ApplicationContextAware</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;传入应用上下文: ApplicationContextAware.setApplicationContext()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;如名，属性设置之后执行&lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> InitializingBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;初始化: InitializingBean.afterPropertiesSet()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造之后</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postConstruct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;构造之后: @PostConstruct postConstruct()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁之前</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;销毁之前: @PreDestroy preDestroy()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> DisposableBean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;销毁bean: DisposableBean.destroy()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现业务接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> UserInterface</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;业务逻辑: UserInterface.test() &quot;</span> + <span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后置处理器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.parak.springlearn.life;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanFactoryPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.ConfigurableListableBeanFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.parak.springlearn.common.KHighnessExecutingLog;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KHighness</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-05-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;实例化前: BeanFactoryPostProcessor.postProcessBeanFactory()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.parak.springlearn.life;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.parak.springlearn.common.KHighnessExecutingLog;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KHighness</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-05-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;初始化前: BeanPostProcessor.postProcessBeforeInitialization()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        KHighnessExecutingLog.info(<span class="string">&quot;初始化后: BeanPostProcessor.postProcessAfterInitialization()&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.parak.springlearn.life;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> top.parak.springlearn.common.KHighnessExecutingLog;</span><br><span class="line"><span class="keyword">import</span> top.parak.springlearn.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KHighness</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-04-01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">InstantiationAwareBeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInstantiation</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanClass.equals(UserService.class)) &#123;</span><br><span class="line">            KHighnessExecutingLog.info(<span class="string">&quot;实例化前: UserServiceBeanPostProcessor.postProcessBeforeInstantiation()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回false则终止bean属性注入</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">postProcessAfterInstantiation</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean.getClass().equals(UserService.class)) &#123;</span><br><span class="line">            KHighnessExecutingLog.info(<span class="string">&quot;实例化后: UserServiceBeanPostProcessor.postProcessAfterInstantiation() &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;userService&quot;</span>)) &#123;</span><br><span class="line">            KHighnessExecutingLog.info(<span class="string">&quot;初始化前: UserServiceBeanPostProcessor.postProcessBeforeInitialization()&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Method method : bean.getClass().getMethods()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.isAnnotationPresent(PostConstruct.class)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        method.invoke(bean);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanName.equals(<span class="string">&quot;userService&quot;</span>)) &#123;</span><br><span class="line">            KHighnessExecutingLog.info(<span class="string">&quot;初始化后: UserServiceBeanPostProcessor.postProcessAfterInitialization() &quot;</span>);</span><br><span class="line">            <span class="comment">// 模拟动态代理AOP</span></span><br><span class="line">            <span class="keyword">return</span> Proxy.newProxyInstance(bean.getClass().getClassLoader(), bean.getClass().getInterfaces(), (proxy, method, args) -&gt; &#123;</span><br><span class="line">                KHighnessExecutingLog.info(<span class="string">&quot;动态代理: Proxy.newProxyInstance()&quot;</span>);</span><br><span class="line">                method.invoke(bean, args);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.parak.springlearn.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> top.parak.springlearn.service.UserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KHighness</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-05-06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;top.parak.springlearn&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(initMethod = &quot;initMethod&quot;, destroyMethod = &quot;destroyMethod&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserService();</span><br><span class="line">        userService.setName(<span class="string">&quot;KHighness&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.parak.springlearn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> top.parak.springlearn.config.Config;</span><br><span class="line"><span class="keyword">import</span> top.parak.springlearn.service.UserInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> KHighness</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 2021-03-30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(Config.class);</span><br><span class="line">        UserInterface userInterface = (UserInterface) applicationContext.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userInterface.test();</span><br><span class="line">        applicationContext.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.085</span> [<span class="number">1</span>] =&gt; 实例化前: BeanFactoryPostProcessor.postProcessBeanFactory()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.118</span> [<span class="number">2</span>] =&gt; 实例化前: InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.128</span> [<span class="number">3</span>] =&gt; 构造函数: UserService.UserService() </span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.129</span> [<span class="number">4</span>] =&gt; <span class="built_in">set</span>函数: UserService.setName() </span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.131</span> [<span class="number">5</span>] =&gt; 实例化后: InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation() </span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.136</span> [<span class="number">6</span>] =&gt; 传入bean名称: BeanNameAware.setBeanName()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.136</span> [<span class="number">7</span>] =&gt; 传入bean类加载器: BeanClassLoaderAware.setBeanClassLoader()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.136</span> [<span class="number">8</span>] =&gt; 传入bean工厂: BeanFactoryAware.setBeanFactory()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">9</span>] =&gt; 传入运行时环境: EnvironmentAware.setEnvironment()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">10</span>] =&gt; 传入文件解析器: EmbeddedValueResolverAware.setEmbeddedValueResolver()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">11</span>] =&gt; 传入资源加载器: ResourceLoaderAware.setResourceLoader()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">12</span>] =&gt; 传入事件发布器: ApplicationEventPublisherAware.setApplicationEventPublisher()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">13</span>] =&gt; 传入语言国际化: MessageSourceAware.setMessageSource()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">14</span>] =&gt; 传入应用上下文: ApplicationContextAware.setApplicationContext()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">15</span>] =&gt; 初始化前: InstantiationAwareBeanPostProcessor.postProcessBeforeInitialization()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">16</span>] =&gt; 构造之后: @PostConstruct postConstruct()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.137</span> [<span class="number">17</span>] =&gt; 初始化: InitializingBean.afterPropertiesSet()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.138</span> [<span class="number">18</span>] =&gt; 自定义初始化: UserService.initMethod()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.138</span> [<span class="number">19</span>] =&gt; 初始化后: InstantiationAwareBeanPostProcessor.postProcessAfterInitialization() </span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.140</span> [<span class="number">20</span>] =&gt; 初始化后: BeanPostProcessor.postProcessAfterInitialization()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.153</span> [<span class="number">21</span>] =&gt; 动态代理: Proxy.newProxyInstance()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.153</span> [<span class="number">22</span>] =&gt; 业务逻辑: UserInterface.test() KHighness</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.154</span> [<span class="number">23</span>] =&gt; 销毁之前: @PreDestroy preDestroy()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.154</span> [<span class="number">24</span>] =&gt; 销毁bean: DisposableBean.destroy()</span><br><span class="line"><span class="number">2021</span><span class="literal">-05</span><span class="literal">-14</span> <span class="number">14</span>:<span class="number">37</span>:<span class="number">37.154</span> [<span class="number">25</span>] =&gt; 自定义销毁: UserService.destroyMethod()</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>实例化<ol>
<li>实例化前：BeanFactoryPostProcessor#postProcessBeanFactory()</li>
<li>实例化前：InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation()</li>
<li>执行bean的构造函数</li>
<li>实例化后：InstantiationAwareBeanPostProcessor#postProcessAfterInstantiation()</li>
<li>为bean注入属性</li>
</ol>
</li>
<li>Bean接口回调<ol>
<li>传入bean名称：BeanNameAware#setBeanName()</li>
<li>传入bean类加载器：BeanClassLoaderAware#setBeanClassLoader()</li>
<li>传入bean工厂：BeanFactoryAware#setBeanFactory()</li>
</ol>
</li>
<li>Spring接口回调<ol>
<li>传入运行时环境：EnvironmentAware#setEnvironment()</li>
<li>传入文件解析器：EmbeddedValueResolverAware#setEmbeddedValueResolver()</li>
<li>传入资源加载器：ResourceLoaderAware#setResourceLoader()</li>
<li>传入事件发布器：ApplicationEventPublisherAware#setApplicationEventPublisher()</li>
<li>传入语言国家化：MessageSourceAware#setMessageSourceAware()</li>
<li>传入应用上下文：ApplicationContextAware#setApplicaionAware()</li>
</ol>
</li>
<li>初始化<ol>
<li>初始化前：InstantiationAwareBeanPostProcessor#postProcessBeforeInitialization()</li>
<li>构造之后：@PostConstruct标注的方法</li>
<li>初始化：InitializingBean#afterPropertiesSet()</li>
<li>自定义初始化：bean指定的initMethod</li>
<li>初始化后：InstantiationAwareBeanPostProcessor#postProcessAfterIntialization()</li>
<li>初始化后：BeanPostProcessor#postProcessAfterInitialization()</li>
</ol>
</li>
<li>销毁<ol>
<li>销毁之前：@PreDestroy标注的方法</li>
<li>销毁bean：DisposableBean#destroy()</li>
<li>自定义销毁：bean指定的destroyMethod</li>
</ol>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] 🚀 深究Spring中Bean的生命周期：<a href="https://www.cnblogs.com/javazhiyin/p/10905294.html">https://www.cnblogs.com/javazhiyin/p/10905294.html</a><br />[2] 🚢 Spring Bean的生命周期：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-组件注册</title>
    <url>/posts/39013/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你只管使用，一切交给IOC。</p>
<p>通过组件注册，IOC容器就自动帮助我们管理bean。​</p>
<p>创建项目，引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="Bean注册组件"><a href="#Bean注册组件" class="headerlink" title="@Bean注册组件"></a>@Bean注册组件</h2><p>创建一个实例类<code>User</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着创建一个配置类，在配置类中通过<code>@Bean</code>注解注册<code>User</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在SpringBoot入口类中编写如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> SpringApplicationBuilder(KHighnessApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">        User user = applicationContext.getBean(User.class);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行启动类，控制台输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">User(id=<span class="number">1</span>, name=KHighness)</span><br></pre></td></tr></table></figure>

<h2 id="ComponentSacn扫描包"><a href="#ComponentSacn扫描包" class="headerlink" title="@ComponentSacn扫描包"></a>@ComponentSacn扫描包</h2><p>在这个SpringBoot启动类所在包下创建其他类：UserDao、UserService、UserController，并且标注上响应注解，给<code>User</code>类标注<code>@Component</code>注解。</p>
<p>并修改配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;top.parak&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在启动类中获取所有的bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> SpringApplicationBuilder(KHighnessApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">        String[] names = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        Arrays.stream(names).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行启动类，观察控制台，有如下输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">KHighnessApplication</span><br><span class="line">org.springframework.boot.autoconfigure.internalCachingMetadataReaderFactory</span><br><span class="line">webConfig</span><br><span class="line">userController</span><br><span class="line">userDao</span><br><span class="line">user</span><br><span class="line">userService</span><br></pre></td></tr></table></figure>

<h2 id="Scope组件作用域"><a href="#Scope组件作用域" class="headerlink" title="@Scope组件作用域"></a>@Scope组件作用域</h2><p>默认情况下，在Spring的IOC容器中每个组件都是单例的，即无论在任何地方注入多少次，这些对象都是同一个。</p>
<p>将配置类修改回去：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">&quot;KHighness&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改SpringBoot启动类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> SpringApplicationBuilder(KHighnessApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">        Object user1 = applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        Object user2 = applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user1 == user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行启动类，控制台输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">true</span><br></pre></td></tr></table></figure>
<p>可以通过<code>@Scope</code>修改作用域，具体如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>singleton</td>
<td>单实例（默认），在Spring IOC容器启动的时候会调用方法创建对象然后纳入到IOC容器中，以后每次获取都是直接从IOC容器中获取</td>
</tr>
<tr>
<td>prototype</td>
<td>多实例，IOC容器启动的时候并不会去创建对象，而是在每次获取的时候才会去调用方法创建对象</td>
</tr>
<tr>
<td>request</td>
<td>一个请求对应一个实例</td>
</tr>
<tr>
<td>session</td>
<td>同一个session对应一个实例</td>
</tr>
</tbody></table>
<h2 id="Lazy懒加载"><a href="#Lazy懒加载" class="headerlink" title="@Lazy懒加载"></a>@Lazy懒加载</h2><p>懒加载是针对单例模式而言的，容器启动的时候会调用方法创建对象然后纳入到IOC容器中。</p>
<p>在User注册的地方打印一句话以观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;向IOC容器中注册user&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">&quot;KHighness&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在IOC容器启动后加入一句话以观察：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> SpringApplicationBuilder(KHighnessApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">System.out.println(<span class="string">&quot;IOC容器创建完毕&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>运行启动类，观察控制台，有如下输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">向IOC容器中注册user</span><br><span class="line"><span class="number">2021</span><span class="literal">-06</span><span class="literal">-28</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">13.064</span>  INFO <span class="number">49772</span> --- [           <span class="type">main</span>] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService <span class="string">&#x27;applicationTaskExecutor&#x27;</span></span><br><span class="line"><span class="number">2021</span><span class="literal">-06</span><span class="literal">-28</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">13.165</span>  INFO <span class="number">49772</span> --- [           <span class="type">main</span>] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): <span class="number">8080</span> (http) with context path <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="number">2021</span><span class="literal">-06</span><span class="literal">-28</span> <span class="number">16</span>:<span class="number">43</span>:<span class="number">13.168</span>  INFO <span class="number">49772</span> --- [           <span class="type">main</span>] top.parak.KHighnessApplication           : Started KHighnessApplication <span class="keyword">in</span> <span class="number">1.081</span> seconds (JVM running <span class="keyword">for</span> <span class="number">1.667</span>)</span><br><span class="line">IOC容器创建完毕</span><br></pre></td></tr></table></figure>
<p>可以看到，在IOC容器创建完毕之前，组件已经注册到容器中。</p>
<p>将User修改为懒加载注册：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;向IOC容器中注册user&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">&quot;KHighness&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将启动类修改一下，获取user：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> SpringApplicationBuilder(KHighnessApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">        System.out.println(<span class="string">&quot;IOC容器创建完毕&quot;</span>);</span><br><span class="line">        Object user = applicationContext.getBean(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行启动类，观察控制台，有如下输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">IOC容器创建完毕</span><br><span class="line">向IOC容器中注册user</span><br><span class="line">User(id=<span class="number">1</span>, name=KHighness)</span><br></pre></td></tr></table></figure>
<p>从输出看到，创建时并没有注册user，获取时才去注册，可以证明懒加载成功。​</p>
<h2 id="条件注册"><a href="#条件注册" class="headerlink" title="条件注册"></a>条件注册</h2><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>使用<code>@Conditional</code>注解我们指定组件注册的条件，即满足特定条件才将组件纳入到IOC容器中。</p>
<p>在使用该注解之前，先创建一个类，实现<code>Condition</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该接口包含一个<code>matches</code>方法，包含两个入参：</p>
<ol>
<li><code>ConditionContext</code>：上下文信息；</li>
<li><code>AnnotatedTypeMetadata</code>：注解信息。</li>
</ol>
<p>简单完善一下实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        String osName = conditionContext.getEnvironment().getProperty(<span class="string">&quot;os.name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> osName != <span class="keyword">null</span> &amp;&amp; osName.contains(<span class="string">&quot;windows&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将这个条件添加到注册User的地方：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional(MyCondition.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;向IOC容器中注册user&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(<span class="number">1L</span>, <span class="string">&quot;KHighness&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Windows系统下，User会被成功注册，其他操作系统下，这个组件则不会被注册到IOC容器中。</p>
<h3 id="Profile"><a href="#Profile" class="headerlink" title="@Profile"></a>@Profile</h3><p><code>@Profile</code>可以根据不同的环境变量来注册不同的组件。</p>
<p>新建一个接口<code>CalculateService</code>，用于求和：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="function">Integer <span class="title">sum</span><span class="params">(Integer... value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接着添加两个实现类<code>Java7CalculateServiceImpl</code>和<code>Java8CalculateServiceImpl</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Profile(&quot;java7&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java7CalculateServiceImpl</span> <span class="keyword">implements</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Integer... value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java7环境下执行&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : value)</span><br><span class="line">            res += val;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Profile(&quot;java8&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8CalculateServiceImpl</span> <span class="keyword">implements</span> <span class="title">CalculateService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">sum</span><span class="params">(Integer... value)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Java8环境下执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(value).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>@Profile</code>注解我们实现了：当环境变量包含<code>java7</code>的时候，<code>Java7CalculateServiceImpl</code>将会被注册到IOC容器中；当环境变量包含<code>java8</code>的时候，<code>Java8CalculateServiceImpl</code>将会被注册到IOC容器中。</p>
<p>修改启动类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> SpringApplicationBuilder(KHighnessApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .profiles(<span class="string">&quot;java8&quot;</span>)</span><br><span class="line">                .run(args);</span><br><span class="line">        CalculateService service = applicationContext.getBean(CalculateService.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;求和结果：&quot;</span> + service.sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行启动类，观察控制台，有如下输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java8环境下执行</span><br><span class="line">求和结果：<span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>同理，如果设置了环境变量<code>java7</code>的时候，将会输出<code>Java7环境下执行</code>。<br /></p>
<h2 id="导入组件"><a href="#导入组件" class="headerlink" title="导入组件"></a>导入组件</h2><h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><p>上面学习了使用<code>@Bean</code>和@<code>@ComponentScan</code>扫描实现组件注册，除此之外，我们还可以使用<code>@Import</code>来快速地往IOC容器中添加组件。</p>
<p>创建一个新的类<code>Hello</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在配置类中导入这个组件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;Hello.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;...</span><br></pre></td></tr></table></figure>
<p>修改启动类，查看所有组件的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KHighnessApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext applicationContext = <span class="keyword">new</span> SpringApplicationBuilder(KHighnessApplication.class)</span><br><span class="line">                .web(WebApplicationType.SERVLET)</span><br><span class="line">                .run(args);</span><br><span class="line">        String[] names = applicationContext.getBeanDefinitionNames();</span><br><span class="line">        Arrays.stream(names).forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行启动类，观察控制台，有如下输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">top.parak.entity.Hello</span><br></pre></td></tr></table></figure>
<p>可以看到，通过<code>@Import</code>我们可以快速向容器中添加组件，默认名称为全类名。</p>
<h3 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h3><p>通过<code>@Import</code>可以实现组件导入，如果需要一次性导入较多组件，我们可以使用<code>@ImportSelector</code>来实现。</p>
<p>查看<code>ImportSelector</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Select and return the names of which class(es) should be imported based on</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125; of the importing @&#123;<span class="doctag">@link</span> Configuration&#125; class.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] selectImports(AnnotationMetadata importingClassMetadata);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ImportSelector</code>是一个接口，包含一个<code>selectImports</code>方法，方法返回的类的全类名数组（即需要导入到IOC容器中组件的全类名数组），包含一个<code>@AnnotationMetadata</code>类型入参，通过这个参数我们可以获取到使用<code>ImportSelector</code>的类的全部注解信息。</p>
<p>新建三个类，分别为<code>Orange</code>、<code>Banana</code>和<code>Pineapple</code>。</p>
<p>新建一个<code>ImportSelector</code>实现类<code>MyImportSelector</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;</span><br><span class="line">                <span class="string">&quot;top.parak.entity.Orange&quot;</span>,</span><br><span class="line">                <span class="string">&quot;top.parak.entity.Banana&quot;</span>,</span><br><span class="line">                <span class="string">&quot;top.parak.entity.Pineapple&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着通过<code>@Import</code>注解将<code>MyImportSelector</code>把丧组件快速导入到容器中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import(MyImportSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;...</span><br></pre></td></tr></table></figure>
<p>运行启动类，观察控制台，发现有如下输出：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">top.parak.entity.Orange</span><br><span class="line">top.parak.entity.Banana</span><br><span class="line">top.parak.entity.Pineapple</span><br></pre></td></tr></table></figure>
<p>说明三个组件已经批量导入。</p>
<h3 id="ImportBeanDefinitionRegistor"><a href="#ImportBeanDefinitionRegistor" class="headerlink" title="ImportBeanDefinitionRegistor"></a>ImportBeanDefinitionRegistor</h3><p>除了上述两种向IOC容器中导入组件的方法外，我们还可以使用<code>ImportBeanDefinitionRegistrar</code>来手动往IOC容器中导入组件。</p>
<p>查看<code>ImportBeanDefinitionRegistrar</code>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ImportBeanDefinitionRegistrar</code>是一个接口，包含一个<code>registerBeanDefinitions</code>方法，该方法包含两个入参：</p>
<ol>
<li><code>AnnotationMetadata</code>：可以通过它获取类的注解信息；</li>
<li><code>BeanDefinitionRegistry</code>：Bean定义注册器，包含了一些和Bean有关的方法：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanDefinitionStoreException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">	String[] getBeanDefinitionNames();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里借助<code>BeanDefinitionRegistry</code>的<code>registerBeanDefinition</code>方法往IOC容器中注册Bean。该方法包含两个入参，第一个参数为需要注册的Bean名称，第二个参数为Bean的定义信息，它是一个接口，我们可以用其实现类<code>RootBeanDefinition</code>来完成：</li>
</ol>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/39013/image1.png" class="" title="image1"><br />

<p>为了演示<code>ImportBeanDefinitionRegistrar</code>的使用，新增一个类<code>Blueberry</code>。</p>
<p>创建一个<code>ImportBeanDefinitionRegistrar</code>实现类<code>MyImportBeanDefinitionRegistrar</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String beanName = <span class="string">&quot;blueberry&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> contain = registry.containsBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (!contain) &#123;</span><br><span class="line">            RootBeanDefinition rootBeanDefinition = <span class="keyword">new</span> RootBeanDefinition(Blueberry.class);</span><br><span class="line">            registry.registerBeanDefinition(beanName, rootBeanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在配置类中导入：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(&#123;MyImportBeanDefinitionRegistrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;...</span><br></pre></td></tr></table></figure>
<p>运行启动类，观察控制台，有如下输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">blueberry</span><br></pre></td></tr></table></figure>
<p>说明组件注册成功。</p>
<h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>Spring提供了<code>FactoryBean</code>接口，我们可以通过该接口来注册组件，该接口包含两个抽象方法和一个默认方法：</p>
<img src= "https://khighness-blog.oss-cn-shanghai.aliyuncs.com/common/loading.gif" data-lazy-src="/posts/39013/image2.png" class="" title="image2">
<br />

<p>为了演示<code>FactoryBean</code>的作用，新建一个类<code>Cherry</code>。</p>
<p>然后创建<code>FactoryBean</code>的实现类<code>CherryFactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CherryFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Cherry</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Cherry <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cherry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Cherry.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在配置类中注册即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CherryFactoryBean <span class="title">cherryFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CherryFactoryBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改启动类，获取<code>cherryFactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object bean = applicationContext.getBean(<span class="string">&quot;cherryFactoryBean&quot;</span>);</span><br><span class="line">System.out.println(bean.getClass());</span><br></pre></td></tr></table></figure>
<p>运行启动类，观察控制台，有如下输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">top</span>.<span class="title">parak</span>.<span class="title">entity</span>.<span class="title">Cherry</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到，虽然获取的是ID为<code>cherryFactoryBean</code>的组件，但是实际上获取到的是<code>getObject</code>里返回的对象。</p>
<p>如果要获取<code>cherryFactoryBean</code>本身，则可以这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object bean = applicationContext.getBean(<span class="string">&quot;&amp;cherryFactoryBean&quot;</span>);</span><br><span class="line">System.out.println(bean.getClass());</span><br></pre></td></tr></table></figure>
<p>重新运行，输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">top</span>.<span class="title">parak</span>.<span class="title">entity</span>.<span class="title">CherryFactoryBean</span></span></span><br></pre></td></tr></table></figure>

<div class="note icon simple"><i class="note-icon fas fa-bolt"></i><p>为什么这里加上<code>&amp;</code>前缀就可以获取到相应的工厂类？</p>
<p>查看<code>BeanFactory</code>源码就可以看到原因：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment">	 * beans &lt;i&gt;cre